 
//----------------------------------------------------------------------------
//  Copyright (C) 2004-2018 by EMGU Corporation. All rights reserved.       
//  This code is automatically generated by a program from Tensorflow 1.7.0.  
//  Please do not modify manually.
//----------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Text;
using Emgu.TF.Util;
using System.Runtime.InteropServices;

namespace Emgu.TF
{
   public partial class Graph : UnmanagedObject
   {
      
      ///<summary>
      ///Computes the product a * b, but only for indices (i, j) in mask_indices. The
      ///</summary>
      ///<param name="a">Input to the operation: A rank 2 tensor of shape [m, n].</param>
      ///<param name="b">Input to the operation: A rank 2 tensor of shape [s, t]. The inner dimensions of a and b should match after transposition.</param>
      ///<param name="mask_indices">Input to the operation: A rank 2 tensor, of shape [nnz, 2] where nnz is the number of non-zero elements in the output. The indices are not assumed to be in lexicographic, or any particular order. For all i, mask_indices[i, :] should represent a valid index of the product matrix (a * b) (after transposition). That is: mask_indices[i, 0] should be in [0, m) if !transpose_a, and in [0, n)   otherwise. mask_indices[i, 1] should be in [0, t) if !transpose_b, and in [0, s)   otherwise.</param>
      ///<param name="transpose_a">Input to the operation: A boolean, specifies whether to transpose the matrix a.</param>
      ///<param name="transpose_b">Input to the operation: A boolean, specifies whether to transpose the matrix b.  Output arguments:</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] prod_values(type: DtFloat): A rank 1 tensor of shape [nnz], representing the values of the non-zero elements in the product, such that for all i, prod_values[i] = (a * b)[mask_indices[i, 0], mask_indices[i, 1]].
      ///</return>
      public Operation MaskedMatmul (  Output a , Output b , Output mask_indices , Output transpose_a , Output transpose_b ,String opName= "MaskedMatmul" ) 
      {
         OperationDescription desc = NewOperation("MaskedMatmul", opName);
         desc.AddInput(a);
         desc.AddInput(b);
         desc.AddInput(mask_indices);
         desc.AddInput(transpose_a);
         desc.AddInput(transpose_b);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///Writes a set of weights into the opaque params buffer so they can be used in
      ///</summary>
      ///<param name="num_layers">Input to the operation: Specifies the number of layers in the RNN model.</param>
      ///<param name="num_units">Input to the operation: Specifies the size of the hidden state.</param>
      ///<param name="input_size">Input to the operation: Specifies the size of the input state.</param>
      ///<param name="weights">Input to the operation: the canonical form of weights that can be used for saving and restoration. They are more likely to be compatible across different generations.</param>
      ///<param name="biases">Input to the operation: the canonical form of biases that can be used for saving     and restoration. They are more likely to be compatible across different     generations.  Note that the params buffer may not be compatible across different GPUs. So any save and restoration should be converted to and from the canonical weights and biases.</param>
      ///<param name="rnn_mode">Indicates the type of the RNN model.</param>
      ///<param name="input_mode">Indicate whether there is a linear projection between the input and The actual computation before the first layer. 'skip_input' is only allowed when input_size == num_units; 'auto_select' implies 'skip_input' when input_size == num_units; otherwise, it implies 'linear_input'.</param>
      ///<param name="direction">Indicates whether a bidirectional model will be used. dir = (direction == bidirectional) ? 2 : 1</param>
      ///<param name="dropout">dropout probability. When set to 0., dropout is disabled.</param>
      ///<param name="seed">the 1st part of a seed to initialize dropout.</param>
      ///<param name="seed2">the 2nd part of a seed to initialize dropout.</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] params(type: DtInvalid).
      ///</return>
      public Operation CudnnRNNCanonicalToParams (  Output num_layers , Output num_units , Output input_size , Output weights , Output biases , string rnn_mode = null , string input_mode = null , string direction = null , float dropout = 0f , long seed = 0 , long seed2 = 0 ,String opName= "CudnnRNNCanonicalToParams" ) 
      {
         OperationDescription desc = NewOperation("CudnnRNNCanonicalToParams", opName);
         desc.AddInput(num_layers);
         desc.AddInput(num_units);
         desc.AddInput(input_size);
         desc.AddInput(weights);
         desc.AddInput(biases);

         if (rnn_mode != null) desc.SetAttr("rnn_mode", rnn_mode);
         if (input_mode != null) desc.SetAttr("input_mode", input_mode);
         if (direction != null) desc.SetAttr("direction", direction);
         if (dropout != 0f) desc.SetAttr("dropout", dropout);
         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         return desc.FinishOperation();
      } 
      // Skipped function _CopyFromGpuToHost

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="axis">Input to the operation. </param>
      ///<param name="out_idx"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///[1] idx(type: DtInvalid).
      ///</return>
      public Operation UniqueV2 (  Output x , Output axis , DataType? out_idx = null ,String opName= "UniqueV2" ) 
      {
         OperationDescription desc = NewOperation("UniqueV2", opName);
         desc.AddInput(x);
         desc.AddInput(axis);

         if (out_idx.HasValue) desc.SetAttr("out_idx", out_idx.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///Creates a handle to a StatsAccumulatorTensorResource
      ///</summary>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] resource(type: DtResource).
      ///</return>
      public Operation StatsAccumulatorTensorResourceHandleOp (  string container = null , string shared_name = null ,String opName= "StatsAccumulatorTensorResourceHandleOp" ) 
      {
         OperationDescription desc = NewOperation("StatsAccumulatorTensorResourceHandleOp", opName);


         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///Retrieves the tree ensemble resource stamp token.
      ///</summary>
      ///<param name="tree_ensemble_handle">Input to the operation: Handle to the tree ensemble.</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] stamp_token(type: DtInt64): Stamp token of the tree ensemble resource.
      ///</return>
      public Operation TreeEnsembleStampToken (  Output tree_ensemble_handle ,String opName= "TreeEnsembleStampToken" ) 
      {
         OperationDescription desc = NewOperation("TreeEnsembleStampToken", opName);
         desc.AddInput(tree_ensemble_handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="concat_dim">Input to the operation. </param>
      ///<param name="values">Input to the operation. </param>
      ///<param name="input_mins">Input to the operation. </param>
      ///<param name="input_maxes">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///[1] output_min(type: DtFloat).
      ///[2] output_max(type: DtFloat).
      ///</return>
      public Operation QuantizedConcat (  Output concat_dim , Output values , Output input_mins , Output input_maxes ,String opName= "QuantizedConcat" ) 
      {
         OperationDescription desc = NewOperation("QuantizedConcat", opName);
         desc.AddInput(concat_dim);
         desc.AddInput(values);
         desc.AddInput(input_mins);
         desc.AddInput(input_maxes);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///Creates a tree ensemble model and returns a handle to it.
      ///</summary>
      ///<param name="tree_ensemble_handle">Input to the operation: Handle to the tree ensemble resource to be created.</param>
      ///<param name="stamp_token">Input to the operation: Token to use as the initial value of the resource stamp.</param>
      ///<param name="tree_ensemble_config">Input to the operation: Serialized proto of the tree ensemble.</param>
      ///<param name="opName">The name of the operation</param>
      public Operation CreateTreeEnsembleVariable (  Output tree_ensemble_handle , Output stamp_token , Output tree_ensemble_config ,String opName= "CreateTreeEnsembleVariable" ) 
      {
         OperationDescription desc = NewOperation("CreateTreeEnsembleVariable", opName);
         desc.AddInput(tree_ensemble_handle);
         desc.AddInput(stamp_token);
         desc.AddInput(tree_ensemble_config);


         return desc.FinishOperation();
      } 
      // Skipped function _CopyFromHostToGpu

      ///<summary>
      ///
      ///</summary>
      ///<param name="images">Input to the operation. </param>
      ///<param name="size">Input to the operation. </param>
      ///<param name="align_corners"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] resized_images(type: DtFloat).
      ///</return>
      public Operation ResizeBicubic (  Output images , Output size , bool align_corners = false ,String opName= "ResizeBicubic" ) 
      {
         OperationDescription desc = NewOperation("ResizeBicubic", opName);
         desc.AddInput(images);
         desc.AddInput(size);

         if (align_corners != false) desc.SetAttr("align_corners", align_corners);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///  Returns the probability that each input will reach each leaf node.
      ///</summary>
      ///<param name="input_data">Input to the operation. </param>
      ///<param name="tree_parameters">Input to the operation. </param>
      ///<param name="tree_biases">Input to the operation. </param>
      ///<param name="max_nodes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] probabilities(type: DtFloat).
      ///</return>
      public Operation RoutingFunction (  Output input_data , Output tree_parameters , Output tree_biases , long max_nodes,String opName= "RoutingFunction" ) 
      {
         OperationDescription desc = NewOperation("RoutingFunction", opName);
         desc.AddInput(input_data);
         desc.AddInput(tree_parameters);
         desc.AddInput(tree_biases);
         desc.SetAttr("max_nodes", max_nodes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///Creates a handle to a DecisionTreeEnsembleResource
      ///</summary>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] resource(type: DtResource).
      ///</return>
      public Operation DecisionTreeEnsembleResourceHandleOp (  string container = null , string shared_name = null ,String opName= "DecisionTreeEnsembleResourceHandleOp" ) 
      {
         OperationDescription desc = NewOperation("DecisionTreeEnsembleResourceHandleOp", opName);


         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///Adds each quantile summary to its stream.
      ///</summary>
      ///<param name="quantile_accumulator_handles">Input to the operation: The handles to the quantile stream resources.</param>
      ///<param name="stamp_token">Input to the operation: Stamp token to validate the Read/Write operation.</param>
      ///<param name="summaries">Input to the operation: A list of serialized QuantileSummaryState.</param>
      ///<param name="opName">The name of the operation</param>
      public Operation QuantileAccumulatorAddSummaries (  Output quantile_accumulator_handles , Output stamp_token , Output summaries ,String opName= "QuantileAccumulatorAddSummaries" ) 
      {
         OperationDescription desc = NewOperation("QuantileAccumulatorAddSummaries", opName);
         desc.AddInput(quantile_accumulator_handles);
         desc.AddInput(stamp_token);
         desc.AddInput(summaries);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="squeeze_dims"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Squeeze (  Output input , long[] squeeze_dims = null ,String opName= "Squeeze" ) 
      {
         OperationDescription desc = NewOperation("Squeeze", opName);
         desc.AddInput(input);

         if (squeeze_dims != null) desc.SetAttr("squeeze_dims", squeeze_dims);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="n">Input to the operation. </param>
      ///<param name="reverse"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] values(type: DtInvalid).
      ///</return>
      public Operation NthElement (  Output input , Output n , bool reverse = false ,String opName= "NthElement" ) 
      {
         OperationDescription desc = NewOperation("NthElement", opName);
         desc.AddInput(input);
         desc.AddInput(n);

         if (reverse != false) desc.SetAttr("reverse", reverse);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="record_bytes"></param>
      ///<param name="header_bytes"></param>
      ///<param name="footer_bytes"></param>
      ///<param name="hop_bytes"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="encoding"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] reader_handle(type: DtResource).
      ///</return>
      public Operation FixedLengthRecordReaderV2 (  long record_bytes, long header_bytes = 0 , long footer_bytes = 0 , long hop_bytes = 0 , string container = null , string shared_name = null , string encoding = null ,String opName= "FixedLengthRecordReaderV2" ) 
      {
         OperationDescription desc = NewOperation("FixedLengthRecordReaderV2", opName);

         desc.SetAttr("record_bytes", record_bytes);
         if (header_bytes != 0) desc.SetAttr("header_bytes", header_bytes);
         if (footer_bytes != 0) desc.SetAttr("footer_bytes", footer_bytes);
         if (hop_bytes != 0) desc.SetAttr("hop_bytes", hop_bytes);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         if (encoding != null) desc.SetAttr("encoding", encoding);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="orig_input">Input to the operation. </param>
      ///<param name="orig_output">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="ksize"></param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="data_format"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation MaxPoolGradGrad (  Output orig_input , Output orig_output , Output grad , long[] ksize, long[] strides, string padding, string data_format = null ,String opName= "MaxPoolGradGrad" ) 
      {
         OperationDescription desc = NewOperation("MaxPoolGradGrad", opName);
         desc.AddInput(orig_input);
         desc.AddInput(orig_output);
         desc.AddInput(grad);
         desc.SetAttr("ksize", ksize);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///Splits input examples into the leaves of the tree.
      ///</summary>
      ///<param name="tree_ensemble_handle">Input to the operation: The handle to the tree ensemble.</param>
      ///<param name="dense_float_features">Input to the operation: Rank 2 Tensors containing dense float feature values.</param>
      ///<param name="sparse_float_feature_indices">Input to the operation: Rank 2 Tensors containing sparse float indices.</param>
      ///<param name="sparse_float_feature_values">Input to the operation: Rank 1 Tensors containing sparse float values.</param>
      ///<param name="sparse_float_feature_shapes">Input to the operation: Rank 1 Tensors containing sparse float shapes.</param>
      ///<param name="sparse_int_feature_indices">Input to the operation: Rank 2 Tensors containing sparse int indices.</param>
      ///<param name="sparse_int_feature_values">Input to the operation: Rank 1 Tensors containing sparse int values.</param>
      ///<param name="sparse_int_feature_shapes">Input to the operation: Rank 1 Tensors containing sparse int shapes.</param>
      ///<param name="use_locking">Whether to use locking.</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] partition_ids(type: DtInt32): Rank 1 Tensor containing partition ids per example.
      ///</return>
      public Operation GradientTreesPartitionExamples (  Output tree_ensemble_handle , Output dense_float_features , Output sparse_float_feature_indices , Output sparse_float_feature_values , Output sparse_float_feature_shapes , Output sparse_int_feature_indices , Output sparse_int_feature_values , Output sparse_int_feature_shapes , bool use_locking = false ,String opName= "GradientTreesPartitionExamples" ) 
      {
         OperationDescription desc = NewOperation("GradientTreesPartitionExamples", opName);
         desc.AddInput(tree_ensemble_handle);
         desc.AddInput(dense_float_features);
         desc.AddInput(sparse_float_feature_indices);
         desc.AddInput(sparse_float_feature_values);
         desc.AddInput(sparse_float_feature_shapes);
         desc.AddInput(sparse_int_feature_indices);
         desc.AddInput(sparse_int_feature_values);
         desc.AddInput(sparse_int_feature_shapes);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="inputs">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///[1] value_index(type: DtInt32).
      ///</return>
      public Operation Merge (  Output inputs ,String opName= "Merge" ) 
      {
         OperationDescription desc = NewOperation("Merge", opName);
         desc.AddInput(inputs);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="value">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] flow_out(type: DtFloat).
      ///</return>
      public Operation TensorArrayUnpack (  Output handle , Output value , Output flow_in ,String opName= "TensorArrayUnpack" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayUnpack", opName);
         desc.AddInput(handle);
         desc.AddInput(value);
         desc.AddInput(flow_in);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="other_arguments">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      //The following attributes are not known: f: func
      public Operation MapDataset (  Output input_dataset , Output other_arguments , DataType[] output_types, long[][] output_shapes,String opName= "MapDataset" ) 
      {
         OperationDescription desc = NewOperation("MapDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(other_arguments);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///Checks whether a tree ensemble has been initialized.
      ///</summary>
      ///<param name="tree_ensemble_handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] is_initialized(type: DtBool).
      ///</return>
      public Operation TreeEnsembleIsInitializedOp (  Output tree_ensemble_handle ,String opName= "TreeEnsembleIsInitializedOp" ) 
      {
         OperationDescription desc = NewOperation("TreeEnsembleIsInitializedOp", opName);
         desc.AddInput(tree_ensemble_handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="filenames">Input to the operation. </param>
      ///<param name="header_bytes">Input to the operation. </param>
      ///<param name="record_bytes">Input to the operation. </param>
      ///<param name="footer_bytes">Input to the operation. </param>
      ///<param name="buffer_size">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation FixedLengthRecordDataset (  Output filenames , Output header_bytes , Output record_bytes , Output footer_bytes , Output buffer_size ,String opName= "FixedLengthRecordDataset" ) 
      {
         OperationDescription desc = NewOperation("FixedLengthRecordDataset", opName);
         desc.AddInput(filenames);
         desc.AddInput(header_bytes);
         desc.AddInput(record_bytes);
         desc.AddInput(footer_bytes);
         desc.AddInput(buffer_size);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///Return the params size that can be used by the Cudnn RNN model. Subsequent
      ///</summary>
      ///<param name="num_layers">Input to the operation: Specifies the number of layers in the RNN model.</param>
      ///<param name="num_units">Input to the operation: Specifies the size of the hidden state.</param>
      ///<param name="input_size">Input to the operation: Specifies the size of the input state.</param>
      ///<param name="T"></param>
      ///<param name="S"></param>
      ///<param name="rnn_mode">Indicates the type of the RNN model.</param>
      ///<param name="input_mode">Indicate whether there is a linear projection between the input and The actual computation before the first layer. 'skip_input' is only allowed when input_size == num_units; 'auto_select' implies 'skip_input' when input_size == num_units; otherwise, it implies 'linear_input'.</param>
      ///<param name="direction">Indicates whether a bidirectional model will be used. dir = (direction == bidirectional) ? 2 : 1</param>
      ///<param name="dropout">dropout probability. When set to 0., dropout is disabled.</param>
      ///<param name="seed">the 1st part of a seed to initialize dropout.</param>
      ///<param name="seed2">the 2nd part of a seed to initialize dropout.</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] params_size(type: DtInvalid): The size of the params buffer that should be allocated and     initialized for this RNN model. Note that this params buffer may not be     compatible across GPUs. Please use CudnnRNNParamsWeights and     CudnnRNNParamsBiases to save and restore them in a way that is compatible     across different runs.  Note that the params buffer may not be compatible across different GPUs. So any save and restoration should be converted to and from the canonical weights and biases.
      ///</return>
      public Operation CudnnRNNParamsSize (  Output num_layers , Output num_units , Output input_size , DataType T, DataType S, string rnn_mode = null , string input_mode = null , string direction = null , float dropout = 0f , long seed = 0 , long seed2 = 0 ,String opName= "CudnnRNNParamsSize" ) 
      {
         OperationDescription desc = NewOperation("CudnnRNNParamsSize", opName);
         desc.AddInput(num_layers);
         desc.AddInput(num_units);
         desc.AddInput(input_size);
         desc.SetAttr("T", T);
         desc.SetAttr("S", S);
         if (rnn_mode != null) desc.SetAttr("rnn_mode", rnn_mode);
         if (input_mode != null) desc.SetAttr("input_mode", input_mode);
         if (direction != null) desc.SetAttr("direction", direction);
         if (dropout != 0f) desc.SetAttr("dropout", dropout);
         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///Using the provided cumulative distribution functions (CDF) inside `cdf`, returns
      ///</summary>
      ///<param name="data">Input to the operation: An int32 tensor.</param>
      ///<param name="cdf">Input to the operation: An int32 tensor representing the CDF's of `data`. Each integer is divided by `2^precision` to represent a fraction.</param>
      ///<param name="precision">The number of bits for probability quantization. Must be &lt;= 16.</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] encoded(type: DtString): A range-coded scalar string.
      ///</return>
      public Operation RangeEncode (  Output data , Output cdf , long precision,String opName= "RangeEncode" ) 
      {
         OperationDescription desc = NewOperation("RangeEncode", opName);
         desc.AddInput(data);
         desc.AddInput(cdf);
         desc.SetAttr("precision", precision);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation GuaranteeConst (  Output input ,String opName= "GuaranteeConst" ) 
      {
         OperationDescription desc = NewOperation("GuaranteeConst", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="dtypes"></param>
      ///<param name="capacity"></param>
      ///<param name="memory_limit"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] size(type: DtInt32).
      ///</return>
      public Operation MapIncompleteSize (  DataType[] dtypes, long capacity = 0 , long memory_limit = 0 , string container = null , string shared_name = null ,String opName= "MapIncompleteSize" ) 
      {
         OperationDescription desc = NewOperation("MapIncompleteSize", opName);

         desc.SetAttr("dtypes", dtypes);
         if (capacity != 0) desc.SetAttr("capacity", capacity);
         if (memory_limit != 0) desc.SetAttr("memory_limit", memory_limit);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///Find the split that has the best gain for the accumulated stats.
      ///</summary>
      ///<param name="num_minibatches">Input to the operation: A scalar, the number of times per example gradients & hessians were accumulated. The stats are divided by this to get per example stats.</param>
      ///<param name="partition_ids">Input to the operation: A rank 1 tensor of partition IDs.</param>
      ///<param name="feature_ids">Input to the operation: A rank 2 tensor of feature IDs and dimensions.</param>
      ///<param name="gradients">Input to the operation: A rank 1 tensor of gradients.</param>
      ///<param name="hessians">Input to the operation: A rank 1 tensor of hessians.</param>
      ///<param name="class_id">Input to the operation. </param>
      ///<param name="feature_column_group_id"></param>
      ///<param name="bias_feature_id"></param>
      ///<param name="l1_regularization"></param>
      ///<param name="l2_regularization"></param>
      ///<param name="tree_complexity_regularization"></param>
      ///<param name="min_node_weight"></param>
      ///<param name="multiclass_strategy"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_partition_ids(type: DtInt32): A rank 1 tensor, the partition IDs that we created splits for.
      ///[1] gains(type: DtFloat): A rank 1 tensor, for the computed gain for the created splits.
      ///[2] split_infos(type: DtString): A rank 1 tensor of serialized protos which contains the `SplitInfo`s.
      ///</return>
      public Operation BuildCategoricalEqualitySplits (  Output num_minibatches , Output partition_ids , Output feature_ids , Output gradients , Output hessians , Output class_id , long feature_column_group_id, long bias_feature_id, float l1_regularization, float l2_regularization, float tree_complexity_regularization, float min_node_weight, long multiclass_strategy,String opName= "BuildCategoricalEqualitySplits" ) 
      {
         OperationDescription desc = NewOperation("BuildCategoricalEqualitySplits", opName);
         desc.AddInput(num_minibatches);
         desc.AddInput(partition_ids);
         desc.AddInput(feature_ids);
         desc.AddInput(gradients);
         desc.AddInput(hessians);
         desc.AddInput(class_id);
         desc.SetAttr("feature_column_group_id", feature_column_group_id);
         desc.SetAttr("bias_feature_id", bias_feature_id);
         desc.SetAttr("l1_regularization", l1_regularization);
         desc.SetAttr("l2_regularization", l2_regularization);
         desc.SetAttr("tree_complexity_regularization", tree_complexity_regularization);
         desc.SetAttr("min_node_weight", min_node_weight);
         desc.SetAttr("multiclass_strategy", multiclass_strategy);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="data">Input to the operation. </param>
      ///<param name="message"></param>
      ///<param name="first_n"></param>
      ///<param name="summarize"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Print (  Output input , Output data , string message = null , long first_n = -1 , long summarize = 3 ,String opName= "Print" ) 
      {
         OperationDescription desc = NewOperation("Print", opName);
         desc.AddInput(input);
         desc.AddInput(data);

         if (message != null) desc.SetAttr("message", message);
         if (first_n != -1) desc.SetAttr("first_n", first_n);
         if (summarize != 3) desc.SetAttr("summarize", summarize);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///Serializes the tree ensemble to a proto.
      ///</summary>
      ///<param name="tree_ensemble_handle">Input to the operation: Handle to the tree ensemble.</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] stamp_token(type: DtInt64): Stamp token of the tree ensemble resource.
      ///[1] tree_ensemble_config(type: DtString): Serialized proto of the ensemble.
      ///</return>
      public Operation TreeEnsembleSerialize (  Output tree_ensemble_handle ,String opName= "TreeEnsembleSerialize" ) 
      {
         OperationDescription desc = NewOperation("TreeEnsembleSerialize", opName);
         desc.AddInput(tree_ensemble_handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///Creates a resource that fills up a buffer by making function calls.
      ///</summary>
      ///<param name="string_arg">Input to the operation: String argument to the function call.</param>
      ///<param name="target_device">Input to the operation: Target device to execute the function on.</param>
      ///<param name="shared_name">If non-empty, this resource will be shared under the given name across multiple sessions.</param>
      ///<param name="container">If non-empty, this resource is placed in the given container. Otherwise, a default container is used.</param>
      ///<param name="buffer_size">Size of the buffer.</param>
      ///<param name="thread_pool_size">Size of the threadpool doing the prefetching.</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] resource(type: DtResource): Handle to the resource created.
      ///</return>
      //The following attributes are not known: f: func
      public Operation FunctionBufferingResource (  Output string_arg , Output target_device , string shared_name, string container, long buffer_size, long thread_pool_size,String opName= "FunctionBufferingResource" ) 
      {
         OperationDescription desc = NewOperation("FunctionBufferingResource", opName);
         desc.AddInput(string_arg);
         desc.AddInput(target_device);
         desc.SetAttr("shared_name", shared_name);
         desc.SetAttr("container", container);
         desc.SetAttr("buffer_size", buffer_size);
         desc.SetAttr("thread_pool_size", thread_pool_size);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///Deserializes a serialized tree ensemble config and replaces current tree
      ///</summary>
      ///<param name="tree_ensemble_handle">Input to the operation: Handle to the tree ensemble.</param>
      ///<param name="stamp_token">Input to the operation: Token to use as the new value of the resource stamp.</param>
      ///<param name="tree_ensemble_config">Input to the operation: Serialized proto of the ensemble.</param>
      ///<param name="opName">The name of the operation</param>
      public Operation TreeEnsembleDeserialize (  Output tree_ensemble_handle , Output stamp_token , Output tree_ensemble_config ,String opName= "TreeEnsembleDeserialize" ) 
      {
         OperationDescription desc = NewOperation("TreeEnsembleDeserialize", opName);
         desc.AddInput(tree_ensemble_handle);
         desc.AddInput(stamp_token);
         desc.AddInput(tree_ensemble_config);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="l">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation CholeskyGrad (  Output l , Output grad ,String opName= "CholeskyGrad" ) 
      {
         OperationDescription desc = NewOperation("CholeskyGrad", opName);
         desc.AddInput(l);
         desc.AddInput(grad);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="num_buckets"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInt64).
      ///</return>
      public Operation StringToHashBucketFast (  Output input , long num_buckets,String opName= "StringToHashBucketFast" ) 
      {
         OperationDescription desc = NewOperation("StringToHashBucketFast", opName);
         desc.AddInput(input);
         desc.SetAttr("num_buckets", num_buckets);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="a">Input to the operation. </param>
      ///<param name="b">Input to the operation. </param>
      ///<param name="transpose_a"></param>
      ///<param name="transpose_b"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] product(type: DtInvalid).
      ///</return>
      public Operation MatMul (  Output a , Output b , bool transpose_a = false , bool transpose_b = false ,String opName= "MatMul" ) 
      {
         OperationDescription desc = NewOperation("MatMul", opName);
         desc.AddInput(a);
         desc.AddInput(b);

         if (transpose_a != false) desc.SetAttr("transpose_a", transpose_a);
         if (transpose_b != false) desc.SetAttr("transpose_b", transpose_b);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///Updates the scalar stats accumulator.
      ///</summary>
      ///<param name="stats_accumulator_handles">Input to the operation: A list of handles to the stats accumulator.</param>
      ///<param name="stamp_token">Input to the operation: Stamp token for Read/Write operations. Any operation with a mismatching token will be dropped.</param>
      ///<param name="partition_ids">Input to the operation: A list of vectors of partition_ids.</param>
      ///<param name="feature_ids">Input to the operation: Rank 2 tensor of feature id and feature dimension ids.</param>
      ///<param name="gradients">Input to the operation: A list of vectors of gradients for each slot in &lt;partition_id, feature_id, feature_dimension_id&gt;.</param>
      ///<param name="hessians">Input to the operation: A list of vectors of hessians for each slot in &lt;partition_id, feature_id, feature_dimension_id&gt;.</param>
      ///<param name="opName">The name of the operation</param>
      public Operation StatsAccumulatorScalarAdd (  Output stats_accumulator_handles , Output stamp_token , Output partition_ids , Output feature_ids , Output gradients , Output hessians ,String opName= "StatsAccumulatorScalarAdd" ) 
      {
         OperationDescription desc = NewOperation("StatsAccumulatorScalarAdd", opName);
         desc.AddInput(stats_accumulator_handles);
         desc.AddInput(stamp_token);
         desc.AddInput(partition_ids);
         desc.AddInput(feature_ids);
         desc.AddInput(gradients);
         desc.AddInput(hessians);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///   Converts byte arrays represented by strings to 32-bit
      ///</summary>
      ///<param name="input_data">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_data(type: DtFloat).
      ///</return>
      public Operation ReinterpretStringToFloat (  Output input_data ,String opName= "ReinterpretStringToFloat" ) 
      {
         OperationDescription desc = NewOperation("ReinterpretStringToFloat", opName);
         desc.AddInput(input_data);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="s0">Input to the operation. </param>
      ///<param name="s1">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] r0(type: DtInvalid).
      ///</return>
      public Operation BroadcastArgs (  Output s0 , Output s1 ,String opName= "BroadcastArgs" ) 
      {
         OperationDescription desc = NewOperation("BroadcastArgs", opName);
         desc.AddInput(s0);
         desc.AddInput(s1);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="Tout"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation ComplexAbs (  Output x , DataType? Tout = null ,String opName= "ComplexAbs" ) 
      {
         OperationDescription desc = NewOperation("ComplexAbs", opName);
         desc.AddInput(x);

         if (Tout.HasValue) desc.SetAttr("Tout", Tout.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///Returns quantile buckets created during previous flush of the accumulator.
      ///</summary>
      ///<param name="quantile_accumulator_handles">Input to the operation: The handles to the quantile stream resources.</param>
      ///<param name="stamp_token">Input to the operation: Stamp token to validate the Read/Write operation.</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] are_buckets_ready(type: DtBool): Whether the buckets are ready or not.
      ///[1] buckets(type: DtFloat): Output quantile summary representing boundaries with "num_quantile" elements.
      ///</return>
      public Operation QuantileAccumulatorGetBuckets (  Output quantile_accumulator_handles , Output stamp_token ,String opName= "QuantileAccumulatorGetBuckets" ) 
      {
         OperationDescription desc = NewOperation("QuantileAccumulatorGetBuckets", opName);
         desc.AddInput(quantile_accumulator_handles);
         desc.AddInput(stamp_token);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="scale">Input to the operation. </param>
      ///<param name="offset">Input to the operation. </param>
      ///<param name="mean">Input to the operation. </param>
      ///<param name="variance">Input to the operation. </param>
      ///<param name="epsilon"></param>
      ///<param name="data_format"></param>
      ///<param name="is_training"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///[1] batch_mean(type: DtInvalid).
      ///[2] batch_variance(type: DtInvalid).
      ///[3] reserve_space_1(type: DtInvalid).
      ///[4] reserve_space_2(type: DtInvalid).
      ///</return>
      public Operation FusedBatchNorm (  Output x , Output scale , Output offset , Output mean , Output variance , float epsilon = 0.0001f , string data_format = null , bool is_training = true ,String opName= "FusedBatchNorm" ) 
      {
         OperationDescription desc = NewOperation("FusedBatchNorm", opName);
         desc.AddInput(x);
         desc.AddInput(scale);
         desc.AddInput(offset);
         desc.AddInput(mean);
         desc.AddInput(variance);

         if (epsilon != 0.0001f) desc.SetAttr("epsilon", epsilon);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         if (is_training != true) desc.SetAttr("is_training", is_training);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///Retrieves a set of weights from the opaque params buffer that can be saved and
      ///</summary>
      ///<param name="num_layers">Input to the operation: Specifies the number of layers in the RNN model.</param>
      ///<param name="num_units">Input to the operation: Specifies the size of the hidden state.</param>
      ///<param name="input_size">Input to the operation: Specifies the size of the input state.  Note that the params buffer may not be compatible across different GPUs. So any save and restoration should be converted to and from the canonical weights and biases.</param>
      ///<param name="parameters">Input to the operation. </param>
      ///<param name="num_params">number of parameter sets for all layers. Each layer may contain multiple parameter sets, with each set consisting of a weight matrix and a bias vector.</param>
      ///<param name="rnn_mode">Indicates the type of the RNN model.</param>
      ///<param name="input_mode">Indicate whether there is a linear projection between the input and The actual computation before the first layer. 'skip_input' is only allowed when input_size == num_units; 'auto_select' implies 'skip_input' when input_size == num_units; otherwise, it implies 'linear_input'.</param>
      ///<param name="direction">Indicates whether a bidirectional model will be used. dir = (direction == bidirectional) ? 2 : 1</param>
      ///<param name="dropout">dropout probability. When set to 0., dropout is disabled.</param>
      ///<param name="seed">the 1st part of a seed to initialize dropout.</param>
      ///<param name="seed2">the 2nd part of a seed to initialize dropout.</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] weights(type: DtInvalid): the canonical form of weights that can be used for saving and restoration. They are more likely to be compatible across different generations.
      ///[1] biases(type: DtInvalid): the canonical form of biases that can be used for saving and restoration. They are more likely to be compatible across different generations.
      ///</return>
      public Operation CudnnRNNParamsToCanonical (  Output num_layers , Output num_units , Output input_size , Output parameters , long num_params, string rnn_mode = null , string input_mode = null , string direction = null , float dropout = 0f , long seed = 0 , long seed2 = 0 ,String opName= "CudnnRNNParamsToCanonical" ) 
      {
         OperationDescription desc = NewOperation("CudnnRNNParamsToCanonical", opName);
         desc.AddInput(num_layers);
         desc.AddInput(num_units);
         desc.AddInput(input_size);
         desc.AddInput(parameters);
         desc.SetAttr("num_params", num_params);
         if (rnn_mode != null) desc.SetAttr("rnn_mode", rnn_mode);
         if (input_mode != null) desc.SetAttr("input_mode", input_mode);
         if (direction != null) desc.SetAttr("direction", direction);
         if (dropout != 0f) desc.SetAttr("dropout", dropout);
         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="parameters">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="validate_indices"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Gather (  Output parameters , Output indices , bool validate_indices = true ,String opName= "Gather" ) 
      {
         OperationDescription desc = NewOperation("Gather", opName);
         desc.AddInput(parameters);
         desc.AddInput(indices);

         if (validate_indices != true) desc.SetAttr("validate_indices", validate_indices);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtComplex64).
      ///</return>
      public Operation IFFT2D (  Output input ,String opName= "IFFT2D" ) 
      {
         OperationDescription desc = NewOperation("IFFT2D", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="logits">Input to the operation. </param>
      ///<param name="num_samples">Input to the operation. </param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="output_dtype"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Multinomial (  Output logits , Output num_samples , long seed = 0 , long seed2 = 0 , DataType? output_dtype = null ,String opName= "Multinomial" ) 
      {
         OperationDescription desc = NewOperation("Multinomial", opName);
         desc.AddInput(logits);
         desc.AddInput(num_samples);

         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         if (output_dtype.HasValue) desc.SetAttr("output_dtype", output_dtype.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///Centers the tree ensemble bias before adding trees based on feature splits.
      ///</summary>
      ///<param name="tree_ensemble_handle">Input to the operation: Handle to the ensemble variable.</param>
      ///<param name="stamp_token">Input to the operation: Stamp token for validating operation consistency.</param>
      ///<param name="next_stamp_token">Input to the operation: Stamp token to be used for the next iteration.</param>
      ///<param name="delta_updates">Input to the operation: Rank 1 Tensor containing delta updates per bias dimension.</param>
      ///<param name="learner_config">Config for the learner of type LearnerConfig proto.</param>
      ///<param name="centering_epsilon"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] continue_centering(type: DtBool): Scalar indicating whether more centering is needed.
      ///</return>
      public Operation CenterTreeEnsembleBias (  Output tree_ensemble_handle , Output stamp_token , Output next_stamp_token , Output delta_updates , string learner_config, float centering_epsilon = 0.01f ,String opName= "CenterTreeEnsembleBias" ) 
      {
         OperationDescription desc = NewOperation("CenterTreeEnsembleBias", opName);
         desc.AddInput(tree_ensemble_handle);
         desc.AddInput(stamp_token);
         desc.AddInput(next_stamp_token);
         desc.AddInput(delta_updates);
         desc.SetAttr("learner_config", learner_config);
         if (centering_epsilon != 0.01f) desc.SetAttr("centering_epsilon", centering_epsilon);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="filename">Input to the operation. </param>
      ///<param name="contents">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation WriteFile (  Output filename , Output contents ,String opName= "WriteFile" ) 
      {
         OperationDescription desc = NewOperation("WriteFile", opName);
         desc.AddInput(filename);
         desc.AddInput(contents);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///Creates a scalar stats accumulator.
      ///</summary>
      ///<param name="stats_accumulator_handle">Input to the operation: handle to the stats accumulator.</param>
      ///<param name="stamp_token">Input to the operation: Token to use as the initial value of the resource stamp.</param>
      ///<param name="opName">The name of the operation</param>
      public Operation CreateStatsAccumulatorScalar (  Output stats_accumulator_handle , Output stamp_token ,String opName= "CreateStatsAccumulatorScalar" ) 
      {
         OperationDescription desc = NewOperation("CreateStatsAccumulatorScalar", opName);
         desc.AddInput(stats_accumulator_handle);
         desc.AddInput(stamp_token);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="gradient_accumulator">Input to the operation. </param>
      ///<param name="gradient_squared_accumulator">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="l1">Input to the operation. </param>
      ///<param name="l2">Input to the operation. </param>
      ///<param name="global_step">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceApplyAdagradDA (  Output var , Output gradient_accumulator , Output gradient_squared_accumulator , Output grad , Output lr , Output l1 , Output l2 , Output global_step , bool use_locking = false ,String opName= "ResourceApplyAdagradDA" ) 
      {
         OperationDescription desc = NewOperation("ResourceApplyAdagradDA", opName);
         desc.AddInput(var);
         desc.AddInput(gradient_accumulator);
         desc.AddInput(gradient_squared_accumulator);
         desc.AddInput(grad);
         desc.AddInput(lr);
         desc.AddInput(l1);
         desc.AddInput(l2);
         desc.AddInput(global_step);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="inputs">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///[1] value_index(type: DtInt32).
      ///</return>
      public Operation RefMerge (  Output inputs ,String opName= "RefMerge" ) 
      {
         OperationDescription desc = NewOperation("RefMerge", opName);
         desc.AddInput(inputs);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="element_shape_except0"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] value(type: DtInvalid).
      ///[1] lengths(type: DtInt64).
      ///</return>
      public Operation TensorArrayConcatV3 (  Output handle , Output flow_in , DataType dtype, long[] element_shape_except0 = null ,String opName= "TensorArrayConcatV3" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayConcatV3", opName);
         desc.AddInput(handle);
         desc.AddInput(flow_in);
         desc.SetAttr("dtype", dtype);
         if (element_shape_except0 != null) desc.SetAttrShape("element_shape_except0", element_shape_except0);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="resource">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] value(type: DtInvalid).
      ///</return>
      public Operation ReadVariableOp (  Output resource , DataType dtype,String opName= "ReadVariableOp" ) 
      {
         OperationDescription desc = NewOperation("ReadVariableOp", opName);
         desc.AddInput(resource);
         desc.SetAttr("dtype", dtype);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///Returns the mask of used handlers along with the number of non-zero elements in
      ///</summary>
      ///<param name="tree_ensemble_handle">Input to the operation: Handle to the tree ensemble.</param>
      ///<param name="stamp_token">Input to the operation: Token to use as the new value of the resource stamp.</param>
      ///<param name="num_all_handlers"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] num_used_handlers(type: DtInt64): number of feature column handlers used in the model.
      ///[1] used_handlers_mask(type: DtBool): A boolean vector of showing which handlers are used in the model.
      ///</return>
      public Operation TreeEnsembleUsedHandlers (  Output tree_ensemble_handle , Output stamp_token , long num_all_handlers,String opName= "TreeEnsembleUsedHandlers" ) 
      {
         OperationDescription desc = NewOperation("TreeEnsembleUsedHandlers", opName);
         desc.AddInput(tree_ensemble_handle);
         desc.AddInput(stamp_token);
         desc.SetAttr("num_all_handlers", num_all_handlers);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///Bucketizes 'input' based on 'boundaries'. This function is similar to Bucketize
      ///</summary>
      ///<param name="input">Input to the operation: Any shape of Tensor contains with numeric type.</param>
      ///<param name="boundaries">Input to the operation: A vector Tensor of sorted floats specifies the boundaries of the buckets.</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInt32): Same shape as 'input', where each value of input is replaced with its corresponding bucket index.
      ///</return>
      public Operation BucketizeWithInputBoundaries (  Output input , Output boundaries ,String opName= "BucketizeWithInputBoundaries" ) 
      {
         OperationDescription desc = NewOperation("BucketizeWithInputBoundaries", opName);
         desc.AddInput(input);
         desc.AddInput(boundaries);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///Computes the partial left-hand side and right-hand side of WALS update.
      ///</summary>
      ///<param name="factors">Input to the operation: Matrix of size m * k.</param>
      ///<param name="factor_weights">Input to the operation: Vector of size m. Corresponds to column weights</param>
      ///<param name="unobserved_weights">Input to the operation: Scalar. Weight for unobserved input entries.</param>
      ///<param name="input_weights">Input to the operation: Vector of size n. Corresponds to row weights.</param>
      ///<param name="input_indices">Input to the operation: Indices for the input SparseTensor.</param>
      ///<param name="input_values">Input to the operation: Values for the input SparseTensor.</param>
      ///<param name="input_block_size">Input to the operation: Scalar. Number of rows spanned by input.</param>
      ///<param name="input_is_transpose">Input to the operation: If true, logically transposes the input for processing.</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] partial_lhs(type: DtFloat): 3-D tensor with size input_block_size x k x k.
      ///[1] partial_rhs(type: DtFloat): Matrix with size input_block_size x k.
      ///</return>
      public Operation WALSComputePartialLhsAndRhs (  Output factors , Output factor_weights , Output unobserved_weights , Output input_weights , Output input_indices , Output input_values , Output input_block_size , Output input_is_transpose ,String opName= "WALSComputePartialLhsAndRhs" ) 
      {
         OperationDescription desc = NewOperation("WALSComputePartialLhsAndRhs", opName);
         desc.AddInput(factors);
         desc.AddInput(factor_weights);
         desc.AddInput(unobserved_weights);
         desc.AddInput(input_weights);
         desc.AddInput(input_indices);
         desc.AddInput(input_values);
         desc.AddInput(input_block_size);
         desc.AddInput(input_is_transpose);


         return desc.FinishOperation();
      } 
      // Skipped function _DisconnectHostFromDistributedTPUSystem

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Bitcast (  Output input , DataType type,String opName= "Bitcast" ) 
      {
         OperationDescription desc = NewOperation("Bitcast", opName);
         desc.AddInput(input);
         desc.SetAttr("type", type);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="key">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="dtypes"></param>
      ///<param name="capacity"></param>
      ///<param name="memory_limit"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] values(type: DtInvalid).
      ///</return>
      public Operation OrderedMapPeek (  Output key , Output indices , DataType[] dtypes, long capacity = 0 , long memory_limit = 0 , string container = null , string shared_name = null ,String opName= "OrderedMapPeek" ) 
      {
         OperationDescription desc = NewOperation("OrderedMapPeek", opName);
         desc.AddInput(key);
         desc.AddInput(indices);
         desc.SetAttr("dtypes", dtypes);
         if (capacity != 0) desc.SetAttr("capacity", capacity);
         if (memory_limit != 0) desc.SetAttr("memory_limit", memory_limit);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="string_tensor">Input to the operation. </param>
      ///<param name="num_buckets"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInt64).
      ///</return>
      public Operation StringToHashBucket (  Output string_tensor , long num_buckets,String opName= "StringToHashBucket" ) 
      {
         OperationDescription desc = NewOperation("StringToHashBucket", opName);
         desc.AddInput(string_tensor);
         desc.SetAttr("num_buckets", num_buckets);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Sinh (  Output x ,String opName= "Sinh" ) 
      {
         OperationDescription desc = NewOperation("Sinh", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///Runs multiple additive regression forests predictors on input instances
      ///</summary>
      ///<param name="tree_ensemble_handle">Input to the operation: The handle to the tree ensemble.</param>
      ///<param name="seed">Input to the operation: random seed to be used for dropout.</param>
      ///<param name="dense_float_features">Input to the operation: Rank 2 Tensors containing dense float feature values.</param>
      ///<param name="sparse_float_feature_indices">Input to the operation: Rank 2 Tensors containing sparse float indices.</param>
      ///<param name="sparse_float_feature_values">Input to the operation: Rank 1 Tensors containing sparse float values.</param>
      ///<param name="sparse_float_feature_shapes">Input to the operation: Rank 1 Tensors containing sparse float shapes.</param>
      ///<param name="sparse_int_feature_indices">Input to the operation: Rank 2 Tensors containing sparse int indices.</param>
      ///<param name="sparse_int_feature_values">Input to the operation: Rank 1 Tensors containing sparse int values.</param>
      ///<param name="sparse_int_feature_shapes">Input to the operation: Rank 1 Tensors containing sparse int shapes.</param>
      ///<param name="learner_config">Config for the learner of type LearnerConfig proto. Prediction ops for now uses only LearningRateDropoutDrivenConfig config from the learner.</param>
      ///<param name="apply_dropout">whether to apply dropout during prediction.</param>
      ///<param name="apply_averaging">whether averaging of tree ensembles should take place. If set to true, will be based on AveragingConfig from learner_config.</param>
      ///<param name="center_bias"></param>
      ///<param name="reduce_dim">whether to reduce the dimension (legacy impl) or not.</param>
      ///<param name="use_locking">Whether to use locking.</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] predictions(type: DtFloat): Rank 2 Tensor containing predictions per example per class.
      ///[1] drop_out_tree_indices_weights(type: DtFloat): Tensor of Rank 2 containing dropped trees indices and original weights of those trees during prediction.
      ///</return>
      public Operation GradientTreesPrediction (  Output tree_ensemble_handle , Output seed , Output dense_float_features , Output sparse_float_feature_indices , Output sparse_float_feature_values , Output sparse_float_feature_shapes , Output sparse_int_feature_indices , Output sparse_int_feature_values , Output sparse_int_feature_shapes , string learner_config, bool apply_dropout, bool apply_averaging, bool center_bias, bool reduce_dim, bool use_locking = false ,String opName= "GradientTreesPrediction" ) 
      {
         OperationDescription desc = NewOperation("GradientTreesPrediction", opName);
         desc.AddInput(tree_ensemble_handle);
         desc.AddInput(seed);
         desc.AddInput(dense_float_features);
         desc.AddInput(sparse_float_feature_indices);
         desc.AddInput(sparse_float_feature_values);
         desc.AddInput(sparse_float_feature_shapes);
         desc.AddInput(sparse_int_feature_indices);
         desc.AddInput(sparse_int_feature_values);
         desc.AddInput(sparse_int_feature_shapes);
         desc.SetAttr("learner_config", learner_config);
         desc.SetAttr("apply_dropout", apply_dropout);
         desc.SetAttr("apply_averaging", apply_averaging);
         desc.SetAttr("center_bias", center_bias);
         desc.SetAttr("reduce_dim", reduce_dim);
         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///Resets the scalar stats accumulator with the serialized state.
      ///</summary>
      ///<param name="stats_accumulator_handle">Input to the operation: handle to the stats accumulator.</param>
      ///<param name="stamp_token">Input to the operation: Stamp token for Read/Write operations. Any operation with a mismatching token will be dropped.</param>
      ///<param name="num_updates">Input to the operation: Number of times stats were added to this accumulator since last flush.</param>
      ///<param name="partition_ids">Input to the operation: A vector of partition_ids.</param>
      ///<param name="feature_ids">Input to the operation: Rank 2 tensor of feature id and feature dimension ids.</param>
      ///<param name="gradients">Input to the operation: A vector of gradients for each slot in &lt;partition_id, feature_id, feature_dimension_id&gt;.</param>
      ///<param name="hessians">Input to the operation: A vector of hessians for each slot in &lt;partition_id, feature_id, feature_dimension_id&gt;</param>
      ///<param name="opName">The name of the operation</param>
      public Operation StatsAccumulatorScalarDeserialize (  Output stats_accumulator_handle , Output stamp_token , Output num_updates , Output partition_ids , Output feature_ids , Output gradients , Output hessians ,String opName= "StatsAccumulatorScalarDeserialize" ) 
      {
         OperationDescription desc = NewOperation("StatsAccumulatorScalarDeserialize", opName);
         desc.AddInput(stats_accumulator_handle);
         desc.AddInput(stamp_token);
         desc.AddInput(num_updates);
         desc.AddInput(partition_ids);
         desc.AddInput(feature_ids);
         desc.AddInput(gradients);
         desc.AddInput(hessians);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///Creates a handle to a QuantileStreamResource
      ///</summary>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] resource(type: DtResource).
      ///</return>
      public Operation QuantileStreamResourceHandleOp (  string container = null , string shared_name = null ,String opName= "QuantileStreamResourceHandleOp" ) 
      {
         OperationDescription desc = NewOperation("QuantileStreamResourceHandleOp", opName);


         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="segment_ids">Input to the operation. </param>
      ///<param name="num_segments">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SparseSegmentSqrtNWithNumSegments (  Output data , Output indices , Output segment_ids , Output num_segments ,String opName= "SparseSegmentSqrtNWithNumSegments" ) 
      {
         OperationDescription desc = NewOperation("SparseSegmentSqrtNWithNumSegments", opName);
         desc.AddInput(data);
         desc.AddInput(indices);
         desc.AddInput(segment_ids);
         desc.AddInput(num_segments);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///Checks whether a quantile accumulator has been initialized.
      ///</summary>
      ///<param name="quantile_accumulator_handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] is_initialized(type: DtBool).
      ///</return>
      public Operation QuantileAccumulatorIsInitialized (  Output quantile_accumulator_handle ,String opName= "QuantileAccumulatorIsInitialized" ) 
      {
         OperationDescription desc = NewOperation("QuantileAccumulatorIsInitialized", opName);
         desc.AddInput(quantile_accumulator_handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///Creates a stateful accumulator for quantile summaries.
      ///</summary>
      ///<param name="quantile_accumulator_handle">Input to the operation: The handle to the accumulator.</param>
      ///<param name="stamp_token">Input to the operation: Token to use as the initial value of the resource stamp.</param>
      ///<param name="epsilon">Error bound on the quantile summary.</param>
      ///<param name="num_quantiles">Number of buckets that we create from the data.</param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="max_elements"></param>
      ///<param name="generate_quantiles"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation CreateQuantileAccumulator (  Output quantile_accumulator_handle , Output stamp_token , float epsilon, long num_quantiles, string container = null , string shared_name = null , long max_elements = 1099511627776 , bool generate_quantiles = false ,String opName= "CreateQuantileAccumulator" ) 
      {
         OperationDescription desc = NewOperation("CreateQuantileAccumulator", opName);
         desc.AddInput(quantile_accumulator_handle);
         desc.AddInput(stamp_token);
         desc.SetAttr("epsilon", epsilon);
         desc.SetAttr("num_quantiles", num_quantiles);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         if (max_elements != 1099511627776) desc.SetAttr("max_elements", max_elements);
         if (generate_quantiles != false) desc.SetAttr("generate_quantiles", generate_quantiles);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///Resets quantile summary streams for each column with a new token.
      ///</summary>
      ///<param name="quantile_accumulator_handle">Input to the operation: The handle to the accumulator.</param>
      ///<param name="stamp_token">Input to the operation: Stamp token for Read/Write operations. Any operation with a mismatching token will be dropped.</param>
      ///<param name="next_stamp_token">Input to the operation: Stamp token to be used for the next iteration.</param>
      ///<param name="opName">The name of the operation</param>
      public Operation QuantileAccumulatorFlush (  Output quantile_accumulator_handle , Output stamp_token , Output next_stamp_token ,String opName= "QuantileAccumulatorFlush" ) 
      {
         OperationDescription desc = NewOperation("QuantileAccumulatorFlush", opName);
         desc.AddInput(quantile_accumulator_handle);
         desc.AddInput(stamp_token);
         desc.AddInput(next_stamp_token);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reverse_index_map">Input to the operation. </param>
      ///<param name="grad_values">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] d_values(type: DtInvalid).
      ///[1] d_default_value(type: DtInvalid).
      ///</return>
      public Operation SparseFillEmptyRowsGrad (  Output reverse_index_map , Output grad_values ,String opName= "SparseFillEmptyRowsGrad" ) 
      {
         OperationDescription desc = NewOperation("SparseFillEmptyRowsGrad", opName);
         desc.AddInput(reverse_index_map);
         desc.AddInput(grad_values);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="reduction_indices">Input to the operation. </param>
      ///<param name="keep_dims"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Prod (  Output input , Output reduction_indices , bool keep_dims = false ,String opName= "Prod" ) 
      {
         OperationDescription desc = NewOperation("Prod", opName);
         desc.AddInput(input);
         desc.AddInput(reduction_indices);

         if (keep_dims != false) desc.SetAttr("keep_dims", keep_dims);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///Resets quantile summary stream and returns the summary.
      ///</summary>
      ///<param name="quantile_accumulator_handle">Input to the operation: The handle to the accumulator.</param>
      ///<param name="stamp_token">Input to the operation: Stamp token for Read/Write operations. Any operation with a mismatching token will be dropped.</param>
      ///<param name="next_stamp_token">Input to the operation: Stamp token to be used for the next iteration.</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtString): A scalar string that is the a summary of the accumulator.
      ///</return>
      public Operation QuantileAccumulatorFlushSummary (  Output quantile_accumulator_handle , Output stamp_token , Output next_stamp_token ,String opName= "QuantileAccumulatorFlushSummary" ) 
      {
         OperationDescription desc = NewOperation("QuantileAccumulatorFlushSummary", opName);
         desc.AddInput(quantile_accumulator_handle);
         desc.AddInput(stamp_token);
         desc.AddInput(next_stamp_token);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///Checks whether a stats accumulator has been initialized.
      ///</summary>
      ///<param name="stats_accumulator_handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] is_initialized(type: DtBool).
      ///</return>
      public Operation StatsAccumulatorScalarIsInitialized (  Output stats_accumulator_handle ,String opName= "StatsAccumulatorScalarIsInitialized" ) 
      {
         OperationDescription desc = NewOperation("StatsAccumulatorScalarIsInitialized", opName);
         desc.AddInput(stats_accumulator_handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] size(type: DtInt32).
      ///</return>
      public Operation TensorArraySize (  Output handle , Output flow_in ,String opName= "TensorArraySize" ) 
      {
         OperationDescription desc = NewOperation("TensorArraySize", opName);
         desc.AddInput(handle);
         desc.AddInput(flow_in);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///Serializes the state of the given resource.
      ///</summary>
      ///<param name="quantile_accumulator_handle">Input to the operation: The handle to the accumulator.</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] stamp_token(type: DtInt64): Stamp token for Read/Write operations. Any operation with a mismatching token will be dropped.
      ///[1] stream_state(type: DtString): A serialized QuantileStreamState.
      ///[2] are_buckets_ready(type: DtBool): Whether the buckets are ready or not.
      ///[3] buckets(type: DtFloat): Output quantile buckets representing boundaries with "num_quantile" elements.
      ///</return>
      public Operation QuantileAccumulatorSerialize (  Output quantile_accumulator_handle ,String opName= "QuantileAccumulatorSerialize" ) 
      {
         OperationDescription desc = NewOperation("QuantileAccumulatorSerialize", opName);
         desc.AddInput(quantile_accumulator_handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///Retrieves stats related to the tree ensemble.
      ///</summary>
      ///<param name="tree_ensemble_handle">Input to the operation: Handle to the ensemble variable.</param>
      ///<param name="stamp_token">Input to the operation: Stamp token for validating operation consistency.</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] num_trees(type: DtInt64): Scalar indicating the number of finalized trees in the ensemble.
      ///[1] num_layers(type: DtInt64): Scalar indicating the number of layers in the ensemble.
      ///[2] active_tree(type: DtInt64): Scalar indicating the active tree being trained.
      ///[3] active_layer(type: DtInt64): Scalar indicating the active layer being trained.
      ///[4] attempted_trees(type: DtInt64).
      ///[5] attempted_layers(type: DtInt64).
      ///</return>
      public Operation TreeEnsembleStats (  Output tree_ensemble_handle , Output stamp_token ,String opName= "TreeEnsembleStats" ) 
      {
         OperationDescription desc = NewOperation("TreeEnsembleStats", opName);
         desc.AddInput(tree_ensemble_handle);
         desc.AddInput(stamp_token);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="json_examples">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] binary_examples(type: DtString).
      ///</return>
      public Operation DecodeJSONExample (  Output json_examples ,String opName= "DecodeJSONExample" ) 
      {
         OperationDescription desc = NewOperation("DecodeJSONExample", opName);
         desc.AddInput(json_examples);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="multiples">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Tile (  Output input , Output multiples ,String opName= "Tile" ) 
      {
         OperationDescription desc = NewOperation("Tile", opName);
         desc.AddInput(input);
         desc.AddInput(multiples);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///Serializes the state of the given resource.
      ///</summary>
      ///<param name="quantile_accumulator_handle">Input to the operation: The handle to the accumulator.</param>
      ///<param name="stamp_token">Input to the operation: Stamp token for Read/Write operations. Any operation with a mismatching token will be dropped.</param>
      ///<param name="stream_state">Input to the operation: A serialized QuantileStreamState.</param>
      ///<param name="are_buckets_ready">Input to the operation: Whether the buckets are ready or not.</param>
      ///<param name="buckets">Input to the operation: Output quantile summary representing boundaries with "num_quantile" elements.</param>
      ///<param name="opName">The name of the operation</param>
      public Operation QuantileAccumulatorDeserialize (  Output quantile_accumulator_handle , Output stamp_token , Output stream_state , Output are_buckets_ready , Output buckets ,String opName= "QuantileAccumulatorDeserialize" ) 
      {
         OperationDescription desc = NewOperation("QuantileAccumulatorDeserialize", opName);
         desc.AddInput(quantile_accumulator_handle);
         desc.AddInput(stamp_token);
         desc.AddInput(stream_state);
         desc.AddInput(are_buckets_ready);
         desc.AddInput(buckets);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="ms">Input to the operation. </param>
      ///<param name="mom">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="rho">Input to the operation. </param>
      ///<param name="momentum">Input to the operation. </param>
      ///<param name="epsilon">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation ApplyRMSProp (  Output var , Output ms , Output mom , Output lr , Output rho , Output momentum , Output epsilon , Output grad , bool use_locking = false ,String opName= "ApplyRMSProp" ) 
      {
         OperationDescription desc = NewOperation("ApplyRMSProp", opName);
         desc.AddInput(var);
         desc.AddInput(ms);
         desc.AddInput(mom);
         desc.AddInput(lr);
         desc.AddInput(rho);
         desc.AddInput(momentum);
         desc.AddInput(epsilon);
         desc.AddInput(grad);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///Creates a dataset that contains the unique elements of `input_dataset`.
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation UniqueDataset (  Output input_dataset , DataType[] output_types, long[][] output_shapes,String opName= "UniqueDataset" ) 
      {
         OperationDescription desc = NewOperation("UniqueDataset", opName);
         desc.AddInput(input_dataset);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 
      // Skipped function _ArrayToList

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="num_required">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] indices(type: DtInt64).
      ///[1] values(type: DtInvalid).
      ///[2] shape(type: DtInt64).
      ///</return>
      public Operation SparseAccumulatorTakeGradient (  Output handle , Output num_required , DataType dtype,String opName= "SparseAccumulatorTakeGradient" ) 
      {
         OperationDescription desc = NewOperation("SparseAccumulatorTakeGradient", opName);
         desc.AddInput(handle);
         desc.AddInput(num_required);
         desc.SetAttr("dtype", dtype);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///Resets the tensor stats accumulator with the serialized state.
      ///</summary>
      ///<param name="stats_accumulator_handle">Input to the operation: handle to the tree ensemble resource to be created.</param>
      ///<param name="stamp_token">Input to the operation: Stamp token for Read/Write operations. Any operation with a mismatching token will be dropped.</param>
      ///<param name="num_updates">Input to the operation: Number of times stats were added to this accumulator since last flush.</param>
      ///<param name="partition_ids">Input to the operation: A vector of partition_ids.</param>
      ///<param name="feature_ids">Input to the operation: Rank 2 tensor of feature id and feature dimension ids.</param>
      ///<param name="gradients">Input to the operation: A vector of gradients for each slot in &lt;partition_id, feature_id, feature_dimension_id&gt;</param>
      ///<param name="hessians">Input to the operation: A vector of hessians for each slot in &lt;partition_id, feature_id, feature_dimension_id&gt;.</param>
      ///<param name="opName">The name of the operation</param>
      public Operation StatsAccumulatorTensorDeserialize (  Output stats_accumulator_handle , Output stamp_token , Output num_updates , Output partition_ids , Output feature_ids , Output gradients , Output hessians ,String opName= "StatsAccumulatorTensorDeserialize" ) 
      {
         OperationDescription desc = NewOperation("StatsAccumulatorTensorDeserialize", opName);
         desc.AddInput(stats_accumulator_handle);
         desc.AddInput(stamp_token);
         desc.AddInput(num_updates);
         desc.AddInput(partition_ids);
         desc.AddInput(feature_ids);
         desc.AddInput(gradients);
         desc.AddInput(hessians);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///Updates the tensor stats accumulator.
      ///</summary>
      ///<param name="stats_accumulator_handles">Input to the operation: A list of handles to the stats accumulator.</param>
      ///<param name="stamp_token">Input to the operation: Stamp token for Read/Write operations. Any operation with a mismatching token will be dropped.</param>
      ///<param name="partition_ids">Input to the operation: A list of vectors of partition_ids.</param>
      ///<param name="feature_ids">Input to the operation: Rank 2 tensor of feature id and feature dimension ids.</param>
      ///<param name="gradients">Input to the operation: A list of vectors of gradients for each slot in &lt;partition_id, feature_id, feature_dimension_id&gt;.</param>
      ///<param name="hessians">Input to the operation: A list of vectors of hessians for each slot in &lt;partition_id, feature_id, feature_dimension_id&gt;.</param>
      ///<param name="opName">The name of the operation</param>
      public Operation StatsAccumulatorTensorAdd (  Output stats_accumulator_handles , Output stamp_token , Output partition_ids , Output feature_ids , Output gradients , Output hessians ,String opName= "StatsAccumulatorTensorAdd" ) 
      {
         OperationDescription desc = NewOperation("StatsAccumulatorTensorAdd", opName);
         desc.AddInput(stats_accumulator_handles);
         desc.AddInput(stamp_token);
         desc.AddInput(partition_ids);
         desc.AddInput(feature_ids);
         desc.AddInput(gradients);
         desc.AddInput(hessians);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///Creates a summary for the given features.
      ///</summary>
      ///<param name="dense_float_features">Input to the operation: A list of vectors which contains dense values.</param>
      ///<param name="sparse_float_feature_indices">Input to the operation: List of rank 2 tensors containing the sparse float feature indices.</param>
      ///<param name="sparse_float_feature_values">Input to the operation: List of rank 1 tensors containing the sparse float feature values.</param>
      ///<param name="sparse_float_feature_shapes">Input to the operation: List of rank 1 tensors containing the shape of the float feature.</param>
      ///<param name="example_weights">Input to the operation: Rank 2 (N, 1) tensor of per-example weights. Should match dense and sparse features shape.</param>
      ///<param name="epsilon">Error bound on the computed summary.</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] dense_summaries(type: DtString): A list of serialized QuantileSummaryState for dense columns.
      ///[1] sparse_summaries(type: DtString): A list of serialized QuantileSummaryState for sparse columns.
      ///</return>
      public Operation MakeQuantileSummaries (  Output dense_float_features , Output sparse_float_feature_indices , Output sparse_float_feature_values , Output sparse_float_feature_shapes , Output example_weights , float epsilon,String opName= "MakeQuantileSummaries" ) 
      {
         OperationDescription desc = NewOperation("MakeQuantileSummaries", opName);
         desc.AddInput(dense_float_features);
         desc.AddInput(sparse_float_feature_indices);
         desc.AddInput(sparse_float_feature_values);
         desc.AddInput(sparse_float_feature_shapes);
         desc.AddInput(example_weights);
         desc.SetAttr("epsilon", epsilon);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="shape">Input to the operation. </param>
      ///<param name="begin">Input to the operation. </param>
      ///<param name="end">Input to the operation. </param>
      ///<param name="strides">Input to the operation. </param>
      ///<param name="dy">Input to the operation. </param>
      ///<param name="begin_mask"></param>
      ///<param name="end_mask"></param>
      ///<param name="ellipsis_mask"></param>
      ///<param name="new_axis_mask"></param>
      ///<param name="shrink_axis_mask"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation StridedSliceGrad (  Output shape , Output begin , Output end , Output strides , Output dy , long begin_mask = 0 , long end_mask = 0 , long ellipsis_mask = 0 , long new_axis_mask = 0 , long shrink_axis_mask = 0 ,String opName= "StridedSliceGrad" ) 
      {
         OperationDescription desc = NewOperation("StridedSliceGrad", opName);
         desc.AddInput(shape);
         desc.AddInput(begin);
         desc.AddInput(end);
         desc.AddInput(strides);
         desc.AddInput(dy);

         if (begin_mask != 0) desc.SetAttr("begin_mask", begin_mask);
         if (end_mask != 0) desc.SetAttr("end_mask", end_mask);
         if (ellipsis_mask != 0) desc.SetAttr("ellipsis_mask", ellipsis_mask);
         if (new_axis_mask != 0) desc.SetAttr("new_axis_mask", new_axis_mask);
         if (shrink_axis_mask != 0) desc.SetAttr("shrink_axis_mask", shrink_axis_mask);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///Computes quantile buckets for a given list of dense and sparse features with
      ///</summary>
      ///<param name="dense_float_features">Input to the operation: A list of vectors which contains dense values.</param>
      ///<param name="sparse_float_feature_indices">Input to the operation: List of rank 2 tensors containing the sparse float feature indices.</param>
      ///<param name="sparse_float_feature_values">Input to the operation: List of rank 1 tensors containing the sparse float feature values.</param>
      ///<param name="sparse_float_feature_shapes">Input to the operation: List of rank 1 tensors containing the shape of the float feature.</param>
      ///<param name="example_weights">Input to the operation: Rank 1 tensor containing the example weight tensor.</param>
      ///<param name="dense_config">Config for computing buckets for dense values. Each entry is QuantileConfig proto.</param>
      ///<param name="sparse_config">Config for computing buckets for sparse feature values. Each entry is QuantileConfig proto.</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] dense_buckets(type: DtFloat): Output quantile summary for each dense float tensor representing boundaries each with "num_quantile" elements.
      ///[1] sparse_buckets(type: DtFloat): Output quantile summary for each sparse float value tensor representing boundaries each with "num_quantile" elements.
      ///</return>
      public Operation QuantileBuckets (  Output dense_float_features , Output sparse_float_feature_indices , Output sparse_float_feature_values , Output sparse_float_feature_shapes , Output example_weights , string[] dense_config, string[] sparse_config,String opName= "QuantileBuckets" ) 
      {
         OperationDescription desc = NewOperation("QuantileBuckets", opName);
         desc.AddInput(dense_float_features);
         desc.AddInput(sparse_float_feature_indices);
         desc.AddInput(sparse_float_feature_values);
         desc.AddInput(sparse_float_feature_shapes);
         desc.AddInput(example_weights);
         desc.SetAttr("dense_config", dense_config);
         desc.SetAttr("sparse_config", sparse_config);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="block_size"></param>
      ///<param name="data_format"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation DepthToSpace (  Output input , long block_size, string data_format = null ,String opName= "DepthToSpace" ) 
      {
         OperationDescription desc = NewOperation("DepthToSpace", opName);
         desc.AddInput(input);
         desc.SetAttr("block_size", block_size);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation SquaredDifference (  Output x , Output y ,String opName= "SquaredDifference" ) 
      {
         OperationDescription desc = NewOperation("SquaredDifference", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///Computes quantile for each a given list of dense and sparse feature values using
      ///</summary>
      ///<param name="dense_values">Input to the operation: List of rank 1 tensors containing the dense values.</param>
      ///<param name="sparse_values">Input to the operation: List of rank 1 tensors containing the sparse feature values.</param>
      ///<param name="dense_buckets">Input to the operation: Quantile summary for each of the dense float tensor.</param>
      ///<param name="sparse_buckets">Input to the operation: Quantile summary for each of the sparse feature float tensor.</param>
      ///<param name="sparse_indices">Input to the operation: List of rank 2 tensors with indices for sparse float tensors.</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] dense_quantiles(type: DtInt32): Rank 2 tensors representing associated quantiles for each of dense float tensors and the dimension.
      ///[1] sparse_quantiles(type: DtInt32): Rank 2 tensors representing associated quantiles for each of the sparse feature tensors for each of sparse feature dimensions: [quantile id, dimension id].
      ///</return>
      public Operation Quantiles (  Output dense_values , Output sparse_values , Output dense_buckets , Output sparse_buckets , Output sparse_indices ,String opName= "Quantiles" ) 
      {
         OperationDescription desc = NewOperation("Quantiles", opName);
         desc.AddInput(dense_values);
         desc.AddInput(sparse_values);
         desc.AddInput(dense_buckets);
         desc.AddInput(sparse_buckets);
         desc.AddInput(sparse_indices);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="prefix">Input to the operation. </param>
      ///<param name="tensor_names">Input to the operation. </param>
      ///<param name="shape_and_slices">Input to the operation. </param>
      ///<param name="dtypes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] tensors(type: DtInvalid).
      ///</return>
      public Operation RestoreV2 (  Output prefix , Output tensor_names , Output shape_and_slices , DataType[] dtypes,String opName= "RestoreV2" ) 
      {
         OperationDescription desc = NewOperation("RestoreV2", opName);
         desc.AddInput(prefix);
         desc.AddInput(tensor_names);
         desc.AddInput(shape_and_slices);
         desc.SetAttr("dtypes", dtypes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///Find the split that has the best gain for the accumulated stats.
      ///</summary>
      ///<param name="num_minibatches">Input to the operation: A scalar, the number of times per example gradients & hessians were accumulated. The stats are divided by this to get per example stats.</param>
      ///<param name="partition_ids">Input to the operation: A rank 1 tensor of partition IDs.</param>
      ///<param name="bucket_ids">Input to the operation: A rank 2 tensor of buckets IDs and dimensions.</param>
      ///<param name="gradients">Input to the operation: A rank 1 tensor of gradients.</param>
      ///<param name="hessians">Input to the operation: A rank 1 tensor of hessians.</param>
      ///<param name="bucket_boundaries">Input to the operation: A rank 1 tensor, thresholds that were used for bucketization.</param>
      ///<param name="class_id">Input to the operation. </param>
      ///<param name="feature_column_group_id"></param>
      ///<param name="l1_regularization"></param>
      ///<param name="l2_regularization"></param>
      ///<param name="tree_complexity_regularization"></param>
      ///<param name="min_node_weight"></param>
      ///<param name="multiclass_strategy"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_partition_ids(type: DtInt32): A rank 1 tensor, the partition IDs that we created splits for.
      ///[1] gains(type: DtFloat): A rank 1 tensor, for the computed gain for the created splits.
      ///[2] split_infos(type: DtString): A rank 1 tensor of serialized protos which contains the `SplitInfo`s.
      ///</return>
      public Operation BuildDenseInequalitySplits (  Output num_minibatches , Output partition_ids , Output bucket_ids , Output gradients , Output hessians , Output bucket_boundaries , Output class_id , long feature_column_group_id, float l1_regularization, float l2_regularization, float tree_complexity_regularization, float min_node_weight, long multiclass_strategy,String opName= "BuildDenseInequalitySplits" ) 
      {
         OperationDescription desc = NewOperation("BuildDenseInequalitySplits", opName);
         desc.AddInput(num_minibatches);
         desc.AddInput(partition_ids);
         desc.AddInput(bucket_ids);
         desc.AddInput(gradients);
         desc.AddInput(hessians);
         desc.AddInput(bucket_boundaries);
         desc.AddInput(class_id);
         desc.SetAttr("feature_column_group_id", feature_column_group_id);
         desc.SetAttr("l1_regularization", l1_regularization);
         desc.SetAttr("l2_regularization", l2_regularization);
         desc.SetAttr("tree_complexity_regularization", tree_complexity_regularization);
         desc.SetAttr("min_node_weight", min_node_weight);
         desc.SetAttr("multiclass_strategy", multiclass_strategy);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="gradients">Input to the operation. </param>
      ///<param name="inputs">Input to the operation. </param>
      ///<param name="min"></param>
      ///<param name="max"></param>
      ///<param name="num_bits"></param>
      ///<param name="narrow_range"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] backprops(type: DtFloat).
      ///</return>
      public Operation FakeQuantWithMinMaxArgsGradient (  Output gradients , Output inputs , float min = -6f , float max = 6f , long num_bits = 8 , bool narrow_range = false ,String opName= "FakeQuantWithMinMaxArgsGradient" ) 
      {
         OperationDescription desc = NewOperation("FakeQuantWithMinMaxArgsGradient", opName);
         desc.AddInput(gradients);
         desc.AddInput(inputs);

         if (min != -6f) desc.SetAttr("min", min);
         if (max != 6f) desc.SetAttr("max", max);
         if (num_bits != 8) desc.SetAttr("num_bits", num_bits);
         if (narrow_range != false) desc.SetAttr("narrow_range", narrow_range);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///Find the split that has the best gain for the accumulated stats for a particular
      ///</summary>
      ///<param name="num_minibatches">Input to the operation: A scalar, the number of times per example gradients & hessians were accumulated. The stats are divided by this to get per example stats.</param>
      ///<param name="partition_ids">Input to the operation: A rank 2 tensor of partition IDs for each dimension of feature column.</param>
      ///<param name="bucket_ids">Input to the operation: A rank 2 tensor of buckets IDs and dimensions.</param>
      ///<param name="gradients">Input to the operation: A rank 1 tensor of gradients.</param>
      ///<param name="hessians">Input to the operation: A rank 1 tensor of hessians.</param>
      ///<param name="bucket_boundaries">Input to the operation: A rank 1 tensor, thresholds that were used for bucketization.</param>
      ///<param name="class_id">Input to the operation. </param>
      ///<param name="feature_column_group_id"></param>
      ///<param name="bias_feature_id"></param>
      ///<param name="l1_regularization"></param>
      ///<param name="l2_regularization"></param>
      ///<param name="tree_complexity_regularization"></param>
      ///<param name="min_node_weight"></param>
      ///<param name="multiclass_strategy"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_partition_ids(type: DtInt32): A rank 1 tensor, the partition IDs that we created splits for.
      ///[1] gains(type: DtFloat): A rank 1 tensor, for the computed gain for the created splits.
      ///[2] split_infos(type: DtString): A rank 1 tensor of serialized protos which contains the `SplitInfo`s.
      ///</return>
      public Operation BuildSparseInequalitySplits (  Output num_minibatches , Output partition_ids , Output bucket_ids , Output gradients , Output hessians , Output bucket_boundaries , Output class_id , long feature_column_group_id, long bias_feature_id, float l1_regularization, float l2_regularization, float tree_complexity_regularization, float min_node_weight, long multiclass_strategy,String opName= "BuildSparseInequalitySplits" ) 
      {
         OperationDescription desc = NewOperation("BuildSparseInequalitySplits", opName);
         desc.AddInput(num_minibatches);
         desc.AddInput(partition_ids);
         desc.AddInput(bucket_ids);
         desc.AddInput(gradients);
         desc.AddInput(hessians);
         desc.AddInput(bucket_boundaries);
         desc.AddInput(class_id);
         desc.SetAttr("feature_column_group_id", feature_column_group_id);
         desc.SetAttr("bias_feature_id", bias_feature_id);
         desc.SetAttr("l1_regularization", l1_regularization);
         desc.SetAttr("l2_regularization", l2_regularization);
         desc.SetAttr("tree_complexity_regularization", tree_complexity_regularization);
         desc.SetAttr("min_node_weight", min_node_weight);
         desc.SetAttr("multiclass_strategy", multiclass_strategy);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///Creates a handle to a StatsAccumulatorScalarResource
      ///</summary>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] resource(type: DtResource).
      ///</return>
      public Operation StatsAccumulatorScalarResourceHandleOp (  string container = null , string shared_name = null ,String opName= "StatsAccumulatorScalarResourceHandleOp" ) 
      {
         OperationDescription desc = NewOperation("StatsAccumulatorScalarResourceHandleOp", opName);


         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///Computes the RNN from the input and initial states, with respect to the params
      ///</summary>
      ///<param name="input">Input to the operation: a 3-D tensor with the shape of [seq_length, batch_size, input_size].</param>
      ///<param name="input_h">Input to the operation: a 3-D tensor with the shape of [num_layer * dir, batch_size, num_units].</param>
      ///<param name="input_c">Input to the operation: For LSTM, a 3-D tensor with the shape of [num_layer * dir, batch, num_units]. For other models, it is ignored.</param>
      ///<param name="parameters">Input to the operation: a 1-D tensor that contains the weights and biases in an opaque layout. The size must be created through CudnnRNNParamsSize, and initialized separately. Note that they might not be compatible across different generations. So it is a good idea to save and restore</param>
      ///<param name="rnn_mode">Indicates the type of the RNN model.</param>
      ///<param name="input_mode">Indicate whether there is a linear projection between the input and The actual computation before the first layer. 'skip_input' is only allowed when input_size == num_units; 'auto_select' implies 'skip_input' when input_size == num_units; otherwise, it implies 'linear_input'.</param>
      ///<param name="direction">Indicates whether a bidirectional model will be used. dir = (direction == bidirectional) ? 2 : 1</param>
      ///<param name="dropout">dropout probability. When set to 0., dropout is disabled.</param>
      ///<param name="seed">the 1st part of a seed to initialize dropout.</param>
      ///<param name="seed2">the 2nd part of a seed to initialize dropout.</param>
      ///<param name="is_training">Indicates whether this operation is used for inferenece or training.</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid): a 3-D tensor with the shape of [seq_length, batch_size, dir * num_units].
      ///[1] output_h(type: DtInvalid): the same shape has input_h.
      ///[2] output_c(type: DtInvalid): the same shape as input_c for LSTM. An empty tensor for other models.
      ///[3] reserve_space(type: DtInvalid): an opaque tensor that can be used in backprop calculation. It is only produced if is_training is false.
      ///</return>
      public Operation CudnnRNN (  Output input , Output input_h , Output input_c , Output parameters , string rnn_mode = null , string input_mode = null , string direction = null , float dropout = 0f , long seed = 0 , long seed2 = 0 , bool is_training = true ,String opName= "CudnnRNN" ) 
      {
         OperationDescription desc = NewOperation("CudnnRNN", opName);
         desc.AddInput(input);
         desc.AddInput(input_h);
         desc.AddInput(input_c);
         desc.AddInput(parameters);

         if (rnn_mode != null) desc.SetAttr("rnn_mode", rnn_mode);
         if (input_mode != null) desc.SetAttr("input_mode", input_mode);
         if (direction != null) desc.SetAttr("direction", direction);
         if (dropout != 0f) desc.SetAttr("dropout", dropout);
         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         if (is_training != true) desc.SetAttr("is_training", is_training);
         return desc.FinishOperation();
      } 
      // Skipped function _While

      ///<summary>
      ///Creates a tensor stats accumulator.
      ///</summary>
      ///<param name="stats_accumulator_handle">Input to the operation: handle to the tree ensemble resource to be created.</param>
      ///<param name="stamp_token">Input to the operation: Token to use as the initial value of the resource stamp.</param>
      ///<param name="per_slot_gradient_shape">Input to the operation: a vector that defines the shape of gradients.</param>
      ///<param name="per_slot_hessian_shape">Input to the operation: a vector that defines the shape of hessians.</param>
      ///<param name="opName">The name of the operation</param>
      public Operation CreateStatsAccumulatorTensor (  Output stats_accumulator_handle , Output stamp_token , Output per_slot_gradient_shape , Output per_slot_hessian_shape ,String opName= "CreateStatsAccumulatorTensor" ) 
      {
         OperationDescription desc = NewOperation("CreateStatsAccumulatorTensor", opName);
         desc.AddInput(stats_accumulator_handle);
         desc.AddInput(stamp_token);
         desc.AddInput(per_slot_gradient_shape);
         desc.AddInput(per_slot_hessian_shape);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///Selects the k nearest centers for each point.
      ///</summary>
      ///<param name="points">Input to the operation: Matrix of shape (n, d). Rows are assumed to be input points.</param>
      ///<param name="centers">Input to the operation: Matrix of shape (m, d). Rows are assumed to be centers.</param>
      ///<param name="k">Input to the operation: Scalar. Number of nearest centers to return for each point. If k is larger than m, then only m centers are returned.</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] nearest_center_indices(type: DtInt64): Matrix of shape (n, min(m, k)). Each row contains the indices of the centers closest to the corresponding point, ordered by increasing distance.
      ///[1] nearest_center_distances(type: DtFloat): Matrix of shape (n, min(m, k)). Each row contains the squared L2 distance to the corresponding center in nearest_center_indices.
      ///</return>
      public Operation NearestNeighbors (  Output points , Output centers , Output k ,String opName= "NearestNeighbors" ) 
      {
         OperationDescription desc = NewOperation("NearestNeighbors", opName);
         desc.AddInput(points);
         desc.AddInput(centers);
         desc.AddInput(k);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///Flushes the scalar stats accumulator to output and resets the internal state.
      ///</summary>
      ///<param name="stats_accumulator_handle">Input to the operation: handle to the stats accumulator.</param>
      ///<param name="stamp_token">Input to the operation: Stamp token for Read/Write operations. Any operation with a mismatching token will be dropped.</param>
      ///<param name="next_stamp_token">Input to the operation: Stamp token for the next iteration.</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] num_updates(type: DtInt64): Number of times stats were added to this accumulator since last     flush. output_partition_ids A vector of partition_ids for the slots.
      ///[1] output_partition_ids(type: DtInt32).
      ///[2] output_feature_ids(type: DtInt64): Rank 2 tensor of feature id and feature dimension ids.
      ///[3] output_gradients(type: DtFloat): A vector of gradients, with a value for each slot in &lt;output_partition_id, output_feature_id&gt;.
      ///[4] output_hessians(type: DtFloat): A vector of hessians, with a value for each slot in &lt;output_partition_id, output_feature_id&gt;.
      ///</return>
      public Operation StatsAccumulatorScalarFlush (  Output stats_accumulator_handle , Output stamp_token , Output next_stamp_token ,String opName= "StatsAccumulatorScalarFlush" ) 
      {
         OperationDescription desc = NewOperation("StatsAccumulatorScalarFlush", opName);
         desc.AddInput(stats_accumulator_handle);
         desc.AddInput(stamp_token);
         desc.AddInput(next_stamp_token);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///  Add elements in deltas to mutable input according to indices.
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="deltas">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation ScatterAddNdim (  Output input , Output indices , Output deltas ,String opName= "ScatterAddNdim" ) 
      {
         OperationDescription desc = NewOperation("ScatterAddNdim", opName);
         desc.AddInput(input);
         desc.AddInput(indices);
         desc.AddInput(deltas);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Lgamma (  Output x ,String opName= "Lgamma" ) 
      {
         OperationDescription desc = NewOperation("Lgamma", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="true_classes">Input to the operation. </param>
      ///<param name="num_true"></param>
      ///<param name="num_sampled"></param>
      ///<param name="unique"></param>
      ///<param name="range_max"></param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] sampled_candidates(type: DtInt64).
      ///[1] true_expected_count(type: DtFloat).
      ///[2] sampled_expected_count(type: DtFloat).
      ///</return>
      public Operation LogUniformCandidateSampler (  Output true_classes , long num_true, long num_sampled, bool unique, long range_max, long seed = 0 , long seed2 = 0 ,String opName= "LogUniformCandidateSampler" ) 
      {
         OperationDescription desc = NewOperation("LogUniformCandidateSampler", opName);
         desc.AddInput(true_classes);
         desc.SetAttr("num_true", num_true);
         desc.SetAttr("num_sampled", num_sampled);
         desc.SetAttr("unique", unique);
         desc.SetAttr("range_max", range_max);
         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="inputs">Input to the operation. </param>
      ///<param name="sequence_length">Input to the operation. </param>
      ///<param name="beam_width"></param>
      ///<param name="top_paths"></param>
      ///<param name="merge_repeated"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] decoded_indices(type: DtInt64).
      ///[1] decoded_values(type: DtInt64).
      ///[2] decoded_shape(type: DtInt64).
      ///[3] log_probability(type: DtFloat).
      ///</return>
      public Operation CTCBeamSearchDecoder (  Output inputs , Output sequence_length , long beam_width, long top_paths, bool merge_repeated = true ,String opName= "CTCBeamSearchDecoder" ) 
      {
         OperationDescription desc = NewOperation("CTCBeamSearchDecoder", opName);
         desc.AddInput(inputs);
         desc.AddInput(sequence_length);
         desc.SetAttr("beam_width", beam_width);
         desc.SetAttr("top_paths", top_paths);
         if (merge_repeated != true) desc.SetAttr("merge_repeated", merge_repeated);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reader_handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] records_produced(type: DtInt64).
      ///</return>
      public Operation ReaderNumRecordsProducedV2 (  Output reader_handle ,String opName= "ReaderNumRecordsProducedV2" ) 
      {
         OperationDescription desc = NewOperation("ReaderNumRecordsProducedV2", opName);
         desc.AddInput(reader_handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="fft_length">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtFloat).
      ///</return>
      public Operation IRFFT2D (  Output input , Output fft_length ,String opName= "IRFFT2D" ) 
      {
         OperationDescription desc = NewOperation("IRFFT2D", opName);
         desc.AddInput(input);
         desc.AddInput(fft_length);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="partition_ids">Input to the operation. </param>
      ///<param name="feature_ids">Input to the operation. </param>
      ///<param name="gradients">Input to the operation. </param>
      ///<param name="hessians">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_partition_ids(type: DtInt32).
      ///[1] output_feature_ids(type: DtInt64).
      ///[2] output_gradients(type: DtFloat).
      ///[3] output_hessians(type: DtFloat).
      ///</return>
      public Operation StatsAccumulatorScalarMakeSummary (  Output partition_ids , Output feature_ids , Output gradients , Output hessians ,String opName= "StatsAccumulatorScalarMakeSummary" ) 
      {
         OperationDescription desc = NewOperation("StatsAccumulatorScalarMakeSummary", opName);
         desc.AddInput(partition_ids);
         desc.AddInput(feature_ids);
         desc.AddInput(gradients);
         desc.AddInput(hessians);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="values">Input to the operation. </param>
      ///<param name="axis"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Pack (  Output values , long axis = 0 ,String opName= "Pack" ) 
      {
         OperationDescription desc = NewOperation("Pack", opName);
         desc.AddInput(values);

         if (axis != 0) desc.SetAttr("axis", axis);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="value">Input to the operation. </param>
      ///<param name="pooling_ratio"></param>
      ///<param name="pseudo_random"></param>
      ///<param name="overlapping"></param>
      ///<param name="deterministic"></param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///[1] row_pooling_sequence(type: DtInt64).
      ///[2] col_pooling_sequence(type: DtInt64).
      ///</return>
      public Operation FractionalAvgPool (  Output value , float[] pooling_ratio, bool pseudo_random = false , bool overlapping = false , bool deterministic = false , long seed = 0 , long seed2 = 0 ,String opName= "FractionalAvgPool" ) 
      {
         OperationDescription desc = NewOperation("FractionalAvgPool", opName);
         desc.AddInput(value);
         desc.SetAttr("pooling_ratio", pooling_ratio);
         if (pseudo_random != false) desc.SetAttr("pseudo_random", pseudo_random);
         if (overlapping != false) desc.SetAttr("overlapping", overlapping);
         if (deterministic != false) desc.SetAttr("deterministic", deterministic);
         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] length(type: DtInt32).
      ///</return>
      public Operation TensorListLength (  Output input_handle ,String opName= "TensorListLength" ) 
      {
         OperationDescription desc = NewOperation("TensorListLength", opName);
         desc.AddInput(input_handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///Serializes the scalar stats accumulator state.
      ///</summary>
      ///<param name="stats_accumulator_handle">Input to the operation: handle to the stats accumulator.</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] stamp_token(type: DtInt64): The current stamp token for the resource.
      ///[1] num_updates(type: DtInt64): Number of times stats were added to this accumulator since last     flush. output_partition_ids A vector of partition_ids for the slots.
      ///[2] output_partition_ids(type: DtInt32).
      ///[3] output_feature_ids(type: DtInt64): Rank 2 tensor of feature id and feature dimension ids.
      ///[4] output_gradients(type: DtFloat): A vector of gradients, with a value for each slot in &lt;output_partition_id, output_feature_id&gt;.
      ///[5] output_hessians(type: DtFloat): A vector of hessians, with a value for each slot in &lt;output_partition_id, output_feature_id&gt;.
      ///</return>
      public Operation StatsAccumulatorScalarSerialize (  Output stats_accumulator_handle ,String opName= "StatsAccumulatorScalarSerialize" ) 
      {
         OperationDescription desc = NewOperation("StatsAccumulatorScalarSerialize", opName);
         desc.AddInput(stats_accumulator_handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="diagonal">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation MatrixDiag (  Output diagonal ,String opName= "MatrixDiag" ) 
      {
         OperationDescription desc = NewOperation("MatrixDiag", opName);
         desc.AddInput(diagonal);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="images">Input to the operation. </param>
      ///<param name="size">Input to the operation. </param>
      ///<param name="align_corners"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] resized_images(type: DtInvalid).
      ///</return>
      public Operation ResizeNearestNeighbor (  Output images , Output size , bool align_corners = false ,String opName= "ResizeNearestNeighbor" ) 
      {
         OperationDescription desc = NewOperation("ResizeNearestNeighbor", opName);
         desc.AddInput(images);
         desc.AddInput(size);

         if (align_corners != false) desc.SetAttr("align_corners", align_corners);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_indices">Input to the operation. </param>
      ///<param name="input_values">Input to the operation. </param>
      ///<param name="input_shape">Input to the operation. </param>
      ///<param name="reduction_axes">Input to the operation. </param>
      ///<param name="keep_dims"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_indices(type: DtInt64).
      ///[1] output_values(type: DtInvalid).
      ///[2] output_shape(type: DtInt64).
      ///</return>
      public Operation SparseReduceMaxSparse (  Output input_indices , Output input_values , Output input_shape , Output reduction_axes , bool keep_dims = false ,String opName= "SparseReduceMaxSparse" ) 
      {
         OperationDescription desc = NewOperation("SparseReduceMaxSparse", opName);
         desc.AddInput(input_indices);
         desc.AddInput(input_values);
         desc.AddInput(input_shape);
         desc.AddInput(reduction_axes);

         if (keep_dims != false) desc.SetAttr("keep_dims", keep_dims);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///Checks whether a tensor stats accumulator has been initialized.
      ///</summary>
      ///<param name="stats_accumulator_handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] is_initialized(type: DtBool).
      ///</return>
      public Operation StatsAccumulatorTensorIsInitialized (  Output stats_accumulator_handle ,String opName= "StatsAccumulatorTensorIsInitialized" ) 
      {
         OperationDescription desc = NewOperation("StatsAccumulatorTensorIsInitialized", opName);
         desc.AddInput(stats_accumulator_handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="key_dtype"></param>
      ///<param name="value_dtype"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="use_node_name_sharing"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] table_handle(type: DtResource).
      ///</return>
      public Operation HashTableV2 (  DataType key_dtype, DataType value_dtype, string container = null , string shared_name = null , bool use_node_name_sharing = false ,String opName= "HashTableV2" ) 
      {
         OperationDescription desc = NewOperation("HashTableV2", opName);

         desc.SetAttr("key_dtype", key_dtype);
         desc.SetAttr("value_dtype", value_dtype);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         if (use_node_name_sharing != false) desc.SetAttr("use_node_name_sharing", use_node_name_sharing);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///Flushes the stats accumulator to output and resets the internal state.
      ///</summary>
      ///<param name="stats_accumulator_handle">Input to the operation: handle to the tree ensemble resource to be created.</param>
      ///<param name="stamp_token">Input to the operation: Stamp token for Read/Write operations. Any operation with a mismatching token will be dropped.</param>
      ///<param name="next_stamp_token">Input to the operation: Stamp token to be used for the next iteration.</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] num_updates(type: DtInt64): Number of times stats were added to this accumulator since last flush.
      ///[1] output_partition_ids(type: DtInt32): A vector of partition_ids for the slots.
      ///[2] output_feature_ids(type: DtInt64): Rank 2 tensor of feature id and feature dimension ids.
      ///[3] output_gradients(type: DtFloat): A tensor of gradients, first dimension matches slots in &lt;partition_id, feature_id, feature_dimension_id&gt;.
      ///[4] output_hessians(type: DtFloat): A tensor of hessians, first dimension matches slots in &lt;partition_id, feature_id, feature_dimension_id&gt;&gt;.
      ///</return>
      public Operation StatsAccumulatorTensorFlush (  Output stats_accumulator_handle , Output stamp_token , Output next_stamp_token ,String opName= "StatsAccumulatorTensorFlush" ) 
      {
         OperationDescription desc = NewOperation("StatsAccumulatorTensorFlush", opName);
         desc.AddInput(stats_accumulator_handle);
         desc.AddInput(stamp_token);
         desc.AddInput(next_stamp_token);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///Serializes the scalar stats accumulator state.
      ///</summary>
      ///<param name="stats_accumulator_handle">Input to the operation: handle to the tree ensemble resource to be created.</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] stamp_token(type: DtInt64): Stamp token for Read/Write operations. Any operation with a mismatching token will be dropped.
      ///[1] num_updates(type: DtInt64): Number of times stats were added to this accumulator since last flush.
      ///[2] output_partition_ids(type: DtInt32): A vector of partition_ids for the slots.
      ///[3] output_feature_ids(type: DtInt64): Rank 2 tensor of feature id and feature dimension ids.
      ///[4] output_gradients(type: DtFloat): A tensor of gradients, first dimension matches slots in &lt;partition_id, feature_id, feature_dimension_id&gt;.
      ///[5] output_hessians(type: DtFloat): A tensor of hessians, first dimension matches slots in &lt;partition_id, feature_id, feature_dimension_id&gt;.
      ///</return>
      public Operation StatsAccumulatorTensorSerialize (  Output stats_accumulator_handle ,String opName= "StatsAccumulatorTensorSerialize" ) 
      {
         OperationDescription desc = NewOperation("StatsAccumulatorTensorSerialize", opName);
         desc.AddInput(stats_accumulator_handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///Summarizes the stats by summing the &lt;gradients, hessians&gt; that are for the same
      ///</summary>
      ///<param name="partition_ids">Input to the operation: A vector of partition_ids.</param>
      ///<param name="feature_ids">Input to the operation: Rank 2 tensor of feature id and feature dimension ids.</param>
      ///<param name="gradients">Input to the operation: A vector of gradients for each slot in &lt;partition_id, feature_id, feature_dimension_id&gt;.</param>
      ///<param name="hessians">Input to the operation: A vector of hessians for each slot in &lt;partition_id, feature_id, feature_dimension_id&gt;.</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_partition_ids(type: DtInt32): A vector of partition_ids for the slots.
      ///[1] output_feature_ids(type: DtInt64): A rank2 tensor of feature_ids and dimensions for the slots.
      ///[2] output_gradients(type: DtFloat): A tensor of gradients, first dimension matches slots in &lt;partition_id, feature_id, feature_dimension_id&gt;.
      ///[3] output_hessians(type: DtFloat): A tensor of hessians, first dimension matches slots in &lt;partition_id, feature_id, feature_dimension_id&gt;.
      ///</return>
      public Operation StatsAccumulatorTensorMakeSummary (  Output partition_ids , Output feature_ids , Output gradients , Output hessians ,String opName= "StatsAccumulatorTensorMakeSummary" ) 
      {
         OperationDescription desc = NewOperation("StatsAccumulatorTensorMakeSummary", opName);
         desc.AddInput(partition_ids);
         desc.AddInput(feature_ids);
         desc.AddInput(gradients);
         desc.AddInput(hessians);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="accum_update">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="rho">Input to the operation. </param>
      ///<param name="epsilon">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceApplyAdadelta (  Output var , Output accum , Output accum_update , Output lr , Output rho , Output epsilon , Output grad , bool use_locking = false ,String opName= "ResourceApplyAdadelta" ) 
      {
         OperationDescription desc = NewOperation("ResourceApplyAdadelta", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(accum_update);
         desc.AddInput(lr);
         desc.AddInput(rho);
         desc.AddInput(epsilon);
         desc.AddInput(grad);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///Grows the tree ensemble by either adding a layer to the last tree being grown
      ///</summary>
      ///<param name="tree_ensemble_handle">Input to the operation: Handle to the ensemble variable.</param>
      ///<param name="stamp_token">Input to the operation: Stamp token for validating operation consistency.</param>
      ///<param name="next_stamp_token">Input to the operation: Stamp token to be used for the next iteration.</param>
      ///<param name="learning_rate">Input to the operation: Scalar learning rate.</param>
      ///<param name="dropout_seed">Input to the operation. </param>
      ///<param name="partition_ids">Input to the operation: List of Rank 1 Tensors containing partition Id per candidate.</param>
      ///<param name="gains">Input to the operation: List of Rank 1 Tensors containing gains per candidate.</param>
      ///<param name="splits">Input to the operation: List of Rank 1 Tensors containing serialized SplitInfo protos per candidate.</param>
      ///<param name="learner_config">Config for the learner of type LearnerConfig proto.</param>
      ///<param name="center_bias"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation GrowTreeEnsemble (  Output tree_ensemble_handle , Output stamp_token , Output next_stamp_token , Output learning_rate , Output dropout_seed , Output partition_ids , Output gains , Output splits , string learner_config, bool center_bias,String opName= "GrowTreeEnsemble" ) 
      {
         OperationDescription desc = NewOperation("GrowTreeEnsemble", opName);
         desc.AddInput(tree_ensemble_handle);
         desc.AddInput(stamp_token);
         desc.AddInput(next_stamp_token);
         desc.AddInput(learning_rate);
         desc.AddInput(dropout_seed);
         desc.AddInput(partition_ids);
         desc.AddInput(gains);
         desc.AddInput(splits);
         desc.SetAttr("learner_config", learner_config);
         desc.SetAttr("center_bias", center_bias);

         return desc.FinishOperation();
      } 
      // Skipped function _Send

      ///<summary>
      ///Decodes a range-coded `code` into an int32 tensor of shape `shape`.
      ///</summary>
      ///<param name="encoded">Input to the operation: A scalar string tensor from RangeEncode.</param>
      ///<param name="shape">Input to the operation: An int32 1-D tensor representing the shape of the data encoded by RangeEncode.</param>
      ///<param name="cdf">Input to the operation. </param>
      ///<param name="precision">The number of bits for probability quantization. Must be &lt;= 16, and must match the precision used by RangeEncode that produced `encoded`.</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] decoded(type: DtInt16): An int32 tensor with shape equal to `shape`.
      ///</return>
      public Operation RangeDecode (  Output encoded , Output shape , Output cdf , long precision,String opName= "RangeDecode" ) 
      {
         OperationDescription desc = NewOperation("RangeDecode", opName);
         desc.AddInput(encoded);
         desc.AddInput(shape);
         desc.AddInput(cdf);
         desc.SetAttr("precision", precision);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="value"></param>
      ///<param name="dtype"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Const (  Tensor value, DataType dtype,String opName= "Const" ) 
      {
         OperationDescription desc = NewOperation("Const", opName);

         desc.SetAttr("value", value);
         desc.SetAttr("dtype", dtype);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///Compute the backprop of both data and weights in a RNN.
      ///</summary>
      ///<param name="input">Input to the operation: a 3-D tensor with the shape of [seq_length, batch_size, input_size].</param>
      ///<param name="input_h">Input to the operation: a 3-D tensor with the shape of [num_layer * dir, batch_size, num_units].</param>
      ///<param name="input_c">Input to the operation: For LSTM, a 3-D tensor with the shape of [num_layer * dir, batch, num_units]. For other models, it is ignored.</param>
      ///<param name="parameters">Input to the operation: a 1-D tensor that contains the weights and biases in an opaque layout. The size must be created through CudnnRNNParamsSize, and initialized separately. Note that they might not be compatible across different generations. So it is a good idea to save and restore</param>
      ///<param name="output">Input to the operation: a 3-D tensor with the shape of [seq_length, batch_size, dir * num_units].</param>
      ///<param name="output_h">Input to the operation: the same shape has input_h.</param>
      ///<param name="output_c">Input to the operation: the same shape as input_c for LSTM. An empty tensor for other models.</param>
      ///<param name="output_backprop">Input to the operation: A 3-D tensor with the same shape as output in the forward pass.</param>
      ///<param name="output_h_backprop">Input to the operation: A 3-D tensor with the same shape as output_h in the forward pass.</param>
      ///<param name="output_c_backprop">Input to the operation: A 3-D tensor with the same shape as output_c in the forward pass.</param>
      ///<param name="reserve_space">Input to the operation: The same reserve_space produced in for forward operation.</param>
      ///<param name="rnn_mode">Indicates the type of the RNN model.</param>
      ///<param name="input_mode">Indicate whether there is a linear projection between the input and The actual computation before the first layer. 'skip_input' is only allowed when input_size == num_units; 'auto_select' implies 'skip_input' when input_size == num_units; otherwise, it implies 'linear_input'.</param>
      ///<param name="direction">Indicates whether a bidirectional model will be used. dir = (direction == bidirectional) ? 2 : 1</param>
      ///<param name="dropout">dropout probability. When set to 0., dropout is disabled.</param>
      ///<param name="seed">the 1st part of a seed to initialize dropout.</param>
      ///<param name="seed2">the 2nd part of a seed to initialize dropout.</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] input_backprop(type: DtInvalid): The backprop to input in the forward pass. Has the same shape as input.
      ///[1] input_h_backprop(type: DtInvalid): The backprop to input_h in the forward pass. Has the same shape as input_h.
      ///[2] input_c_backprop(type: DtInvalid): The backprop to input_c in the forward pass. Has the same shape as input_c.
      ///[3] params_backprop(type: DtInvalid): The backprop to the params buffer in the forward pass. Has the same shape as params.
      ///</return>
      public Operation CudnnRNNBackprop (  Output input , Output input_h , Output input_c , Output parameters , Output output , Output output_h , Output output_c , Output output_backprop , Output output_h_backprop , Output output_c_backprop , Output reserve_space , string rnn_mode = null , string input_mode = null , string direction = null , float dropout = 0f , long seed = 0 , long seed2 = 0 ,String opName= "CudnnRNNBackprop" ) 
      {
         OperationDescription desc = NewOperation("CudnnRNNBackprop", opName);
         desc.AddInput(input);
         desc.AddInput(input_h);
         desc.AddInput(input_c);
         desc.AddInput(parameters);
         desc.AddInput(output);
         desc.AddInput(output_h);
         desc.AddInput(output_c);
         desc.AddInput(output_backprop);
         desc.AddInput(output_h_backprop);
         desc.AddInput(output_c_backprop);
         desc.AddInput(reserve_space);

         if (rnn_mode != null) desc.SetAttr("rnn_mode", rnn_mode);
         if (input_mode != null) desc.SetAttr("input_mode", input_mode);
         if (direction != null) desc.SetAttr("direction", direction);
         if (dropout != 0f) desc.SetAttr("dropout", dropout);
         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///Creates a dataset that contains the elements of `input_dataset` ignoring errors.
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation IgnoreErrorsDataset (  Output input_dataset , DataType[] output_types, long[][] output_shapes,String opName= "IgnoreErrorsDataset" ) 
      {
         OperationDescription desc = NewOperation("IgnoreErrorsDataset", opName);
         desc.AddInput(input_dataset);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///Gets the next element from a FunctionBufferingResource.
      ///</summary>
      ///<param name="function_buffer_resource">Input to the operation: The FunctionBufferingResource handle.</param>
      ///<param name="output_types">The type list for the return values.</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid): A list of return values.
      ///</return>
      public Operation FunctionBufferingResourceGetNext (  Output function_buffer_resource , DataType[] output_types,String opName= "FunctionBufferingResourceGetNext" ) 
      {
         OperationDescription desc = NewOperation("FunctionBufferingResourceGetNext", opName);
         desc.AddInput(function_buffer_resource);
         desc.SetAttr("output_types", output_types);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="file_pattern">Input to the operation. </param>
      ///<param name="tensor_name">Input to the operation. </param>
      ///<param name="shape_and_slice">Input to the operation. </param>
      ///<param name="dt"></param>
      ///<param name="preferred_shard"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] tensor(type: DtInvalid).
      ///</return>
      public Operation RestoreSlice (  Output file_pattern , Output tensor_name , Output shape_and_slice , DataType dt, long preferred_shard = -1 ,String opName= "RestoreSlice" ) 
      {
         OperationDescription desc = NewOperation("RestoreSlice", opName);
         desc.AddInput(file_pattern);
         desc.AddInput(tensor_name);
         desc.AddInput(shape_and_slice);
         desc.SetAttr("dt", dt);
         if (preferred_shard != -1) desc.SetAttr("preferred_shard", preferred_shard);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="features">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] activations(type: DtInvalid).
      ///</return>
      public Operation Softplus (  Output features ,String opName= "Softplus" ) 
      {
         OperationDescription desc = NewOperation("Softplus", opName);
         desc.AddInput(features);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///Creates a dataset that uses a custom thread pool to compute `input_dataset`.
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="thread_pool">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant): A resource produced by the ThreadPoolHandle op.
      ///</return>
      public Operation ThreadPoolDataset (  Output input_dataset , Output thread_pool , DataType[] output_types, long[][] output_shapes,String opName= "ThreadPoolDataset" ) 
      {
         OperationDescription desc = NewOperation("ThreadPoolDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(thread_pool);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation StopGradient (  Output input ,String opName= "StopGradient" ) 
      {
         OperationDescription desc = NewOperation("StopGradient", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///Creates a custom thread pool with the given number of threads.
      ///</summary>
      ///<param name="num_threads">The number of threads in the thread pool.</param>
      ///<param name="display_name">A human-readable name for the threads that may be visible in some visualizations.</param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtResource): A resource that can be consumed by one or more ThreadPoolDataset ops.
      ///</return>
      public Operation ThreadPoolHandle (  long num_threads, string display_name, string container = null , string shared_name = null ,String opName= "ThreadPoolHandle" ) 
      {
         OperationDescription desc = NewOperation("ThreadPoolHandle", opName);

         desc.SetAttr("num_threads", num_threads);
         desc.SetAttr("display_name", display_name);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///  Computes the derivative of the routing loss with respect to each decision
      ///</summary>
      ///<param name="input_data">Input to the operation. </param>
      ///<param name="tree_parameters">Input to the operation. </param>
      ///<param name="tree_biases">Input to the operation. </param>
      ///<param name="path_probability">Input to the operation. </param>
      ///<param name="path">Input to the operation. </param>
      ///<param name="tree_depth"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] routing_gradient(type: DtFloat).
      ///[1] data_gradient(type: DtFloat).
      ///[2] parameter_gradient(type: DtFloat).
      ///[3] bias_gradient(type: DtFloat).
      ///</return>
      public Operation StochasticHardRoutingGradient (  Output input_data , Output tree_parameters , Output tree_biases , Output path_probability , Output path , long tree_depth,String opName= "StochasticHardRoutingGradient" ) 
      {
         OperationDescription desc = NewOperation("StochasticHardRoutingGradient", opName);
         desc.AddInput(input_data);
         desc.AddInput(tree_parameters);
         desc.AddInput(tree_biases);
         desc.AddInput(path_probability);
         desc.AddInput(path);
         desc.SetAttr("tree_depth", tree_depth);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reader_handle">Input to the operation. </param>
      ///<param name="state">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation ReaderRestoreState (  Output reader_handle , Output state ,String opName= "ReaderRestoreState" ) 
      {
         OperationDescription desc = NewOperation("ReaderRestoreState", opName);
         desc.AddInput(reader_handle);
         desc.AddInput(state);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="filter">Input to the operation. </param>
      ///<param name="out_backprop">Input to the operation. </param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Conv3DBackpropFilter (  Output input , Output filter , Output out_backprop , long[] strides, string padding,String opName= "Conv3DBackpropFilter" ) 
      {
         OperationDescription desc = NewOperation("Conv3DBackpropFilter", opName);
         desc.AddInput(input);
         desc.AddInput(filter);
         desc.AddInput(out_backprop);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="out_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation ShapeN (  Output input , DataType? out_type = null ,String opName= "ShapeN" ) 
      {
         OperationDescription desc = NewOperation("ShapeN", opName);
         desc.AddInput(input);

         if (out_type.HasValue) desc.SetAttr("out_type", out_type.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Tan (  Output x ,String opName= "Tan" ) 
      {
         OperationDescription desc = NewOperation("Tan", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Inv (  Output x ,String opName= "Inv" ) 
      {
         OperationDescription desc = NewOperation("Inv", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///Selects num_to_sample rows of input using the KMeans++ criterion.
      ///</summary>
      ///<param name="points">Input to the operation: Matrix of shape (n, d). Rows are assumed to be input points.</param>
      ///<param name="num_to_sample">Input to the operation: Scalar. The number of rows to sample. This value must not be larger than n.</param>
      ///<param name="seed">Input to the operation: Scalar. Seed for initializing the random number generator.</param>
      ///<param name="num_retries_per_sample">Input to the operation: Scalar. For each row that is sampled, this parameter specifies the number of additional points to draw from the current distribution before selecting the best. If a negative value is specified, a heuristic is used to sample O(log(num_to_sample)) additional points.</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] samples(type: DtFloat): Matrix of shape (num_to_sample, d). The sampled rows.
      ///</return>
      public Operation KmeansPlusPlusInitialization (  Output points , Output num_to_sample , Output seed , Output num_retries_per_sample ,String opName= "KmeansPlusPlusInitialization" ) 
      {
         OperationDescription desc = NewOperation("KmeansPlusPlusInitialization", opName);
         desc.AddInput(points);
         desc.AddInput(num_to_sample);
         desc.AddInput(seed);
         desc.AddInput(num_retries_per_sample);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///Returns the index of a data point that should be added to the seed set.
      ///</summary>
      ///<param name="distances">Input to the operation: Vector with squared distances to the closest previously sampled cluster center for each candidate point.</param>
      ///<param name="seed">Input to the operation: Scalar. Seed for initializing the random number generator.</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] index(type: DtInt64): Scalar with the index of the sampled point.
      ///</return>
      public Operation KMC2ChainInitialization (  Output distances , Output seed ,String opName= "KMC2ChainInitialization" ) 
      {
         OperationDescription desc = NewOperation("KMC2ChainInitialization", opName);
         desc.AddInput(distances);
         desc.AddInput(seed);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation BatchMatrixDeterminant (  Output input ,String opName= "BatchMatrixDeterminant" ) 
      {
         OperationDescription desc = NewOperation("BatchMatrixDeterminant", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reference">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="updates">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_ref(type: DtInvalid).
      ///</return>
      public Operation ScatterSub (  Output reference , Output indices , Output updates , bool use_locking = false ,String opName= "ScatterSub" ) 
      {
         OperationDescription desc = NewOperation("ScatterSub", opName);
         desc.AddInput(reference);
         desc.AddInput(indices);
         desc.AddInput(updates);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation Maximum (  Output x , Output y ,String opName= "Maximum" ) 
      {
         OperationDescription desc = NewOperation("Maximum", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///Initialize 'ref' with all zeros. This op requires that the tensor is not
      ///</summary>
      ///<param name="reference">Input to the operation: Should be from a `Variable` node.</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_ref(type: DtInvalid): = Same as "ref".
      ///</return>
      public Operation ZeroInitializer (  Output reference ,String opName= "ZeroInitializer" ) 
      {
         OperationDescription desc = NewOperation("ZeroInitializer", opName);
         desc.AddInput(reference);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///Adjust the YIQ hue of one or more images.
      ///</summary>
      ///<param name="images">Input to the operation: Images to adjust.  At least 3-D.</param>
      ///<param name="delta_h">Input to the operation: A float scale that represents the hue rotation amount, in radians. Although delta_h can be any float value.</param>
      ///<param name="scale_s">Input to the operation: A float scale that represents the factor to multiply the saturation by. scale_s needs to be non-negative.</param>
      ///<param name="scale_v">Input to the operation: A float scale that represents the factor to multiply the value by. scale_v needs to be non-negative.</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid): The hsv-adjusted image or images. No clipping will be done in this op. The client can clip them using additional ops in their graph.
      ///</return>
      public Operation AdjustHsvInYiq (  Output images , Output delta_h , Output scale_s , Output scale_v ,String opName= "AdjustHsvInYiq" ) 
      {
         OperationDescription desc = NewOperation("AdjustHsvInYiq", opName);
         desc.AddInput(images);
         desc.AddInput(delta_h);
         desc.AddInput(scale_s);
         desc.AddInput(scale_v);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///Applies the given transform to each of the images.
      ///</summary>
      ///<param name="images">Input to the operation: 4D `Tensor`, input image(s) in NHWC format.</param>
      ///<param name="transforms">Input to the operation: 2D `Tensor`, projective transform(s) to apply to the image(s).</param>
      ///<param name="interpolation"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] transformed_images(type: DtInvalid): 4D `Tensor`, image(s) in NHWC format, generated by applying the `transforms` to the `images`. Satisfies the description above.
      ///</return>
      public Operation ImageProjectiveTransform (  Output images , Output transforms , string interpolation,String opName= "ImageProjectiveTransform" ) 
      {
         OperationDescription desc = NewOperation("ImageProjectiveTransform", opName);
         desc.AddInput(images);
         desc.AddInput(transforms);
         desc.SetAttr("interpolation", interpolation);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="s0">Input to the operation. </param>
      ///<param name="s1">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] r0(type: DtInvalid).
      ///[1] r1(type: DtInvalid).
      ///</return>
      public Operation BroadcastGradientArgs (  Output s0 , Output s1 ,String opName= "BroadcastGradientArgs" ) 
      {
         OperationDescription desc = NewOperation("BroadcastGradientArgs", opName);
         desc.AddInput(s0);
         desc.AddInput(s1);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///Find bipartite matching based on a given distance matrix.
      ///</summary>
      ///<param name="distance_mat">Input to the operation: A 2-D float tensor of shape `[num_rows, num_columns]`. It is a pair-wise distance matrix between the entities represented by each row and each column. It is an asymmetric matrix. The smaller the distance is, the more similar the pairs are. The bipartite matching is to minimize the distances.</param>
      ///<param name="num_valid_rows">Input to the operation: A scalar or a 1-D tensor with one element describing the number of valid rows of distance_mat to consider for the bipartite matching. If set to be negative, then all rows from `distance_mat` are used.</param>
      ///<param name="top_k">A scalar that specifies the number of top-k matches to retrieve. If set to be negative, then is set according to the maximum number of matches from `distance_mat`.</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] row_to_col_match_indices(type: DtInt32): A vector of length num_rows, which is the number of rows of the input `distance_matrix`. If `row_to_col_match_indices[i]` is not -1, row i is matched to column `row_to_col_match_indices[i]`.
      ///[1] col_to_row_match_indices(type: DtInt32): A vector of length num_columns, which is the number of columns of the input ditance matrix. If `col_to_row_match_indices[j]` is not -1, column j is matched to row `col_to_row_match_indices[j]`.
      ///</return>
      public Operation BipartiteMatch (  Output distance_mat , Output num_valid_rows , long top_k = -1 ,String opName= "BipartiteMatch" ) 
      {
         OperationDescription desc = NewOperation("BipartiteMatch", opName);
         desc.AddInput(distance_mat);
         desc.AddInput(num_valid_rows);

         if (top_k != -1) desc.SetAttr("top_k", top_k);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="resource_handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] string_handle(type: DtString).
      ///</return>
      public Operation IteratorToStringHandle (  Output resource_handle ,String opName= "IteratorToStringHandle" ) 
      {
         OperationDescription desc = NewOperation("IteratorToStringHandle", opName);
         desc.AddInput(resource_handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_indices">Input to the operation. </param>
      ///<param name="input_shape">Input to the operation. </param>
      ///<param name="new_shape">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_indices(type: DtInt64).
      ///[1] output_shape(type: DtInt64).
      ///</return>
      public Operation SparseReshape (  Output input_indices , Output input_shape , Output new_shape ,String opName= "SparseReshape" ) 
      {
         OperationDescription desc = NewOperation("SparseReshape", opName);
         desc.AddInput(input_indices);
         desc.AddInput(input_shape);
         desc.AddInput(new_shape);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///Find the connected components of image(s).
      ///</summary>
      ///<param name="image">Input to the operation: Image(s) with shape (N, H, W).</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] components(type: DtInt64): Component ids for each pixel in "image". Same shape as "image". Zero pixels all have an output of 0, and all components of adjacent pixels with the same value are given consecutive ids, starting from 1.
      ///</return>
      public Operation ImageConnectedComponents (  Output image ,String opName= "ImageConnectedComponents" ) 
      {
         OperationDescription desc = NewOperation("ImageConnectedComponents", opName);
         desc.AddInput(image);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="value">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] flow_out(type: DtFloat).
      ///</return>
      public Operation TensorArrayScatter (  Output handle , Output indices , Output value , Output flow_in ,String opName= "TensorArrayScatter" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayScatter", opName);
         desc.AddInput(handle);
         desc.AddInput(indices);
         desc.AddInput(value);
         desc.AddInput(flow_in);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///Outputs a single image random dot stereogram for export via encode_PNG/JPG OP.
      ///</summary>
      ///<param name="depth_values">Input to the operation: Z values of data to encode into 'output_data_window' window, lower values are further away {0.0 floor(far), 1.0 ceiling(near) after normalization}, must be 2-D tensor</param>
      ///<param name="hidden_surface_removal">Activate hidden surface removal</param>
      ///<param name="convergence_dots_size">Black dot size in pixels to help view converge image, drawn on bottom of image</param>
      ///<param name="dots_per_inch">Output device in dots/inch</param>
      ///<param name="eye_separation">Separation between eyes in inches</param>
      ///<param name="mu">Depth of field, Fraction of viewing distance (eg. 1/3 = .3333)</param>
      ///<param name="normalize">Normalize input data to [0.0, 1.0]</param>
      ///<param name="normalize_max">Fix MAX value for Normalization - if &lt; MIN, autoscale</param>
      ///<param name="normalize_min">Fix MIN value for Normalization - if &gt; MAX, autoscale</param>
      ///<param name="border_level">Value of border depth 0.0 {far} to 1.0 {near}</param>
      ///<param name="number_colors">2 (Black & White),256 (grayscale), and Numbers &gt; 256 (Full Color) are all that are supported currently</param>
      ///<param name="output_image_shape">Output size of returned image in X,Y, Channels 1-grayscale, 3 color (1024, 768, 1), channels will be updated to 3 if 'number_colors' &gt; 256</param>
      ///<param name="output_data_window">Size of "DATA" window, must be equal to or smaller than 'output_image_shape', will be centered and use 'convergence_dots_size' for best fit to avoid overlap if possible</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] image(type: DtUint8): = A tensor of size 'output_image_shape' with the encloded 'depth_values'
      ///</return>
      public Operation SingleImageRandomDotStereograms (  Output depth_values , bool hidden_surface_removal = true , long convergence_dots_size = 8 , long dots_per_inch = 72 , float eye_separation = 2.5f , float mu = 0.3333f , bool normalize = true , float normalize_max = -100f , float normalize_min = 100f , float border_level = 0f , long number_colors = 256 , long[] output_image_shape = null , long[] output_data_window = null ,String opName= "SingleImageRandomDotStereograms" ) 
      {
         OperationDescription desc = NewOperation("SingleImageRandomDotStereograms", opName);
         desc.AddInput(depth_values);

         if (hidden_surface_removal != true) desc.SetAttr("hidden_surface_removal", hidden_surface_removal);
         if (convergence_dots_size != 8) desc.SetAttr("convergence_dots_size", convergence_dots_size);
         if (dots_per_inch != 72) desc.SetAttr("dots_per_inch", dots_per_inch);
         if (eye_separation != 2.5f) desc.SetAttr("eye_separation", eye_separation);
         if (mu != 0.3333f) desc.SetAttr("mu", mu);
         if (normalize != true) desc.SetAttr("normalize", normalize);
         if (normalize_max != -100f) desc.SetAttr("normalize_max", normalize_max);
         if (normalize_min != 100f) desc.SetAttr("normalize_min", normalize_min);
         if (border_level != 0f) desc.SetAttr("border_level", border_level);
         if (number_colors != 256) desc.SetAttr("number_colors", number_colors);
         if (output_image_shape != null) desc.SetAttrShape("output_image_shape", output_image_shape);
         if (output_data_window != null) desc.SetAttrShape("output_data_window", output_data_window);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="true_classes">Input to the operation. </param>
      ///<param name="sampled_candidates">Input to the operation. </param>
      ///<param name="num_true"></param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] indices(type: DtInt32).
      ///[1] ids(type: DtInt64).
      ///[2] weights(type: DtFloat).
      ///</return>
      public Operation ComputeAccidentalHits (  Output true_classes , Output sampled_candidates , long num_true, long seed = 0 , long seed2 = 0 ,String opName= "ComputeAccidentalHits" ) 
      {
         OperationDescription desc = NewOperation("ComputeAccidentalHits", opName);
         desc.AddInput(true_classes);
         desc.AddInput(sampled_candidates);
         desc.SetAttr("num_true", num_true);
         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation TensorArrayCloseV2 (  Output handle ,String opName= "TensorArrayCloseV2" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayCloseV2", opName);
         desc.AddInput(handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///Generates sparse cross form a list of sparse tensors.
      ///</summary>
      ///<param name="indices">Input to the operation: 2-D.  Indices of each input `SparseTensor`.</param>
      ///<param name="values">Input to the operation: 1-D.   values of each `SparseTensor`.</param>
      ///<param name="shapes">Input to the operation: 1-D.   Shapes of each `SparseTensor`.</param>
      ///<param name="dense">Input to the operation: 2-D.    Columns represented by dense `Tensor`.</param>
      ///<param name="hashed_output"></param>
      ///<param name="num_buckets"></param>
      ///<param name="out_type"></param>
      ///<param name="internal_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_indices(type: DtInt64): 2-D.  Indices of the concatenated `SparseTensor`.
      ///[1] output_values(type: DtInvalid): 1-D.  Non-empty values of the concatenated or hashed `SparseTensor`.
      ///[2] output_shape(type: DtInt64): 1-D.  Shape of the concatenated `SparseTensor`.
      ///</return>
      public Operation SparseFeatureCross (  Output indices , Output values , Output shapes , Output dense , bool hashed_output, long num_buckets, DataType out_type, DataType internal_type,String opName= "SparseFeatureCross" ) 
      {
         OperationDescription desc = NewOperation("SparseFeatureCross", opName);
         desc.AddInput(indices);
         desc.AddInput(values);
         desc.AddInput(shapes);
         desc.AddInput(dense);
         desc.SetAttr("hashed_output", hashed_output);
         desc.SetAttr("num_buckets", num_buckets);
         desc.SetAttr("out_type", out_type);
         desc.SetAttr("internal_type", internal_type);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///Generates sparse cross form a list of sparse tensors.
      ///</summary>
      ///<param name="indices">Input to the operation: 2-D.  Indices of each input `SparseTensor`.</param>
      ///<param name="values">Input to the operation: 1-D.   values of each `SparseTensor`.</param>
      ///<param name="shapes">Input to the operation: 1-D.   Shapes of each `SparseTensor`.</param>
      ///<param name="dense">Input to the operation: 2-D.    Columns represented by dense `Tensor`.</param>
      ///<param name="hashed_output"></param>
      ///<param name="num_buckets"></param>
      ///<param name="hash_key"></param>
      ///<param name="out_type"></param>
      ///<param name="internal_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_indices(type: DtInt64): 2-D.  Indices of the concatenated `SparseTensor`.
      ///[1] output_values(type: DtInvalid): 1-D.  Non-empty values of the concatenated or hashed `SparseTensor`.
      ///[2] output_shape(type: DtInt64): 1-D.  Shape of the concatenated `SparseTensor`.
      ///</return>
      public Operation SparseFeatureCrossV2 (  Output indices , Output values , Output shapes , Output dense , bool hashed_output, long num_buckets, long hash_key, DataType out_type, DataType internal_type,String opName= "SparseFeatureCrossV2" ) 
      {
         OperationDescription desc = NewOperation("SparseFeatureCrossV2", opName);
         desc.AddInput(indices);
         desc.AddInput(values);
         desc.AddInput(shapes);
         desc.AddInput(dense);
         desc.SetAttr("hashed_output", hashed_output);
         desc.SetAttr("num_buckets", num_buckets);
         desc.SetAttr("hash_key", hash_key);
         desc.SetAttr("out_type", out_type);
         desc.SetAttr("internal_type", internal_type);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///Convert LibSVM input to tensors. The output consists of
      ///</summary>
      ///<param name="input">Input to the operation: Each string is a record in the LibSVM.</param>
      ///<param name="num_features">The number of features.</param>
      ///<param name="dtype"></param>
      ///<param name="label_dtype"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] label(type: DtInvalid): A tensor of the same shape as input.
      ///[1] feature_indices(type: DtInt64): A 2-D int64 tensor of dense_shape [N, ndims].
      ///[2] feature_values(type: DtInvalid): A 1-D tensor of any type and dense_shape [N].
      ///[3] feature_shape(type: DtInt64): A 1-D int64 tensor of dense_shape [ndims].
      ///</return>
      public Operation DecodeLibsvm (  Output input , long num_features, DataType? dtype = null , DataType? label_dtype = null ,String opName= "DecodeLibsvm" ) 
      {
         OperationDescription desc = NewOperation("DecodeLibsvm", opName);
         desc.AddInput(input);
         desc.SetAttr("num_features", num_features);
         if (dtype.HasValue) desc.SetAttr("dtype", dtype.Value);
         if (label_dtype.HasValue) desc.SetAttr("label_dtype", label_dtype.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///Resampler op.
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="warp">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Resampler (  Output data , Output warp ,String opName= "Resampler" ) 
      {
         OperationDescription desc = NewOperation("Resampler", opName);
         desc.AddInput(data);
         desc.AddInput(warp);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="file_pattern"></param>
      ///<param name="file_random_seed"></param>
      ///<param name="file_shuffle_shift_ratio"></param>
      ///<param name="file_buffer_size"></param>
      ///<param name="file_parallelism"></param>
      ///<param name="batch_size"></param>
      ///<param name="compression_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] records(type: DtString).
      ///</return>
      public Operation RecordInput (  string file_pattern, long file_random_seed = 301 , float file_shuffle_shift_ratio = 0f , long file_buffer_size = 10000 , long file_parallelism = 16 , long batch_size = 32 , string compression_type = null ,String opName= "RecordInput" ) 
      {
         OperationDescription desc = NewOperation("RecordInput", opName);

         desc.SetAttr("file_pattern", file_pattern);
         if (file_random_seed != 301) desc.SetAttr("file_random_seed", file_random_seed);
         if (file_shuffle_shift_ratio != 0f) desc.SetAttr("file_shuffle_shift_ratio", file_shuffle_shift_ratio);
         if (file_buffer_size != 10000) desc.SetAttr("file_buffer_size", file_buffer_size);
         if (file_parallelism != 16) desc.SetAttr("file_parallelism", file_parallelism);
         if (batch_size != 32) desc.SetAttr("batch_size", batch_size);
         if (compression_type != null) desc.SetAttr("compression_type", compression_type);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="initial_state">Input to the operation. </param>
      ///<param name="other_arguments">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      //The following attributes are not known: f: func
      public Operation ScanDataset (  Output input_dataset , Output initial_state , Output other_arguments , DataType[] output_types, long[][] output_shapes,String opName= "ScanDataset" ) 
      {
         OperationDescription desc = NewOperation("ScanDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(initial_state);
         desc.AddInput(other_arguments);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="index">Input to the operation. </param>
      ///<param name="value">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] flow_out(type: DtFloat).
      ///</return>
      public Operation TensorArrayWrite (  Output handle , Output index , Output value , Output flow_in ,String opName= "TensorArrayWrite" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayWrite", opName);
         desc.AddInput(handle);
         desc.AddInput(index);
         desc.AddInput(value);
         desc.AddInput(flow_in);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="resource">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="updates">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceScatterAdd (  Output resource , Output indices , Output updates ,String opName= "ResourceScatterAdd" ) 
      {
         OperationDescription desc = NewOperation("ResourceScatterAdd", opName);
         desc.AddInput(resource);
         desc.AddInput(indices);
         desc.AddInput(updates);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Ceil (  Output x ,String opName= "Ceil" ) 
      {
         OperationDescription desc = NewOperation("Ceil", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="seq_lengths">Input to the operation. </param>
      ///<param name="seq_dim"></param>
      ///<param name="batch_dim"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation ReverseSequence (  Output input , Output seq_lengths , long seq_dim, long batch_dim = 0 ,String opName= "ReverseSequence" ) 
      {
         OperationDescription desc = NewOperation("ReverseSequence", opName);
         desc.AddInput(input);
         desc.AddInput(seq_lengths);
         desc.SetAttr("seq_dim", seq_dim);
         if (batch_dim != 0) desc.SetAttr("batch_dim", batch_dim);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///Resampler Grad op.
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="warp">Input to the operation. </param>
      ///<param name="grad_output">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] grad_data(type: DtInvalid).
      ///[1] grad_warp(type: DtInvalid).
      ///</return>
      public Operation ResamplerGrad (  Output data , Output warp , Output grad_output ,String opName= "ResamplerGrad" ) 
      {
         OperationDescription desc = NewOperation("ResamplerGrad", opName);
         desc.AddInput(data);
         desc.AddInput(warp);
         desc.AddInput(grad_output);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///  Chooses a single path for each instance in `input_data` and returns the leaf
      ///</summary>
      ///<param name="input_data">Input to the operation. </param>
      ///<param name="tree_parameters">Input to the operation. </param>
      ///<param name="tree_biases">Input to the operation. </param>
      ///<param name="max_nodes"></param>
      ///<param name="tree_depth"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] path_probability(type: DtFloat).
      ///[1] path(type: DtInt32).
      ///</return>
      public Operation HardRoutingFunction (  Output input_data , Output tree_parameters , Output tree_biases , long max_nodes, long tree_depth,String opName= "HardRoutingFunction" ) 
      {
         OperationDescription desc = NewOperation("HardRoutingFunction", opName);
         desc.AddInput(input_data);
         desc.AddInput(tree_parameters);
         desc.AddInput(tree_biases);
         desc.SetAttr("max_nodes", max_nodes);
         desc.SetAttr("tree_depth", tree_depth);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///    Computes the derivative of the routing loss with respect to each decision
      ///</summary>
      ///<param name="input_data">Input to the operation. </param>
      ///<param name="tree_parameters">Input to the operation. </param>
      ///<param name="tree_biases">Input to the operation. </param>
      ///<param name="routes">Input to the operation. </param>
      ///<param name="layer_num"></param>
      ///<param name="random_seed"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] routing_gradient(type: DtFloat).
      ///[1] data_gradient(type: DtFloat).
      ///[2] weight_gradient(type: DtFloat).
      ///</return>
      public Operation KFeatureGradient (  Output input_data , Output tree_parameters , Output tree_biases , Output routes , long layer_num, long random_seed,String opName= "KFeatureGradient" ) 
      {
         OperationDescription desc = NewOperation("KFeatureGradient", opName);
         desc.AddInput(input_data);
         desc.AddInput(tree_parameters);
         desc.AddInput(tree_biases);
         desc.AddInput(routes);
         desc.SetAttr("layer_num", layer_num);
         desc.SetAttr("random_seed", random_seed);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_datasets">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation ZipDataset (  Output input_datasets , DataType[] output_types, long[][] output_shapes,String opName= "ZipDataset" ) 
      {
         OperationDescription desc = NewOperation("ZipDataset", opName);
         desc.AddInput(input_datasets);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///  Takes a batch of paths through a tree and a batch of values along those paths
      ///</summary>
      ///<param name="path">Input to the operation. </param>
      ///<param name="path_values">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] unpacked_path(type: DtFloat).
      ///</return>
      public Operation UnpackPath (  Output path , Output path_values ,String opName= "UnpackPath" ) 
      {
         OperationDescription desc = NewOperation("UnpackPath", opName);
         desc.AddInput(path);
         desc.AddInput(path_values);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="serialized">Input to the operation. </param>
      ///<param name="dense_defaults">Input to the operation. </param>
      ///<param name="num_sparse"></param>
      ///<param name="sparse_keys"></param>
      ///<param name="dense_keys"></param>
      ///<param name="sparse_types"></param>
      ///<param name="dense_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] sparse_indices(type: DtInt64).
      ///[1] sparse_values(type: DtInvalid).
      ///[2] sparse_shapes(type: DtInt64).
      ///[3] dense_values(type: DtInvalid).
      ///</return>
      public Operation ParseSingleExample (  Output serialized , Output dense_defaults , long num_sparse, string[] sparse_keys, string[] dense_keys, DataType[] sparse_types, long[][] dense_shapes,String opName= "ParseSingleExample" ) 
      {
         OperationDescription desc = NewOperation("ParseSingleExample", opName);
         desc.AddInput(serialized);
         desc.AddInput(dense_defaults);
         desc.SetAttr("num_sparse", num_sparse);
         desc.SetAttr("sparse_keys", sparse_keys);
         desc.SetAttr("dense_keys", dense_keys);
         desc.SetAttr("sparse_types", sparse_types);
         desc.SetAttrShapeList("dense_shapes", dense_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///  Returns the probability that each input will reach each leaf node.  Each
      ///</summary>
      ///<param name="input_data">Input to the operation. </param>
      ///<param name="tree_parameters">Input to the operation. </param>
      ///<param name="tree_biases">Input to the operation. </param>
      ///<param name="layer_num"></param>
      ///<param name="max_nodes"></param>
      ///<param name="num_features_per_node"></param>
      ///<param name="random_seed"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] probabilities(type: DtFloat).
      ///</return>
      public Operation KFeatureRoutingFunction (  Output input_data , Output tree_parameters , Output tree_biases , long layer_num, long max_nodes, long num_features_per_node, long random_seed,String opName= "KFeatureRoutingFunction" ) 
      {
         OperationDescription desc = NewOperation("KFeatureRoutingFunction", opName);
         desc.AddInput(input_data);
         desc.AddInput(tree_parameters);
         desc.AddInput(tree_biases);
         desc.SetAttr("layer_num", layer_num);
         desc.SetAttr("max_nodes", max_nodes);
         desc.SetAttr("num_features_per_node", num_features_per_node);
         desc.SetAttr("random_seed", random_seed);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///  Computes the derivative of the routing loss with respect to each decision
      ///</summary>
      ///<param name="input_data">Input to the operation. </param>
      ///<param name="tree_parameters">Input to the operation. </param>
      ///<param name="tree_biases">Input to the operation. </param>
      ///<param name="routes">Input to the operation. </param>
      ///<param name="max_nodes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] routing_gradient(type: DtFloat).
      ///</return>
      public Operation RoutingGradient (  Output input_data , Output tree_parameters , Output tree_biases , Output routes , long max_nodes,String opName= "RoutingGradient" ) 
      {
         OperationDescription desc = NewOperation("RoutingGradient", opName);
         desc.AddInput(input_data);
         desc.AddInput(tree_parameters);
         desc.AddInput(tree_biases);
         desc.AddInput(routes);
         desc.SetAttr("max_nodes", max_nodes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="alpha">Input to the operation. </param>
      ///<param name="l1">Input to the operation. </param>
      ///<param name="l2">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation SparseApplyProximalGradientDescent (  Output var , Output alpha , Output l1 , Output l2 , Output grad , Output indices , bool use_locking = false ,String opName= "SparseApplyProximalGradientDescent" ) 
      {
         OperationDescription desc = NewOperation("SparseApplyProximalGradientDescent", opName);
         desc.AddInput(var);
         desc.AddInput(alpha);
         desc.AddInput(l1);
         desc.AddInput(l2);
         desc.AddInput(grad);
         desc.AddInput(indices);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///  Samples a path for each instance in `input_data` and returns the
      ///</summary>
      ///<param name="input_data">Input to the operation. </param>
      ///<param name="tree_parameters">Input to the operation. </param>
      ///<param name="tree_biases">Input to the operation. </param>
      ///<param name="tree_depth"></param>
      ///<param name="random_seed"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] path_probability(type: DtFloat).
      ///[1] path(type: DtInt32).
      ///</return>
      public Operation StochasticHardRoutingFunction (  Output input_data , Output tree_parameters , Output tree_biases , long tree_depth, long random_seed,String opName= "StochasticHardRoutingFunction" ) 
      {
         OperationDescription desc = NewOperation("StochasticHardRoutingFunction", opName);
         desc.AddInput(input_data);
         desc.AddInput(tree_parameters);
         desc.AddInput(tree_biases);
         desc.SetAttr("tree_depth", tree_depth);
         desc.SetAttr("random_seed", random_seed);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="other_arguments">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      //The following attributes are not known: predicate: func
      public Operation FilterDataset (  Output input_dataset , Output other_arguments , DataType[] output_types, long[][] output_shapes,String opName= "FilterDataset" ) 
      {
         OperationDescription desc = NewOperation("FilterDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(other_arguments);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///Generates skip-gram token and label paired Tensors from the input tensor.
      ///</summary>
      ///<param name="input_tensor">Input to the operation. </param>
      ///<param name="min_skips">Input to the operation. </param>
      ///<param name="max_skips">Input to the operation. </param>
      ///<param name="start">Input to the operation. </param>
      ///<param name="limit">Input to the operation. </param>
      ///<param name="emit_self_as_target">Input to the operation. </param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] tokens(type: DtInvalid).
      ///[1] labels(type: DtInvalid).
      ///</return>
      public Operation SkipGramGenerateCandidates (  Output input_tensor , Output min_skips , Output max_skips , Output start , Output limit , Output emit_self_as_target , long seed = 0 , long seed2 = 0 ,String opName= "SkipGramGenerateCandidates" ) 
      {
         OperationDescription desc = NewOperation("SkipGramGenerateCandidates", opName);
         desc.AddInput(input_tensor);
         desc.AddInput(min_skips);
         desc.AddInput(max_skips);
         desc.AddInput(start);
         desc.AddInput(limit);
         desc.AddInput(emit_self_as_target);

         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="input_min">Input to the operation. </param>
      ///<param name="input_max">Input to the operation. </param>
      ///<param name="num_bits">Input to the operation. </param>
      ///<param name="signed_input"></param>
      ///<param name="range_given"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation QuantizeAndDequantizeV3 (  Output input , Output input_min , Output input_max , Output num_bits , bool signed_input = true , bool range_given = true ,String opName= "QuantizeAndDequantizeV3" ) 
      {
         OperationDescription desc = NewOperation("QuantizeAndDequantizeV3", opName);
         desc.AddInput(input);
         desc.AddInput(input_min);
         desc.AddInput(input_max);
         desc.AddInput(num_bits);

         if (signed_input != true) desc.SetAttr("signed_input", signed_input);
         if (range_given != true) desc.SetAttr("range_given", range_given);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///An Op to sum inputs across replicated TPU instances. Each
      ///</summary>
      ///<param name="input">Input to the operation: The local input to the sum.</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid): The sum of all the distributed inputs.
      ///</return>
      public Operation CrossReplicaSum (  Output input ,String opName= "CrossReplicaSum" ) 
      {
         OperationDescription desc = NewOperation("CrossReplicaSum", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="out_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Size (  Output input , DataType? out_type = null ,String opName= "Size" ) 
      {
         OperationDescription desc = NewOperation("Size", opName);
         desc.AddInput(input);

         if (out_type.HasValue) desc.SetAttr("out_type", out_type.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="token"></param>
      ///<param name="Tout"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation PyFunc (  Output input , string token, DataType[] Tout,String opName= "PyFunc" ) 
      {
         OperationDescription desc = NewOperation("PyFunc", opName);
         desc.AddInput(input);
         desc.SetAttr("token", token);
         desc.SetAttr("Tout", Tout);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="table_handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] size(type: DtInt64).
      ///</return>
      public Operation LookupTableSize (  Output table_handle ,String opName= "LookupTableSize" ) 
      {
         OperationDescription desc = NewOperation("LookupTableSize", opName);
         desc.AddInput(table_handle);


         return desc.FinishOperation();
      } 
      // Skipped function _ShutdownDistributedTPU

      ///<summary>
      ///A placeholder op for a value that will be fed into the computation.
      ///</summary>
      ///<param name="dtype">The type of elements in the tensor.</param>
      ///<param name="shape">The shape of the tensor.</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid): A tensor that will be provided using the infeed mechanism.
      ///</return>
      public Operation InfeedDequeue (  DataType dtype, long[] shape,String opName= "InfeedDequeue" ) 
      {
         OperationDescription desc = NewOperation("InfeedDequeue", opName);

         desc.SetAttr("dtype", dtype);
         desc.SetAttrShape("shape", shape);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reference">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="updates">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_ref(type: DtInvalid).
      ///</return>
      public Operation ScatterAdd (  Output reference , Output indices , Output updates , bool use_locking = false ,String opName= "ScatterAdd" ) 
      {
         OperationDescription desc = NewOperation("ScatterAdd", opName);
         desc.AddInput(reference);
         desc.AddInput(indices);
         desc.AddInput(updates);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtBool).
      ///</return>
      public Operation Less (  Output x , Output y ,String opName= "Less" ) 
      {
         OperationDescription desc = NewOperation("Less", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///An op which feeds a single Tensor value into the computation.
      ///</summary>
      ///<param name="input">Input to the operation: A tensor that will be provided using the infeed mechanism.</param>
      ///<param name="shape">The shape of the tensor.</param>
      ///<param name="device_ordinal">The TPU device to use. This should be -1 when the Op is running on a TPU device, and &gt;= 0 when the Op is running on the CPU device.</param>
      ///<param name="opName">The name of the operation</param>
      public Operation InfeedEnqueue (  Output input , long[] shape = null , long device_ordinal = -1 ,String opName= "InfeedEnqueue" ) 
      {
         OperationDescription desc = NewOperation("InfeedEnqueue", opName);
         desc.AddInput(input);

         if (shape != null) desc.SetAttrShape("shape", shape);
         if (device_ordinal != -1) desc.SetAttr("device_ordinal", device_ordinal);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///An op which feeds multiple Tensor values into the computation as an XLA tuple.
      ///</summary>
      ///<param name="inputs">Input to the operation: A list of tensors that will be provided using the infeed mechanism.</param>
      ///<param name="shapes">The shapes of each tensor in `inputs`.</param>
      ///<param name="device_ordinal">The TPU device to use. This should be -1 when the Op is running on a TPU device, and &gt;= 0 when the Op is running on the CPU device.</param>
      ///<param name="opName">The name of the operation</param>
      public Operation InfeedEnqueueTuple (  Output inputs , long[][] shapes, long device_ordinal = -1 ,String opName= "InfeedEnqueueTuple" ) 
      {
         OperationDescription desc = NewOperation("InfeedEnqueueTuple", opName);
         desc.AddInput(inputs);
         desc.SetAttrShapeList("shapes", shapes);
         if (device_ordinal != -1) desc.SetAttr("device_ordinal", device_ordinal);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///A placeholder op for multiple values that will be fed into the computation
      ///</summary>
      ///<param name="dtypes">The element types of each element in `outputs`.</param>
      ///<param name="shapes">The shapes of each tensor in `outputs`.</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] outputs(type: DtInvalid): A list of tensors that will be provided using the infeed mechanism.
      ///</return>
      public Operation InfeedDequeueTuple (  DataType[] dtypes, long[][] shapes,String opName= "InfeedDequeueTuple" ) 
      {
         OperationDescription desc = NewOperation("InfeedDequeueTuple", opName);

         desc.SetAttr("dtypes", dtypes);
         desc.SetAttrShapeList("shapes", shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="elem_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] elem(type: DtInvalid).
      ///</return>
      public Operation StackPop (  Output handle , DataType elem_type,String opName= "StackPop" ) 
      {
         OperationDescription desc = NewOperation("StackPop", opName);
         desc.AddInput(handle);
         desc.SetAttr("elem_type", elem_type);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="scale">Input to the operation. </param>
      ///<param name="offset">Input to the operation. </param>
      ///<param name="mean">Input to the operation. </param>
      ///<param name="variance">Input to the operation. </param>
      ///<param name="epsilon"></param>
      ///<param name="data_format"></param>
      ///<param name="is_training"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///[1] batch_mean(type: DtInvalid).
      ///[2] batch_variance(type: DtInvalid).
      ///[3] reserve_space_1(type: DtInvalid).
      ///[4] reserve_space_2(type: DtInvalid).
      ///</return>
      public Operation FusedBatchNormV2 (  Output x , Output scale , Output offset , Output mean , Output variance , float epsilon = 0.0001f , string data_format = null , bool is_training = true ,String opName= "FusedBatchNormV2" ) 
      {
         OperationDescription desc = NewOperation("FusedBatchNormV2", opName);
         desc.AddInput(x);
         desc.AddInput(scale);
         desc.AddInput(offset);
         desc.AddInput(mean);
         desc.AddInput(variance);

         if (epsilon != 0.0001f) desc.SetAttr("epsilon", epsilon);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         if (is_training != true) desc.SetAttr("is_training", is_training);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="values">Input to the operation. </param>
      ///<param name="shape"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation ParallelConcat (  Output values , long[] shape,String opName= "ParallelConcat" ) 
      {
         OperationDescription desc = NewOperation("ParallelConcat", opName);
         desc.AddInput(values);
         desc.SetAttrShape("shape", shape);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="parameters">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="axis">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation GatherV2 (  Output parameters , Output indices , Output axis ,String opName= "GatherV2" ) 
      {
         OperationDescription desc = NewOperation("GatherV2", opName);
         desc.AddInput(parameters);
         desc.AddInput(indices);
         desc.AddInput(axis);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///An op which emits a single Tensor value from an XLA computation.
      ///</summary>
      ///<param name="input">Input to the operation: A tensor that will be inserted into the outfeed queue.</param>
      ///<param name="opName">The name of the operation</param>
      public Operation OutfeedEnqueue (  Output input ,String opName= "OutfeedEnqueue" ) 
      {
         OperationDescription desc = NewOperation("OutfeedEnqueue", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="gradients">Input to the operation. </param>
      ///<param name="inputs">Input to the operation. </param>
      ///<param name="min">Input to the operation. </param>
      ///<param name="max">Input to the operation. </param>
      ///<param name="num_bits"></param>
      ///<param name="narrow_range"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] backprops_wrt_input(type: DtFloat).
      ///[1] backprop_wrt_min(type: DtFloat).
      ///[2] backprop_wrt_max(type: DtFloat).
      ///</return>
      public Operation FakeQuantWithMinMaxVarsGradient (  Output gradients , Output inputs , Output min , Output max , long num_bits = 8 , bool narrow_range = false ,String opName= "FakeQuantWithMinMaxVarsGradient" ) 
      {
         OperationDescription desc = NewOperation("FakeQuantWithMinMaxVarsGradient", opName);
         desc.AddInput(gradients);
         desc.AddInput(inputs);
         desc.AddInput(min);
         desc.AddInput(max);

         if (num_bits != 8) desc.SetAttr("num_bits", num_bits);
         if (narrow_range != false) desc.SetAttr("narrow_range", narrow_range);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation BatchCholesky (  Output input ,String opName= "BatchCholesky" ) 
      {
         OperationDescription desc = NewOperation("BatchCholesky", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="split_dim">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="values">Input to the operation. </param>
      ///<param name="shape">Input to the operation. </param>
      ///<param name="num_split"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_indices(type: DtInt64).
      ///[1] output_values(type: DtInvalid).
      ///[2] output_shape(type: DtInt64).
      ///</return>
      public Operation SparseSplit (  Output split_dim , Output indices , Output values , Output shape , long num_split,String opName= "SparseSplit" ) 
      {
         OperationDescription desc = NewOperation("SparseSplit", opName);
         desc.AddInput(split_dim);
         desc.AddInput(indices);
         desc.AddInput(values);
         desc.AddInput(shape);
         desc.SetAttr("num_split", num_split);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///An op which emits multiple Tensor values from an XLA computation.
      ///</summary>
      ///<param name="inputs">Input to the operation: A list of tensors that will be inserted into the outfeed queue as an XLA tuple.</param>
      ///<param name="opName">The name of the operation</param>
      public Operation OutfeedEnqueueTuple (  Output inputs ,String opName= "OutfeedEnqueueTuple" ) 
      {
         OperationDescription desc = NewOperation("OutfeedEnqueueTuple", opName);
         desc.AddInput(inputs);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] reader_handle(type: DtString).
      ///</return>
      public Operation LMDBReader (  string container = null , string shared_name = null ,String opName= "LMDBReader" ) 
      {
         OperationDescription desc = NewOperation("LMDBReader", opName);


         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///Retrieves a single tensor from the computation outfeed.  This operation will
      ///</summary>
      ///<param name="dtype">The type of elements in the tensor.</param>
      ///<param name="shape">The shape of the tensor.</param>
      ///<param name="device_ordinal">The TPU device to use. This should be -1 when the Op is running on a TPU device, and &gt;= 0 when the Op is running on the CPU device.</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid): A tensor that will be read from the device outfeed.
      ///</return>
      public Operation OutfeedDequeue (  DataType dtype, long[] shape, long device_ordinal = -1 ,String opName= "OutfeedDequeue" ) 
      {
         OperationDescription desc = NewOperation("OutfeedDequeue", opName);

         desc.SetAttr("dtype", dtype);
         desc.SetAttrShape("shape", shape);
         if (device_ordinal != -1) desc.SetAttr("device_ordinal", device_ordinal);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///Retrieve multiple values that will be emitted by the computation as an XLA
      ///</summary>
      ///<param name="dtypes">The element types of each element in `outputs`.</param>
      ///<param name="shapes">The shapes of each tensor in `outputs`.</param>
      ///<param name="device_ordinal">The TPU device to use. This should be -1 when the Op is running on a TPU device, and &gt;= 0 when the Op is running on the CPU device.</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] outputs(type: DtInvalid): A list of tensors that will be read from the outfeed.
      ///</return>
      public Operation OutfeedDequeueTuple (  DataType[] dtypes, long[][] shapes, long device_ordinal = -1 ,String opName= "OutfeedDequeueTuple" ) 
      {
         OperationDescription desc = NewOperation("OutfeedDequeueTuple", opName);

         desc.SetAttr("dtypes", dtypes);
         desc.SetAttrShapeList("shapes", shapes);
         if (device_ordinal != -1) desc.SetAttr("device_ordinal", device_ordinal);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtBool).
      ///</return>
      public Operation LoopCond (  Output input ,String opName= "LoopCond" ) 
      {
         OperationDescription desc = NewOperation("LoopCond", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="min_input">Input to the operation. </param>
      ///<param name="max_input">Input to the operation. </param>
      ///<param name="ksize"></param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///[1] min_output(type: DtFloat).
      ///[2] max_output(type: DtFloat).
      ///</return>
      public Operation QuantizedMaxPool (  Output input , Output min_input , Output max_input , long[] ksize, long[] strides, string padding,String opName= "QuantizedMaxPool" ) 
      {
         OperationDescription desc = NewOperation("QuantizedMaxPool", opName);
         desc.AddInput(input);
         desc.AddInput(min_input);
         desc.AddInput(max_input);
         desc.SetAttr("ksize", ksize);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="num_replicas"></param>
      ///<param name="topology"></param>
      ///<param name="device_assignment"></param>
      ///<param name="computation_shape"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation TPUReplicateMetadata (  long num_replicas, string topology = null , long[] device_assignment = null , long[] computation_shape = null ,String opName= "TPUReplicateMetadata" ) 
      {
         OperationDescription desc = NewOperation("TPUReplicateMetadata", opName);

         desc.SetAttr("num_replicas", num_replicas);
         if (topology != null) desc.SetAttr("topology", topology);
         if (device_assignment != null) desc.SetAttr("device_assignment", device_assignment);
         if (computation_shape != null) desc.SetAttr("computation_shape", computation_shape);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation RefNextIteration (  Output data ,String opName= "RefNextIteration" ) 
      {
         OperationDescription desc = NewOperation("RefNextIteration", opName);
         desc.AddInput(data);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///Operator that connects N unreplicated inputs to an N-way replicated TPU computation.
      ///</summary>
      ///<param name="inputs">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation TPUReplicatedInput (  Output inputs ,String opName= "TPUReplicatedInput" ) 
      {
         OperationDescription desc = NewOperation("TPUReplicatedInput", opName);
         desc.AddInput(inputs);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///Operator that connects the output of an N-way replicated TPU computation to N separate outputs.
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="num_replicas"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] outputs(type: DtInvalid).
      ///</return>
      public Operation TPUReplicatedOutput (  Output input , long num_replicas,String opName= "TPUReplicatedOutput" ) 
      {
         OperationDescription desc = NewOperation("TPUReplicatedOutput", opName);
         desc.AddInput(input);
         desc.SetAttr("num_replicas", num_replicas);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///Runs replicated computations on a distributed TPU system.
      ///</summary>
      ///<param name="inputs">Input to the operation: the inputs to 'computation', flattened, in replica-major order.</param>
      ///<param name="broadcast_inputs">Input to the operation: additional arguments to broadcast to all replicas. The broadcast inputs are appended to the per-replica inputs when calling computation.</param>
      ///<param name="variables">Input to the operation. </param>
      ///<param name="guaranteed_constants">Input to the operation: arguments which have been guaranteed to not change their values during the session lifetime. These contain tensors marked as constant using the GuaranteeConstOp.</param>
      ///<param name="num_replicas">the number of replicas of the computation to run.</param>
      ///<param name="output_types">the types of the outputs of 'computation'.</param>
      ///<param name="topology">A serialized tensorflow.tpu.TopologyProto that describes the TPU topology.</param>
      ///<param name="device_assignment">a flattened array with shape [replica] + computation_shape + [mesh_dimension] that maps the coordinates of logical cores in each replica of a computation to physical coordinates in the TPU topology.</param>
      ///<param name="computation_shape">a [mesh_dimension] array describing the shape of each computation replica in numbers of cores in the TPU mesh.</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] outputs(type: DtInvalid): the outputs of 'computation'.
      ///</return>
      //The following attributes are not known: computation: func
      public Operation TPUReplicate (  Output inputs , Output broadcast_inputs , Output variables , Output guaranteed_constants , long num_replicas, DataType[] output_types, string topology = null , long[] device_assignment = null , long[] computation_shape = null ,String opName= "TPUReplicate" ) 
      {
         OperationDescription desc = NewOperation("TPUReplicate", opName);
         desc.AddInput(inputs);
         desc.AddInput(broadcast_inputs);
         desc.AddInput(variables);
         desc.AddInput(guaranteed_constants);
         desc.SetAttr("num_replicas", num_replicas);
         desc.SetAttr("output_types", output_types);
         if (topology != null) desc.SetAttr("topology", topology);
         if (device_assignment != null) desc.SetAttr("device_assignment", device_assignment);
         if (computation_shape != null) desc.SetAttr("computation_shape", computation_shape);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="split_dim">Input to the operation. </param>
      ///<param name="value">Input to the operation. </param>
      ///<param name="num_split"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Split (  Output split_dim , Output value , long num_split,String opName= "Split" ) 
      {
         OperationDescription desc = NewOperation("Split", opName);
         desc.AddInput(split_dim);
         desc.AddInput(value);
         desc.SetAttr("num_split", num_split);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_indices">Input to the operation. </param>
      ///<param name="input_values">Input to the operation. </param>
      ///<param name="input_shape">Input to the operation. </param>
      ///<param name="reduction_axes">Input to the operation. </param>
      ///<param name="keep_dims"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_indices(type: DtInt64).
      ///[1] output_values(type: DtInvalid).
      ///[2] output_shape(type: DtInt64).
      ///</return>
      public Operation SparseReduceSumSparse (  Output input_indices , Output input_values , Output input_shape , Output reduction_axes , bool keep_dims = false ,String opName= "SparseReduceSumSparse" ) 
      {
         OperationDescription desc = NewOperation("SparseReduceSumSparse", opName);
         desc.AddInput(input_indices);
         desc.AddInput(input_values);
         desc.AddInput(input_shape);
         desc.AddInput(reduction_axes);

         if (keep_dims != false) desc.SetAttr("keep_dims", keep_dims);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="opName">The name of the operation</param>
      public Operation ControlTrigger ( String opName= "ControlTrigger" ) 
      {
         OperationDescription desc = NewOperation("ControlTrigger", opName);



         return desc.FinishOperation();
      } 
      // Skipped function _ConfigureDistributedTPU

      ///<summary>
      ///
      ///</summary>
      ///<param name="new_vocab_file">Input to the operation. </param>
      ///<param name="old_vocab_file">Input to the operation. </param>
      ///<param name="new_vocab_offset"></param>
      ///<param name="num_new_vocab"></param>
      ///<param name="old_vocab_size"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] remapping(type: DtInt64).
      ///[1] num_present(type: DtInt32).
      ///</return>
      public Operation GenerateVocabRemapping (  Output new_vocab_file , Output old_vocab_file , long new_vocab_offset, long num_new_vocab, long old_vocab_size = -1 ,String opName= "GenerateVocabRemapping" ) 
      {
         OperationDescription desc = NewOperation("GenerateVocabRemapping", opName);
         desc.AddInput(new_vocab_file);
         desc.AddInput(old_vocab_file);
         desc.SetAttr("new_vocab_offset", new_vocab_offset);
         desc.SetAttr("num_new_vocab", num_new_vocab);
         if (old_vocab_size != -1) desc.SetAttr("old_vocab_size", old_vocab_size);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="window_size"></param>
      ///<param name="stride"></param>
      ///<param name="magnitude_squared"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] spectrogram(type: DtFloat).
      ///</return>
      public Operation AudioSpectrogram (  Output input , long window_size, long stride, bool magnitude_squared = false ,String opName= "AudioSpectrogram" ) 
      {
         OperationDescription desc = NewOperation("AudioSpectrogram", opName);
         desc.AddInput(input);
         desc.SetAttr("window_size", window_size);
         desc.SetAttr("stride", stride);
         if (magnitude_squared != false) desc.SetAttr("magnitude_squared", magnitude_squared);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="window_size">Input to the operation. </param>
      ///<param name="stride">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation SlideDataset (  Output input_dataset , Output window_size , Output stride , DataType[] output_types, long[][] output_shapes,String opName= "SlideDataset" ) 
      {
         OperationDescription desc = NewOperation("SlideDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(window_size);
         desc.AddInput(stride);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 
      // Skipped function _WaitForDistributedTPU
      // Skipped function _SetGlobalTPUArray

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="momentum">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="use_nesterov"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation ApplyMomentum (  Output var , Output accum , Output lr , Output grad , Output momentum , bool use_locking = false , bool use_nesterov = false ,String opName= "ApplyMomentum" ) 
      {
         OperationDescription desc = NewOperation("ApplyMomentum", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(lr);
         desc.AddInput(grad);
         desc.AddInput(momentum);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         if (use_nesterov != false) desc.SetAttr("use_nesterov", use_nesterov);
         return desc.FinishOperation();
      } 
      // Skipped function _InitializeHostForDistributedTPU

      ///<summary>
      ///
      ///</summary>
      ///<param name="gradients">Input to the operation. </param>
      ///<param name="outputs">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] backprops(type: DtInvalid).
      ///</return>
      public Operation EluGrad (  Output gradients , Output outputs ,String opName= "EluGrad" ) 
      {
         OperationDescription desc = NewOperation("EluGrad", opName);
         desc.AddInput(gradients);
         desc.AddInput(outputs);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///An op that sets up the centralized structures for a distributed TPU
      ///</summary>
      ///<param name="embedding_config">Reserved. Do not use.</param>
      ///<param name="tpu_embedding_config">Serialized tensorflow.tpu.TPUEmbeddingConfiguration that describes the embedding lookups of the program.</param>
      ///<param name="is_global_init">Reserved. Do not use.</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] topology(type: DtString): A serialized tensorflow.tpu.TopologyProto that describes the TPU topology.
      ///</return>
      public Operation ConfigureDistributedTPU (  string embedding_config = null , string tpu_embedding_config = null , bool is_global_init = false ,String opName= "ConfigureDistributedTPU" ) 
      {
         OperationDescription desc = NewOperation("ConfigureDistributedTPU", opName);


         if (embedding_config != null) desc.SetAttr("embedding_config", embedding_config);
         if (tpu_embedding_config != null) desc.SetAttr("tpu_embedding_config", tpu_embedding_config);
         if (is_global_init != false) desc.SetAttr("is_global_init", is_global_init);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="elem">Input to the operation. </param>
      ///<param name="swap_memory"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation StackPushV2 (  Output handle , Output elem , bool swap_memory = false ,String opName= "StackPushV2" ) 
      {
         OperationDescription desc = NewOperation("StackPushV2", opName);
         desc.AddInput(handle);
         desc.AddInput(elem);

         if (swap_memory != false) desc.SetAttr("swap_memory", swap_memory);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="elem_type"></param>
      ///<param name="stack_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtString).
      ///</return>
      public Operation Stack (  DataType elem_type, string stack_name = null ,String opName= "Stack" ) 
      {
         OperationDescription desc = NewOperation("Stack", opName);

         desc.SetAttr("elem_type", elem_type);
         if (stack_name != null) desc.SetAttr("stack_name", stack_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="key_func_other_arguments">Input to the operation. </param>
      ///<param name="reduce_func_other_arguments">Input to the operation. </param>
      ///<param name="window_size_func_other_arguments">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      //The following attributes are not known: key_func: func; reduce_func: func; window_size_func: func
      public Operation GroupByWindowDataset (  Output input_dataset , Output key_func_other_arguments , Output reduce_func_other_arguments , Output window_size_func_other_arguments , DataType[] output_types, long[][] output_shapes,String opName= "GroupByWindowDataset" ) 
      {
         OperationDescription desc = NewOperation("GroupByWindowDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(key_func_other_arguments);
         desc.AddInput(reduce_func_other_arguments);
         desc.AddInput(window_size_func_other_arguments);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="input_min">Input to the operation. </param>
      ///<param name="input_max">Input to the operation. </param>
      ///<param name="out_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///[1] output_min(type: DtFloat).
      ///[2] output_max(type: DtFloat).
      ///</return>
      public Operation QuantizeDownAndShrinkRange (  Output input , Output input_min , Output input_max , DataType out_type,String opName= "QuantizeDownAndShrinkRange" ) 
      {
         OperationDescription desc = NewOperation("QuantizeDownAndShrinkRange", opName);
         desc.AddInput(input);
         desc.AddInput(input_min);
         desc.AddInput(input_max);
         desc.SetAttr("out_type", out_type);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///An op that shuts down a running distributed TPU system. The Op returns
      ///</summary>
      ///<param name="opName">The name of the operation</param>
      public Operation ShutdownDistributedTPU ( String opName= "ShutdownDistributedTPU" ) 
      {
         OperationDescription desc = NewOperation("ShutdownDistributedTPU", opName);



         return desc.FinishOperation();
      } 

      ///<summary>
      ///Not for public usage.
      ///</summary>
      ///<param name="fetch_start_timestamp">Input to the operation: any messages earlier than this will be excluded from the returned proto.</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] status(type: DtString).
      ///</return>
      public Operation SessionStatus (  Output fetch_start_timestamp ,String opName= "SessionStatus" ) 
      {
         OperationDescription desc = NewOperation("SessionStatus", opName);
         desc.AddInput(fetch_start_timestamp);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="dtypes"></param>
      ///<param name="capacity"></param>
      ///<param name="memory_limit"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] key(type: DtInt64).
      ///[1] values(type: DtInvalid).
      ///</return>
      public Operation OrderedMapUnstageNoKey (  Output indices , DataType[] dtypes, long capacity = 0 , long memory_limit = 0 , string container = null , string shared_name = null ,String opName= "OrderedMapUnstageNoKey" ) 
      {
         OperationDescription desc = NewOperation("OrderedMapUnstageNoKey", opName);
         desc.AddInput(indices);
         desc.SetAttr("dtypes", dtypes);
         if (capacity != 0) desc.SetAttr("capacity", capacity);
         if (memory_limit != 0) desc.SetAttr("memory_limit", memory_limit);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="value">Input to the operation. </param>
      ///<param name="num"></param>
      ///<param name="axis"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Unpack (  Output value , long num, long axis = 0 ,String opName= "Unpack" ) 
      {
         OperationDescription desc = NewOperation("Unpack", opName);
         desc.AddInput(value);
         desc.SetAttr("num", num);
         if (axis != 0) desc.SetAttr("axis", axis);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="dims">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation UnravelIndex (  Output indices , Output dims ,String opName= "UnravelIndex" ) 
      {
         OperationDescription desc = NewOperation("UnravelIndex", opName);
         desc.AddInput(indices);
         desc.AddInput(dims);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="tag">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation BytesProducedStatsDataset (  Output input_dataset , Output tag , DataType[] output_types, long[][] output_shapes,String opName= "BytesProducedStatsDataset" ) 
      {
         OperationDescription desc = NewOperation("BytesProducedStatsDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(tag);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="concat_dim">Input to the operation. </param>
      ///<param name="values">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Concat (  Output concat_dim , Output values ,String opName= "Concat" ) 
      {
         OperationDescription desc = NewOperation("Concat", opName);
         desc.AddInput(concat_dim);
         desc.AddInput(values);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="values">Input to the operation. </param>
      ///<param name="axis">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation ConcatV2 (  Output values , Output axis ,String opName= "ConcatV2" ) 
      {
         OperationDescription desc = NewOperation("ConcatV2", opName);
         desc.AddInput(values);
         desc.AddInput(axis);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="compression_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] reader_handle(type: DtString).
      ///</return>
      public Operation TFRecordReader (  string container = null , string shared_name = null , string compression_type = null ,String opName= "TFRecordReader" ) 
      {
         OperationDescription desc = NewOperation("TFRecordReader", opName);


         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         if (compression_type != null) desc.SetAttr("compression_type", compression_type);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="concat_dim">Input to the operation. </param>
      ///<param name="shape">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] offset(type: DtInt32).
      ///</return>
      public Operation ConcatOffset (  Output concat_dim , Output shape ,String opName= "ConcatOffset" ) 
      {
         OperationDescription desc = NewOperation("ConcatOffset", opName);
         desc.AddInput(concat_dim);
         desc.AddInput(shape);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="value">Input to the operation. </param>
      ///<param name="size_splits">Input to the operation. </param>
      ///<param name="split_dim">Input to the operation. </param>
      ///<param name="num_split"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SplitV (  Output value , Output size_splits , Output split_dim , long num_split,String opName= "SplitV" ) 
      {
         OperationDescription desc = NewOperation("SplitV", opName);
         desc.AddInput(value);
         desc.AddInput(size_splits);
         desc.AddInput(split_dim);
         desc.SetAttr("num_split", num_split);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="grads">Input to the operation. </param>
      ///<param name="size">Input to the operation. </param>
      ///<param name="align_corners"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation ResizeNearestNeighborGrad (  Output grads , Output size , bool align_corners = false ,String opName= "ResizeNearestNeighborGrad" ) 
      {
         OperationDescription desc = NewOperation("ResizeNearestNeighborGrad", opName);
         desc.AddInput(grads);
         desc.AddInput(size);

         if (align_corners != false) desc.SetAttr("align_corners", align_corners);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="element_shape">Input to the operation. </param>
      ///<param name="element_dtype"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation EmptyTensorList (  Output element_shape , DataType element_dtype,String opName= "EmptyTensorList" ) 
      {
         OperationDescription desc = NewOperation("EmptyTensorList", opName);
         desc.AddInput(element_shape);
         desc.SetAttr("element_dtype", element_dtype);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="ksize"></param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="data_format"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation MaxPool (  Output input , long[] ksize, long[] strides, string padding, string data_format = null ,String opName= "MaxPool" ) 
      {
         OperationDescription desc = NewOperation("MaxPool", opName);
         desc.AddInput(input);
         desc.SetAttr("ksize", ksize);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="value">Input to the operation. </param>
      ///<param name="lengths">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] flow_out(type: DtFloat).
      ///</return>
      public Operation TensorArraySplit (  Output handle , Output value , Output lengths , Output flow_in ,String opName= "TensorArraySplit" ) 
      {
         OperationDescription desc = NewOperation("TensorArraySplit", opName);
         desc.AddInput(handle);
         desc.AddInput(value);
         desc.AddInput(lengths);
         desc.AddInput(flow_in);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation MatrixDeterminant (  Output input ,String opName= "MatrixDeterminant" ) 
      {
         OperationDescription desc = NewOperation("MatrixDeterminant", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="compute_v"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] e(type: DtInvalid).
      ///[1] v(type: DtInvalid).
      ///</return>
      public Operation BatchSelfAdjointEigV2 (  Output input , bool compute_v = true ,String opName= "BatchSelfAdjointEigV2" ) 
      {
         OperationDescription desc = NewOperation("BatchSelfAdjointEigV2", opName);
         desc.AddInput(input);

         if (compute_v != true) desc.SetAttr("compute_v", compute_v);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="resource">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="validate_indices"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation ResourceGather (  Output resource , Output indices , DataType dtype, bool validate_indices = true ,String opName= "ResourceGather" ) 
      {
         OperationDescription desc = NewOperation("ResourceGather", opName);
         desc.AddInput(resource);
         desc.AddInput(indices);
         desc.SetAttr("dtype", dtype);
         if (validate_indices != true) desc.SetAttr("validate_indices", validate_indices);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="dtype"></param>
      ///<param name="shape"></param>
      ///<param name="memory_region_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] tensor(type: DtInvalid).
      ///</return>
      public Operation ImmutableConst (  DataType dtype, long[] shape, string memory_region_name,String opName= "ImmutableConst" ) 
      {
         OperationDescription desc = NewOperation("ImmutableConst", opName);

         desc.SetAttr("dtype", dtype);
         desc.SetAttrShape("shape", shape);
         desc.SetAttr("memory_region_name", memory_region_name);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation ZerosLike (  Output x ,String opName= "ZerosLike" ) 
      {
         OperationDescription desc = NewOperation("ZerosLike", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation OnesLike (  Output x ,String opName= "OnesLike" ) 
      {
         OperationDescription desc = NewOperation("OnesLike", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Rint (  Output x ,String opName= "Rint" ) 
      {
         OperationDescription desc = NewOperation("Rint", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="inputs">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] sum(type: DtInvalid).
      ///</return>
      public Operation AddN (  Output inputs ,String opName= "AddN" ) 
      {
         OperationDescription desc = NewOperation("AddN", opName);
         desc.AddInput(inputs);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="diagonal">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Diag (  Output diagonal ,String opName= "Diag" ) 
      {
         OperationDescription desc = NewOperation("Diag", opName);
         desc.AddInput(diagonal);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="adjoint"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation BatchMatrixInverse (  Output input , bool adjoint = false ,String opName= "BatchMatrixInverse" ) 
      {
         OperationDescription desc = NewOperation("BatchMatrixInverse", opName);
         desc.AddInput(input);

         if (adjoint != false) desc.SetAttr("adjoint", adjoint);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="linear">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="l1">Input to the operation. </param>
      ///<param name="l2">Input to the operation. </param>
      ///<param name="lr_power">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceSparseApplyFtrl (  Output var , Output accum , Output linear , Output grad , Output indices , Output lr , Output l1 , Output l2 , Output lr_power , bool use_locking = false ,String opName= "ResourceSparseApplyFtrl" ) 
      {
         OperationDescription desc = NewOperation("ResourceSparseApplyFtrl", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(linear);
         desc.AddInput(grad);
         desc.AddInput(indices);
         desc.AddInput(lr);
         desc.AddInput(l1);
         desc.AddInput(l2);
         desc.AddInput(lr_power);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation RightShift (  Output x , Output y ,String opName= "RightShift" ) 
      {
         OperationDescription desc = NewOperation("RightShift", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] diagonal(type: DtInvalid).
      ///</return>
      public Operation DiagPart (  Output input ,String opName= "DiagPart" ) 
      {
         OperationDescription desc = NewOperation("DiagPart", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInt32).
      ///</return>
      public Operation Rank (  Output input ,String opName= "Rank" ) 
      {
         OperationDescription desc = NewOperation("Rank", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="values">Input to the operation. </param>
      ///<param name="shapes">Input to the operation. </param>
      ///<param name="dense_inputs">Input to the operation. </param>
      ///<param name="hashed_output"></param>
      ///<param name="num_buckets"></param>
      ///<param name="hash_key"></param>
      ///<param name="out_type"></param>
      ///<param name="internal_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_indices(type: DtInt64).
      ///[1] output_values(type: DtInvalid).
      ///[2] output_shape(type: DtInt64).
      ///</return>
      public Operation SparseCross (  Output indices , Output values , Output shapes , Output dense_inputs , bool hashed_output, long num_buckets, long hash_key, DataType out_type, DataType internal_type,String opName= "SparseCross" ) 
      {
         OperationDescription desc = NewOperation("SparseCross", opName);
         desc.AddInput(indices);
         desc.AddInput(values);
         desc.AddInput(shapes);
         desc.AddInput(dense_inputs);
         desc.SetAttr("hashed_output", hashed_output);
         desc.SetAttr("num_buckets", num_buckets);
         desc.SetAttr("hash_key", hash_key);
         desc.SetAttr("out_type", out_type);
         desc.SetAttr("internal_type", internal_type);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="elem">Input to the operation. </param>
      ///<param name="swap_memory"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation StackPush (  Output handle , Output elem , bool swap_memory = false ,String opName= "StackPush" ) 
      {
         OperationDescription desc = NewOperation("StackPush", opName);
         desc.AddInput(handle);
         desc.AddInput(elem);

         if (swap_memory != false) desc.SetAttr("swap_memory", swap_memory);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="diagonal">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation MatrixSetDiag (  Output input , Output diagonal ,String opName= "MatrixSetDiag" ) 
      {
         OperationDescription desc = NewOperation("MatrixSetDiag", opName);
         desc.AddInput(input);
         desc.AddInput(diagonal);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="key">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="values">Input to the operation. </param>
      ///<param name="dtypes"></param>
      ///<param name="capacity"></param>
      ///<param name="memory_limit"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation OrderedMapStage (  Output key , Output indices , Output values , DataType[] dtypes, long capacity = 0 , long memory_limit = 0 , string container = null , string shared_name = null ,String opName= "OrderedMapStage" ) 
      {
         OperationDescription desc = NewOperation("OrderedMapStage", opName);
         desc.AddInput(key);
         desc.AddInput(indices);
         desc.AddInput(values);
         desc.SetAttr("dtypes", dtypes);
         if (capacity != 0) desc.SetAttr("capacity", capacity);
         if (memory_limit != 0) desc.SetAttr("memory_limit", memory_limit);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] diagonal(type: DtInvalid).
      ///</return>
      public Operation MatrixDiagPart (  Output input ,String opName= "MatrixDiagPart" ) 
      {
         OperationDescription desc = NewOperation("MatrixDiagPart", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="images">Input to the operation. </param>
      ///<param name="size">Input to the operation. </param>
      ///<param name="min">Input to the operation. </param>
      ///<param name="max">Input to the operation. </param>
      ///<param name="align_corners"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] resized_images(type: DtInvalid).
      ///[1] out_min(type: DtFloat).
      ///[2] out_max(type: DtFloat).
      ///</return>
      public Operation QuantizedResizeBilinear (  Output images , Output size , Output min , Output max , bool align_corners = false ,String opName= "QuantizedResizeBilinear" ) 
      {
         OperationDescription desc = NewOperation("QuantizedResizeBilinear", opName);
         desc.AddInput(images);
         desc.AddInput(size);
         desc.AddInput(min);
         desc.AddInput(max);

         if (align_corners != false) desc.SetAttr("align_corners", align_corners);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="num_lower">Input to the operation. </param>
      ///<param name="num_upper">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] band(type: DtInvalid).
      ///</return>
      public Operation MatrixBandPart (  Output input , Output num_lower , Output num_upper ,String opName= "MatrixBandPart" ) 
      {
         OperationDescription desc = NewOperation("MatrixBandPart", opName);
         desc.AddInput(input);
         desc.AddInput(num_lower);
         desc.AddInput(num_upper);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtComplex64).
      ///</return>
      public Operation BatchIFFT3D (  Output input ,String opName= "BatchIFFT3D" ) 
      {
         OperationDescription desc = NewOperation("BatchIFFT3D", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="tensor">Input to the operation. </param>
      ///<param name="dims">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Reverse (  Output tensor , Output dims ,String opName= "Reverse" ) 
      {
         OperationDescription desc = NewOperation("Reverse", opName);
         desc.AddInput(tensor);
         desc.AddInput(dims);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="tensor">Input to the operation. </param>
      ///<param name="axis">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation ReverseV2 (  Output tensor , Output axis ,String opName= "ReverseV2" ) 
      {
         OperationDescription desc = NewOperation("ReverseV2", opName);
         desc.AddInput(tensor);
         desc.AddInput(axis);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="hypothesis_indices">Input to the operation. </param>
      ///<param name="hypothesis_values">Input to the operation. </param>
      ///<param name="hypothesis_shape">Input to the operation. </param>
      ///<param name="truth_indices">Input to the operation. </param>
      ///<param name="truth_values">Input to the operation. </param>
      ///<param name="truth_shape">Input to the operation. </param>
      ///<param name="normalize"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtFloat).
      ///</return>
      public Operation EditDistance (  Output hypothesis_indices , Output hypothesis_values , Output hypothesis_shape , Output truth_indices , Output truth_values , Output truth_shape , bool normalize = true ,String opName= "EditDistance" ) 
      {
         OperationDescription desc = NewOperation("EditDistance", opName);
         desc.AddInput(hypothesis_indices);
         desc.AddInput(hypothesis_values);
         desc.AddInput(hypothesis_shape);
         desc.AddInput(truth_indices);
         desc.AddInput(truth_values);
         desc.AddInput(truth_shape);

         if (normalize != true) desc.SetAttr("normalize", normalize);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///Writes a `Summary` protocol buffer with scalar values.
      ///</summary>
      ///<param name="writer">Input to the operation: A handle to a summary writer.</param>
      ///<param name="step">Input to the operation: The step to write the summary for.</param>
      ///<param name="tag">Input to the operation: Tag for the summary.</param>
      ///<param name="value">Input to the operation: Value for the summary.</param>
      ///<param name="opName">The name of the operation</param>
      public Operation WriteScalarSummary (  Output writer , Output step , Output tag , Output value ,String opName= "WriteScalarSummary" ) 
      {
         OperationDescription desc = NewOperation("WriteScalarSummary", opName);
         desc.AddInput(writer);
         desc.AddInput(step);
         desc.AddInput(tag);
         desc.AddInput(value);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="sp_indices">Input to the operation. </param>
      ///<param name="sp_values">Input to the operation. </param>
      ///<param name="sp_shape">Input to the operation. </param>
      ///<param name="dense">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SparseDenseCwiseAdd (  Output sp_indices , Output sp_values , Output sp_shape , Output dense ,String opName= "SparseDenseCwiseAdd" ) 
      {
         OperationDescription desc = NewOperation("SparseDenseCwiseAdd", opName);
         desc.AddInput(sp_indices);
         desc.AddInput(sp_values);
         desc.AddInput(sp_shape);
         desc.AddInput(dense);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="filter">Input to the operation. </param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="data_format"></param>
      ///<param name="dilations"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Conv3D (  Output input , Output filter , long[] strides, string padding, string data_format = null , long[] dilations = null ,String opName= "Conv3D" ) 
      {
         OperationDescription desc = NewOperation("Conv3D", opName);
         desc.AddInput(input);
         desc.AddInput(filter);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         if (dilations != null) desc.SetAttr("dilations", dilations);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation Div (  Output x , Output y ,String opName= "Div" ) 
      {
         OperationDescription desc = NewOperation("Div", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="dims">Input to the operation. </param>
      ///<param name="value">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Fill (  Output dims , Output value ,String opName= "Fill" ) 
      {
         OperationDescription desc = NewOperation("Fill", opName);
         desc.AddInput(dims);
         desc.AddInput(value);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_handle">Input to the operation. </param>
      ///<param name="index">Input to the operation. </param>
      ///<param name="item">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_handle(type: DtVariant).
      ///</return>
      public Operation TensorListSetItem (  Output input_handle , Output index , Output item ,String opName= "TensorListSetItem" ) 
      {
         OperationDescription desc = NewOperation("TensorListSetItem", opName);
         desc.AddInput(input_handle);
         desc.AddInput(index);
         desc.AddInput(item);


         return desc.FinishOperation();
      } 
      // Skipped function _ParallelConcatStart

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Identity (  Output input ,String opName= "Identity" ) 
      {
         OperationDescription desc = NewOperation("Identity", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] diagonal(type: DtInvalid).
      ///</return>
      public Operation BatchMatrixDiagPart (  Output input ,String opName= "BatchMatrixDiagPart" ) 
      {
         OperationDescription desc = NewOperation("BatchMatrixDiagPart", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 
      // Skipped function _ParallelConcatUpdate

      ///<summary>
      ///
      ///</summary>
      ///<param name="parameters">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation GatherNd (  Output parameters , Output indices ,String opName= "GatherNd" ) 
      {
         OperationDescription desc = NewOperation("GatherNd", opName);
         desc.AddInput(parameters);
         desc.AddInput(indices);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="value">Input to the operation. </param>
      ///<param name="lengths">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] flow_out(type: DtFloat).
      ///</return>
      public Operation TensorArraySplitV3 (  Output handle , Output value , Output lengths , Output flow_in ,String opName= "TensorArraySplitV3" ) 
      {
         OperationDescription desc = NewOperation("TensorArraySplitV3", opName);
         desc.AddInput(handle);
         desc.AddInput(value);
         desc.AddInput(lengths);
         desc.AddInput(flow_in);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Snapshot (  Output input ,String opName= "Snapshot" ) 
      {
         OperationDescription desc = NewOperation("Snapshot", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation IdentityN (  Output input ,String opName= "IdentityN" ) 
      {
         OperationDescription desc = NewOperation("IdentityN", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation RefIdentity (  Output input ,String opName= "RefIdentity" ) 
      {
         OperationDescription desc = NewOperation("RefIdentity", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation DebugGradientIdentity (  Output input ,String opName= "DebugGradientIdentity" ) 
      {
         OperationDescription desc = NewOperation("DebugGradientIdentity", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="dim">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation ExpandDims (  Output input , Output dim ,String opName= "ExpandDims" ) 
      {
         OperationDescription desc = NewOperation("ExpandDims", opName);
         desc.AddInput(input);
         desc.AddInput(dim);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation DebugGradientRefIdentity (  Output input ,String opName= "DebugGradientRefIdentity" ) 
      {
         OperationDescription desc = NewOperation("DebugGradientRefIdentity", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="alpha">Input to the operation. </param>
      ///<param name="l1">Input to the operation. </param>
      ///<param name="l2">Input to the operation. </param>
      ///<param name="delta">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation ApplyProximalGradientDescent (  Output var , Output alpha , Output l1 , Output l2 , Output delta , bool use_locking = false ,String opName= "ApplyProximalGradientDescent" ) 
      {
         OperationDescription desc = NewOperation("ApplyProximalGradientDescent", opName);
         desc.AddInput(var);
         desc.AddInput(alpha);
         desc.AddInput(l1);
         desc.AddInput(l2);
         desc.AddInput(delta);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="serialized">Input to the operation. </param>
      ///<param name="out_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation ParseTensor (  Output serialized , DataType out_type,String opName= "ParseTensor" ) 
      {
         OperationDescription desc = NewOperation("ParseTensor", opName);
         desc.AddInput(serialized);
         desc.SetAttr("out_type", out_type);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="message"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation PreventGradient (  Output input , string message = null ,String opName= "PreventGradient" ) 
      {
         OperationDescription desc = NewOperation("PreventGradient", opName);
         desc.AddInput(input);

         if (message != null) desc.SetAttr("message", message);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="tolerance"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtBool).
      ///</return>
      public Operation ApproximateEqual (  Output x , Output y , float tolerance = 1E-05f ,String opName= "ApproximateEqual" ) 
      {
         OperationDescription desc = NewOperation("ApproximateEqual", opName);
         desc.AddInput(x);
         desc.AddInput(y);

         if (tolerance != 1E-05f) desc.SetAttr("tolerance", tolerance);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="shape"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation PlaceholderWithDefault (  Output input , long[] shape,String opName= "PlaceholderWithDefault" ) 
      {
         OperationDescription desc = NewOperation("PlaceholderWithDefault", opName);
         desc.AddInput(input);
         desc.SetAttrShape("shape", shape);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="true_classes">Input to the operation. </param>
      ///<param name="num_true"></param>
      ///<param name="num_sampled"></param>
      ///<param name="unique"></param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] sampled_candidates(type: DtInt64).
      ///[1] true_expected_count(type: DtFloat).
      ///[2] sampled_expected_count(type: DtFloat).
      ///</return>
      public Operation AllCandidateSampler (  Output true_classes , long num_true, long num_sampled, bool unique, long seed = 0 , long seed2 = 0 ,String opName= "AllCandidateSampler" ) 
      {
         OperationDescription desc = NewOperation("AllCandidateSampler", opName);
         desc.AddInput(true_classes);
         desc.SetAttr("num_true", num_true);
         desc.SetAttr("num_sampled", num_sampled);
         desc.SetAttr("unique", unique);
         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation FloorMod (  Output x , Output y ,String opName= "FloorMod" ) 
      {
         OperationDescription desc = NewOperation("FloorMod", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Sigmoid (  Output x ,String opName= "Sigmoid" ) 
      {
         OperationDescription desc = NewOperation("Sigmoid", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="tags">Input to the operation. </param>
      ///<param name="values">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] summary(type: DtString).
      ///</return>
      public Operation ScalarSummary (  Output tags , Output values ,String opName= "ScalarSummary" ) 
      {
         OperationDescription desc = NewOperation("ScalarSummary", opName);
         desc.AddInput(tags);
         desc.AddInput(values);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="tensor">Input to the operation. </param>
      ///<param name="message"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation CheckNumerics (  Output tensor , string message,String opName= "CheckNumerics" ) 
      {
         OperationDescription desc = NewOperation("CheckNumerics", opName);
         desc.AddInput(tensor);
         desc.SetAttr("message", message);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="tensor">Input to the operation. </param>
      ///<param name="shape">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Reshape (  Output tensor , Output shape ,String opName= "Reshape" ) 
      {
         OperationDescription desc = NewOperation("Reshape", opName);
         desc.AddInput(tensor);
         desc.AddInput(shape);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation InvertPermutation (  Output x ,String opName= "InvertPermutation" ) 
      {
         OperationDescription desc = NewOperation("InvertPermutation", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation MatrixLogarithm (  Output input ,String opName= "MatrixLogarithm" ) 
      {
         OperationDescription desc = NewOperation("MatrixLogarithm", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reference">Input to the operation. </param>
      ///<param name="begin">Input to the operation. </param>
      ///<param name="end">Input to the operation. </param>
      ///<param name="strides">Input to the operation. </param>
      ///<param name="value">Input to the operation. </param>
      ///<param name="begin_mask"></param>
      ///<param name="end_mask"></param>
      ///<param name="ellipsis_mask"></param>
      ///<param name="new_axis_mask"></param>
      ///<param name="shrink_axis_mask"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceStridedSliceAssign (  Output reference , Output begin , Output end , Output strides , Output value , long begin_mask = 0 , long end_mask = 0 , long ellipsis_mask = 0 , long new_axis_mask = 0 , long shrink_axis_mask = 0 ,String opName= "ResourceStridedSliceAssign" ) 
      {
         OperationDescription desc = NewOperation("ResourceStridedSliceAssign", opName);
         desc.AddInput(reference);
         desc.AddInput(begin);
         desc.AddInput(end);
         desc.AddInput(strides);
         desc.AddInput(value);

         if (begin_mask != 0) desc.SetAttr("begin_mask", begin_mask);
         if (end_mask != 0) desc.SetAttr("end_mask", end_mask);
         if (ellipsis_mask != 0) desc.SetAttr("ellipsis_mask", ellipsis_mask);
         if (new_axis_mask != 0) desc.SetAttr("new_axis_mask", new_axis_mask);
         if (shrink_axis_mask != 0) desc.SetAttr("shrink_axis_mask", shrink_axis_mask);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="perm">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Transpose (  Output x , Output perm ,String opName= "Transpose" ) 
      {
         OperationDescription desc = NewOperation("Transpose", opName);
         desc.AddInput(x);
         desc.AddInput(perm);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="component_types"></param>
      ///<param name="shapes"></param>
      ///<param name="capacity"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtString).
      ///</return>
      public Operation Barrier (  DataType[] component_types, long[][] shapes = null , long capacity = -1 , string container = null , string shared_name = null ,String opName= "Barrier" ) 
      {
         OperationDescription desc = NewOperation("Barrier", opName);

         desc.SetAttr("component_types", component_types);
         if (shapes != null) desc.SetAttrShapeList("shapes", shapes);
         if (capacity != -1) desc.SetAttr("capacity", capacity);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="perm">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation ConjugateTranspose (  Output x , Output perm ,String opName= "ConjugateTranspose" ) 
      {
         OperationDescription desc = NewOperation("ConjugateTranspose", opName);
         desc.AddInput(x);
         desc.AddInput(perm);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="out_idx"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///[1] idx(type: DtInvalid).
      ///</return>
      public Operation Unique (  Output x , DataType? out_idx = null ,String opName= "Unique" ) 
      {
         OperationDescription desc = NewOperation("Unique", opName);
         desc.AddInput(x);

         if (out_idx.HasValue) desc.SetAttr("out_idx", out_idx.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="count">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation TakeDataset (  Output input_dataset , Output count , DataType[] output_types, long[][] output_shapes,String opName= "TakeDataset" ) 
      {
         OperationDescription desc = NewOperation("TakeDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(count);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="out_idx"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///[1] idx(type: DtInvalid).
      ///[2] count(type: DtInvalid).
      ///</return>
      public Operation UniqueWithCounts (  Output x , DataType? out_idx = null ,String opName= "UniqueWithCounts" ) 
      {
         OperationDescription desc = NewOperation("UniqueWithCounts", opName);
         desc.AddInput(x);

         if (out_idx.HasValue) desc.SetAttr("out_idx", out_idx.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="axis">Input to the operation. </param>
      ///<param name="out_idx"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///[1] idx(type: DtInvalid).
      ///[2] count(type: DtInvalid).
      ///</return>
      public Operation UniqueWithCountsV2 (  Output x , Output axis , DataType? out_idx = null ,String opName= "UniqueWithCountsV2" ) 
      {
         OperationDescription desc = NewOperation("UniqueWithCountsV2", opName);
         desc.AddInput(x);
         desc.AddInput(axis);

         if (out_idx.HasValue) desc.SetAttr("out_idx", out_idx.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="images">Input to the operation. </param>
      ///<param name="scale">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtFloat).
      ///</return>
      public Operation AdjustSaturation (  Output images , Output scale ,String opName= "AdjustSaturation" ) 
      {
         OperationDescription desc = NewOperation("AdjustSaturation", opName);
         desc.AddInput(images);
         desc.AddInput(scale);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="out_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation VariableShape (  Output input , DataType? out_type = null ,String opName= "VariableShape" ) 
      {
         OperationDescription desc = NewOperation("VariableShape", opName);
         desc.AddInput(input);

         if (out_type.HasValue) desc.SetAttr("out_type", out_type.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="data">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] merged(type: DtInvalid).
      ///</return>
      public Operation ParallelDynamicStitch (  Output indices , Output data ,String opName= "ParallelDynamicStitch" ) 
      {
         OperationDescription desc = NewOperation("ParallelDynamicStitch", opName);
         desc.AddInput(indices);
         desc.AddInput(data);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="out_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Shape (  Output input , DataType? out_type = null ,String opName= "Shape" ) 
      {
         OperationDescription desc = NewOperation("Shape", opName);
         desc.AddInput(input);

         if (out_type.HasValue) desc.SetAttr("out_type", out_type.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="begin">Input to the operation. </param>
      ///<param name="size">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Slice (  Output input , Output begin , Output size ,String opName= "Slice" ) 
      {
         OperationDescription desc = NewOperation("Slice", opName);
         desc.AddInput(input);
         desc.AddInput(begin);
         desc.AddInput(size);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="boxes">Input to the operation. </param>
      ///<param name="scores">Input to the operation. </param>
      ///<param name="max_output_size">Input to the operation. </param>
      ///<param name="iou_threshold">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] selected_indices(type: DtInt32).
      ///</return>
      public Operation NonMaxSuppressionV2 (  Output boxes , Output scores , Output max_output_size , Output iou_threshold ,String opName= "NonMaxSuppressionV2" ) 
      {
         OperationDescription desc = NewOperation("NonMaxSuppressionV2", opName);
         desc.AddInput(boxes);
         desc.AddInput(scores);
         desc.AddInput(max_output_size);
         desc.AddInput(iou_threshold);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="orig_input_shape">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="ksize"></param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="data_format"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation AvgPool3DGrad (  Output orig_input_shape , Output grad , long[] ksize, long[] strides, string padding, string data_format = null ,String opName= "AvgPool3DGrad" ) 
      {
         OperationDescription desc = NewOperation("AvgPool3DGrad", opName);
         desc.AddInput(orig_input_shape);
         desc.AddInput(grad);
         desc.SetAttr("ksize", ksize);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="begin">Input to the operation. </param>
      ///<param name="end">Input to the operation. </param>
      ///<param name="strides">Input to the operation. </param>
      ///<param name="begin_mask"></param>
      ///<param name="end_mask"></param>
      ///<param name="ellipsis_mask"></param>
      ///<param name="new_axis_mask"></param>
      ///<param name="shrink_axis_mask"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation StridedSlice (  Output input , Output begin , Output end , Output strides , long begin_mask = 0 , long end_mask = 0 , long ellipsis_mask = 0 , long new_axis_mask = 0 , long shrink_axis_mask = 0 ,String opName= "StridedSlice" ) 
      {
         OperationDescription desc = NewOperation("StridedSlice", opName);
         desc.AddInput(input);
         desc.AddInput(begin);
         desc.AddInput(end);
         desc.AddInput(strides);

         if (begin_mask != 0) desc.SetAttr("begin_mask", begin_mask);
         if (end_mask != 0) desc.SetAttr("end_mask", end_mask);
         if (ellipsis_mask != 0) desc.SetAttr("ellipsis_mask", ellipsis_mask);
         if (new_axis_mask != 0) desc.SetAttr("new_axis_mask", new_axis_mask);
         if (shrink_axis_mask != 0) desc.SetAttr("shrink_axis_mask", shrink_axis_mask);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reader_handle">Input to the operation. </param>
      ///<param name="queue_handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] key(type: DtString).
      ///[1] value(type: DtString).
      ///</return>
      public Operation ReaderReadV2 (  Output reader_handle , Output queue_handle ,String opName= "ReaderReadV2" ) 
      {
         OperationDescription desc = NewOperation("ReaderReadV2", opName);
         desc.AddInput(reader_handle);
         desc.AddInput(queue_handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation TensorArrayClose (  Output handle ,String opName= "TensorArrayClose" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayClose", opName);
         desc.AddInput(handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="reduction_indices">Input to the operation. </param>
      ///<param name="keep_dims"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Min (  Output input , Output reduction_indices , bool keep_dims = false ,String opName= "Min" ) 
      {
         OperationDescription desc = NewOperation("Min", opName);
         desc.AddInput(input);
         desc.AddInput(reduction_indices);

         if (keep_dims != false) desc.SetAttr("keep_dims", keep_dims);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reference">Input to the operation. </param>
      ///<param name="begin">Input to the operation. </param>
      ///<param name="end">Input to the operation. </param>
      ///<param name="strides">Input to the operation. </param>
      ///<param name="value">Input to the operation. </param>
      ///<param name="begin_mask"></param>
      ///<param name="end_mask"></param>
      ///<param name="ellipsis_mask"></param>
      ///<param name="new_axis_mask"></param>
      ///<param name="shrink_axis_mask"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_ref(type: DtInvalid).
      ///</return>
      public Operation StridedSliceAssign (  Output reference , Output begin , Output end , Output strides , Output value , long begin_mask = 0 , long end_mask = 0 , long ellipsis_mask = 0 , long new_axis_mask = 0 , long shrink_axis_mask = 0 ,String opName= "StridedSliceAssign" ) 
      {
         OperationDescription desc = NewOperation("StridedSliceAssign", opName);
         desc.AddInput(reference);
         desc.AddInput(begin);
         desc.AddInput(end);
         desc.AddInput(strides);
         desc.AddInput(value);

         if (begin_mask != 0) desc.SetAttr("begin_mask", begin_mask);
         if (end_mask != 0) desc.SetAttr("end_mask", end_mask);
         if (ellipsis_mask != 0) desc.SetAttr("ellipsis_mask", ellipsis_mask);
         if (new_axis_mask != 0) desc.SetAttr("new_axis_mask", new_axis_mask);
         if (shrink_axis_mask != 0) desc.SetAttr("shrink_axis_mask", shrink_axis_mask);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="resource">Input to the operation. </param>
      ///<param name="value">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation AssignSubVariableOp (  Output resource , Output value ,String opName= "AssignSubVariableOp" ) 
      {
         OperationDescription desc = NewOperation("AssignSubVariableOp", opName);
         desc.AddInput(resource);
         desc.AddInput(value);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reader_handle">Input to the operation. </param>
      ///<param name="state">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation ReaderRestoreStateV2 (  Output reader_handle , Output state ,String opName= "ReaderRestoreStateV2" ) 
      {
         OperationDescription desc = NewOperation("ReaderRestoreStateV2", opName);
         desc.AddInput(reader_handle);
         desc.AddInput(state);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="multiples">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation TileGrad (  Output input , Output multiples ,String opName= "TileGrad" ) 
      {
         OperationDescription desc = NewOperation("TileGrad", opName);
         desc.AddInput(input);
         desc.AddInput(multiples);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] index(type: DtInt64).
      ///</return>
      public Operation Where (  Output input ,String opName= "Where" ) 
      {
         OperationDescription desc = NewOperation("Where", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="paddings">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Pad (  Output input , Output paddings ,String opName= "Pad" ) 
      {
         OperationDescription desc = NewOperation("Pad", opName);
         desc.AddInput(input);
         desc.AddInput(paddings);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="paddings">Input to the operation. </param>
      ///<param name="constant_values">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation PadV2 (  Output input , Output paddings , Output constant_values ,String opName= "PadV2" ) 
      {
         OperationDescription desc = NewOperation("PadV2", opName);
         desc.AddInput(input);
         desc.AddInput(paddings);
         desc.AddInput(constant_values);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="record_bytes"></param>
      ///<param name="header_bytes"></param>
      ///<param name="footer_bytes"></param>
      ///<param name="hop_bytes"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] reader_handle(type: DtString).
      ///</return>
      public Operation FixedLengthRecordReader (  long record_bytes, long header_bytes = 0 , long footer_bytes = 0 , long hop_bytes = 0 , string container = null , string shared_name = null ,String opName= "FixedLengthRecordReader" ) 
      {
         OperationDescription desc = NewOperation("FixedLengthRecordReader", opName);

         desc.SetAttr("record_bytes", record_bytes);
         if (header_bytes != 0) desc.SetAttr("header_bytes", header_bytes);
         if (footer_bytes != 0) desc.SetAttr("footer_bytes", footer_bytes);
         if (hop_bytes != 0) desc.SetAttr("hop_bytes", hop_bytes);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="paddings">Input to the operation. </param>
      ///<param name="mode"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation MirrorPad (  Output input , Output paddings , string mode,String opName= "MirrorPad" ) 
      {
         OperationDescription desc = NewOperation("MirrorPad", opName);
         desc.AddInput(input);
         desc.AddInput(paddings);
         desc.SetAttr("mode", mode);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="paddings">Input to the operation. </param>
      ///<param name="mode"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation MirrorPadGrad (  Output input , Output paddings , string mode,String opName= "MirrorPadGrad" ) 
      {
         OperationDescription desc = NewOperation("MirrorPadGrad", opName);
         desc.AddInput(input);
         desc.AddInput(paddings);
         desc.SetAttr("mode", mode);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="resource_handle">Input to the operation. </param>
      ///<param name="serialized">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation DeserializeIterator (  Output resource_handle , Output serialized ,String opName= "DeserializeIterator" ) 
      {
         OperationDescription desc = NewOperation("DeserializeIterator", opName);
         desc.AddInput(resource_handle);
         desc.AddInput(serialized);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="dtype"></param>
      ///<param name="shape"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Placeholder (  DataType dtype, long[] shape = null ,String opName= "Placeholder" ) 
      {
         OperationDescription desc = NewOperation("Placeholder", opName);

         desc.SetAttr("dtype", dtype);
         if (shape != null) desc.SetAttrShape("shape", shape);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtComplex64).
      ///</return>
      public Operation BatchIFFT (  Output input ,String opName= "BatchIFFT" ) 
      {
         OperationDescription desc = NewOperation("BatchIFFT", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="init_func_other_args">Input to the operation. </param>
      ///<param name="next_func_other_args">Input to the operation. </param>
      ///<param name="finalize_func_other_args">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      //The following attributes are not known: init_func: func; next_func: func; finalize_func: func
      public Operation GeneratorDataset (  Output init_func_other_args , Output next_func_other_args , Output finalize_func_other_args , DataType[] output_types, long[][] output_shapes,String opName= "GeneratorDataset" ) 
      {
         OperationDescription desc = NewOperation("GeneratorDataset", opName);
         desc.AddInput(init_func_other_args);
         desc.AddInput(next_func_other_args);
         desc.AddInput(finalize_func_other_args);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="dtype"></param>
      ///<param name="shape"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation PlaceholderV2 (  DataType dtype, long[] shape,String opName= "PlaceholderV2" ) 
      {
         OperationDescription desc = NewOperation("PlaceholderV2", opName);

         desc.SetAttr("dtype", dtype);
         desc.SetAttrShape("shape", shape);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="shift">Input to the operation. </param>
      ///<param name="axis">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Roll (  Output input , Output shift , Output axis ,String opName= "Roll" ) 
      {
         OperationDescription desc = NewOperation("Roll", opName);
         desc.AddInput(input);
         desc.AddInput(shift);
         desc.AddInput(axis);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="other_arguments">Input to the operation. </param>
      ///<param name="batch_size">Input to the operation. </param>
      ///<param name="num_parallel_batches">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      //The following attributes are not known: f: func
      public Operation MapAndBatchDataset (  Output input_dataset , Output other_arguments , Output batch_size , Output num_parallel_batches , DataType[] output_types, long[][] output_shapes,String opName= "MapAndBatchDataset" ) 
      {
         OperationDescription desc = NewOperation("MapAndBatchDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(other_arguments);
         desc.AddInput(batch_size);
         desc.AddInput(num_parallel_batches);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="out_idx"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///[1] idx(type: DtInvalid).
      ///</return>
      public Operation ListDiff (  Output x , Output y , DataType? out_idx = null ,String opName= "ListDiff" ) 
      {
         OperationDescription desc = NewOperation("ListDiff", opName);
         desc.AddInput(x);
         desc.AddInput(y);

         if (out_idx.HasValue) desc.SetAttr("out_idx", out_idx.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="component_types"></param>
      ///<param name="shapes"></param>
      ///<param name="capacity"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtString).
      ///</return>
      public Operation FIFOQueue (  DataType[] component_types, long[][] shapes = null , long capacity = -1 , string container = null , string shared_name = null ,String opName= "FIFOQueue" ) 
      {
         OperationDescription desc = NewOperation("FIFOQueue", opName);

         desc.SetAttr("component_types", component_types);
         if (shapes != null) desc.SetAttrShapeList("shapes", shapes);
         if (capacity != -1) desc.SetAttr("capacity", capacity);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="matrix">Input to the operation. </param>
      ///<param name="rhs">Input to the operation. </param>
      ///<param name="l2_regularizer">Input to the operation. </param>
      ///<param name="fast"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation MatrixSolveLs (  Output matrix , Output rhs , Output l2_regularizer , bool fast = true ,String opName= "MatrixSolveLs" ) 
      {
         OperationDescription desc = NewOperation("MatrixSolveLs", opName);
         desc.AddInput(matrix);
         desc.AddInput(rhs);
         desc.AddInput(l2_regularizer);

         if (fast != true) desc.SetAttr("fast", fast);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="tag">Input to the operation. </param>
      ///<param name="tensor">Input to the operation. </param>
      ///<param name="max_images"></param>
      ///<param name="bad_color"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] summary(type: DtString).
      ///</return>
      public Operation ImageSummary (  Output tag , Output tensor , long max_images = 3 , Tensor bad_color = null ,String opName= "ImageSummary" ) 
      {
         OperationDescription desc = NewOperation("ImageSummary", opName);
         desc.AddInput(tag);
         desc.AddInput(tensor);

         if (max_images != 3) desc.SetAttr("max_images", max_images);
         if (bad_color != null) desc.SetAttr("bad_color", bad_color);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="block_shape">Input to the operation. </param>
      ///<param name="paddings">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SpaceToBatchND (  Output input , Output block_shape , Output paddings ,String opName= "SpaceToBatchND" ) 
      {
         OperationDescription desc = NewOperation("SpaceToBatchND", opName);
         desc.AddInput(input);
         desc.AddInput(block_shape);
         desc.AddInput(paddings);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="new_global_step">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation AccumulatorSetGlobalStep (  Output handle , Output new_global_step ,String opName= "AccumulatorSetGlobalStep" ) 
      {
         OperationDescription desc = NewOperation("AccumulatorSetGlobalStep", opName);
         desc.AddInput(handle);
         desc.AddInput(new_global_step);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="checkpoint_prefixes">Input to the operation. </param>
      ///<param name="destination_prefix">Input to the operation. </param>
      ///<param name="delete_old_dirs"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation MergeV2Checkpoints (  Output checkpoint_prefixes , Output destination_prefix , bool delete_old_dirs = true ,String opName= "MergeV2Checkpoints" ) 
      {
         OperationDescription desc = NewOperation("MergeV2Checkpoints", opName);
         desc.AddInput(checkpoint_prefixes);
         desc.AddInput(destination_prefix);

         if (delete_old_dirs != true) desc.SetAttr("delete_old_dirs", delete_old_dirs);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="paddings">Input to the operation. </param>
      ///<param name="block_size"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SpaceToBatch (  Output input , Output paddings , long block_size,String opName= "SpaceToBatch" ) 
      {
         OperationDescription desc = NewOperation("SpaceToBatch", opName);
         desc.AddInput(input);
         desc.AddInput(paddings);
         desc.SetAttr("block_size", block_size);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="shapes"></param>
      ///<param name="component_types"></param>
      ///<param name="capacity"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtResource).
      ///</return>
      public Operation PriorityQueueV2 (  long[][] shapes, DataType[] component_types = null , long capacity = -1 , string container = null , string shared_name = null ,String opName= "PriorityQueueV2" ) 
      {
         OperationDescription desc = NewOperation("PriorityQueueV2", opName);

         desc.SetAttrShapeList("shapes", shapes);
         if (component_types != null) desc.SetAttr("component_types", component_types);
         if (capacity != -1) desc.SetAttr("capacity", capacity);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="other_arguments">Input to the operation. </param>
      ///<param name="cycle_length">Input to the operation. </param>
      ///<param name="block_length">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      //The following attributes are not known: f: func
      public Operation InterleaveDataset (  Output input_dataset , Output other_arguments , Output cycle_length , Output block_length , DataType[] output_types, long[][] output_shapes,String opName= "InterleaveDataset" ) 
      {
         OperationDescription desc = NewOperation("InterleaveDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(other_arguments);
         desc.AddInput(cycle_length);
         desc.AddInput(block_length);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="block_shape">Input to the operation. </param>
      ///<param name="crops">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation BatchToSpaceND (  Output input , Output block_shape , Output crops ,String opName= "BatchToSpaceND" ) 
      {
         OperationDescription desc = NewOperation("BatchToSpaceND", opName);
         desc.AddInput(input);
         desc.AddInput(block_shape);
         desc.AddInput(crops);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="m">Input to the operation. </param>
      ///<param name="v">Input to the operation. </param>
      ///<param name="beta1_power">Input to the operation. </param>
      ///<param name="beta2_power">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="beta1">Input to the operation. </param>
      ///<param name="beta2">Input to the operation. </param>
      ///<param name="epsilon">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="use_nesterov"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceApplyAdam (  Output var , Output m , Output v , Output beta1_power , Output beta2_power , Output lr , Output beta1 , Output beta2 , Output epsilon , Output grad , bool use_locking = false , bool use_nesterov = false ,String opName= "ResourceApplyAdam" ) 
      {
         OperationDescription desc = NewOperation("ResourceApplyAdam", opName);
         desc.AddInput(var);
         desc.AddInput(m);
         desc.AddInput(v);
         desc.AddInput(beta1_power);
         desc.AddInput(beta2_power);
         desc.AddInput(lr);
         desc.AddInput(beta1);
         desc.AddInput(beta2);
         desc.AddInput(epsilon);
         desc.AddInput(grad);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         if (use_nesterov != false) desc.SetAttr("use_nesterov", use_nesterov);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="crops">Input to the operation. </param>
      ///<param name="block_size"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation BatchToSpace (  Output input , Output crops , long block_size,String opName= "BatchToSpace" ) 
      {
         OperationDescription desc = NewOperation("BatchToSpace", opName);
         desc.AddInput(input);
         desc.AddInput(crops);
         desc.SetAttr("block_size", block_size);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="index">Input to the operation. </param>
      ///<param name="value">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] flow_out(type: DtFloat).
      ///</return>
      public Operation TensorArrayWriteV2 (  Output handle , Output index , Output value , Output flow_in ,String opName= "TensorArrayWriteV2" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayWriteV2", opName);
         desc.AddInput(handle);
         desc.AddInput(index);
         desc.AddInput(value);
         desc.AddInput(flow_in);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="block_size"></param>
      ///<param name="data_format"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SpaceToDepth (  Output input , long block_size, string data_format = null ,String opName= "SpaceToDepth" ) 
      {
         OperationDescription desc = NewOperation("SpaceToDepth", opName);
         desc.AddInput(input);
         desc.SetAttr("block_size", block_size);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="images">Input to the operation. </param>
      ///<param name="size">Input to the operation. </param>
      ///<param name="align_corners"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] resized_images(type: DtFloat).
      ///</return>
      public Operation ResizeBilinear (  Output images , Output size , bool align_corners = false ,String opName= "ResizeBilinear" ) 
      {
         OperationDescription desc = NewOperation("ResizeBilinear", opName);
         desc.AddInput(images);
         desc.AddInput(size);

         if (align_corners != false) desc.SetAttr("align_corners", align_corners);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_indices">Input to the operation. </param>
      ///<param name="input_values">Input to the operation. </param>
      ///<param name="input_shape">Input to the operation. </param>
      ///<param name="reduction_axes">Input to the operation. </param>
      ///<param name="keep_dims"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SparseReduceMax (  Output input_indices , Output input_values , Output input_shape , Output reduction_axes , bool keep_dims = false ,String opName= "SparseReduceMax" ) 
      {
         OperationDescription desc = NewOperation("SparseReduceMax", opName);
         desc.AddInput(input_indices);
         desc.AddInput(input_values);
         desc.AddInput(input_shape);
         desc.AddInput(reduction_axes);

         if (keep_dims != false) desc.SetAttr("keep_dims", keep_dims);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="images">Input to the operation. </param>
      ///<param name="ksizes"></param>
      ///<param name="strides"></param>
      ///<param name="rates"></param>
      ///<param name="padding"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] patches(type: DtInvalid).
      ///</return>
      public Operation ExtractImagePatches (  Output images , long[] ksizes, long[] strides, long[] rates, string padding,String opName= "ExtractImagePatches" ) 
      {
         OperationDescription desc = NewOperation("ExtractImagePatches", opName);
         desc.AddInput(images);
         desc.SetAttr("ksizes", ksizes);
         desc.SetAttr("strides", strides);
         desc.SetAttr("rates", rates);
         desc.SetAttr("padding", padding);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="depth">Input to the operation. </param>
      ///<param name="on_value">Input to the operation. </param>
      ///<param name="off_value">Input to the operation. </param>
      ///<param name="axis"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation OneHot (  Output indices , Output depth , Output on_value , Output off_value , long axis = -1 ,String opName= "OneHot" ) 
      {
         OperationDescription desc = NewOperation("OneHot", opName);
         desc.AddInput(indices);
         desc.AddInput(depth);
         desc.AddInput(on_value);
         desc.AddInput(off_value);

         if (axis != -1) desc.SetAttr("axis", axis);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="signed_input"></param>
      ///<param name="num_bits"></param>
      ///<param name="range_given"></param>
      ///<param name="input_min"></param>
      ///<param name="input_max"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation QuantizeAndDequantize (  Output input , bool signed_input = true , long num_bits = 8 , bool range_given = false , float input_min = 0f , float input_max = 0f ,String opName= "QuantizeAndDequantize" ) 
      {
         OperationDescription desc = NewOperation("QuantizeAndDequantize", opName);
         desc.AddInput(input);

         if (signed_input != true) desc.SetAttr("signed_input", signed_input);
         if (num_bits != 8) desc.SetAttr("num_bits", num_bits);
         if (range_given != false) desc.SetAttr("range_given", range_given);
         if (input_min != 0f) desc.SetAttr("input_min", input_min);
         if (input_max != 0f) desc.SetAttr("input_max", input_max);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="input_min">Input to the operation. </param>
      ///<param name="input_max">Input to the operation. </param>
      ///<param name="signed_input"></param>
      ///<param name="num_bits"></param>
      ///<param name="range_given"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation QuantizeAndDequantizeV2 (  Output input , Output input_min , Output input_max , bool signed_input = true , long num_bits = 8 , bool range_given = false ,String opName= "QuantizeAndDequantizeV2" ) 
      {
         OperationDescription desc = NewOperation("QuantizeAndDequantizeV2", opName);
         desc.AddInput(input);
         desc.AddInput(input_min);
         desc.AddInput(input_max);

         if (signed_input != true) desc.SetAttr("signed_input", signed_input);
         if (num_bits != 8) desc.SetAttr("num_bits", num_bits);
         if (range_given != false) desc.SetAttr("range_given", range_given);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="min_range">Input to the operation. </param>
      ///<param name="max_range">Input to the operation. </param>
      ///<param name="T"></param>
      ///<param name="mode"></param>
      ///<param name="round_mode"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///[1] output_min(type: DtFloat).
      ///[2] output_max(type: DtFloat).
      ///</return>
      public Operation QuantizeV2 (  Output input , Output min_range , Output max_range , DataType T, string mode = null , string round_mode = null ,String opName= "QuantizeV2" ) 
      {
         OperationDescription desc = NewOperation("QuantizeV2", opName);
         desc.AddInput(input);
         desc.AddInput(min_range);
         desc.AddInput(max_range);
         desc.SetAttr("T", T);
         if (mode != null) desc.SetAttr("mode", mode);
         if (round_mode != null) desc.SetAttr("round_mode", round_mode);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="min_range">Input to the operation. </param>
      ///<param name="max_range">Input to the operation. </param>
      ///<param name="mode"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtFloat).
      ///</return>
      public Operation Dequantize (  Output input , Output min_range , Output max_range , string mode = null ,String opName= "Dequantize" ) 
      {
         OperationDescription desc = NewOperation("Dequantize", opName);
         desc.AddInput(input);
         desc.AddInput(min_range);
         desc.AddInput(max_range);

         if (mode != null) desc.SetAttr("mode", mode);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation BitwiseOr (  Output x , Output y ,String opName= "BitwiseOr" ) 
      {
         OperationDescription desc = NewOperation("BitwiseOr", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="source"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] grad_handle(type: DtString).
      ///</return>
      public Operation TensorArrayGrad (  Output handle , Output flow_in , string source,String opName= "TensorArrayGrad" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayGrad", opName);
         desc.AddInput(handle);
         desc.AddInput(flow_in);
         desc.SetAttr("source", source);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="tensor">Input to the operation. </param>
      ///<param name="shape">Input to the operation. </param>
      ///<param name="input_min">Input to the operation. </param>
      ///<param name="input_max">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///[1] output_min(type: DtFloat).
      ///[2] output_max(type: DtFloat).
      ///</return>
      public Operation QuantizedReshape (  Output tensor , Output shape , Output input_min , Output input_max ,String opName= "QuantizedReshape" ) 
      {
         OperationDescription desc = NewOperation("QuantizedReshape", opName);
         desc.AddInput(tensor);
         desc.AddInput(shape);
         desc.AddInput(input_min);
         desc.AddInput(input_max);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="segment_ids">Input to the operation. </param>
      ///<param name="num_segments">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SparseSegmentMeanWithNumSegments (  Output data , Output indices , Output segment_ids , Output num_segments ,String opName= "SparseSegmentMeanWithNumSegments" ) 
      {
         OperationDescription desc = NewOperation("SparseSegmentMeanWithNumSegments", opName);
         desc.AddInput(data);
         desc.AddInput(indices);
         desc.AddInput(segment_ids);
         desc.AddInput(num_segments);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] size(type: DtInt32).
      ///</return>
      public Operation TensorArraySizeV3 (  Output handle , Output flow_in ,String opName= "TensorArraySizeV3" ) 
      {
         OperationDescription desc = NewOperation("TensorArraySizeV3", opName);
         desc.AddInput(handle);
         desc.AddInput(flow_in);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="x_min">Input to the operation. </param>
      ///<param name="x_max">Input to the operation. </param>
      ///<param name="output_range_given"></param>
      ///<param name="given_y_min"></param>
      ///<param name="given_y_max"></param>
      ///<param name="variance_epsilon"></param>
      ///<param name="min_separation"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///[1] y_min(type: DtFloat).
      ///[2] y_max(type: DtFloat).
      ///</return>
      public Operation QuantizedInstanceNorm (  Output x , Output x_min , Output x_max , bool output_range_given = false , float given_y_min = 0f , float given_y_max = 0f , float variance_epsilon = 1E-05f , float min_separation = 0.001f ,String opName= "QuantizedInstanceNorm" ) 
      {
         OperationDescription desc = NewOperation("QuantizedInstanceNorm", opName);
         desc.AddInput(x);
         desc.AddInput(x_min);
         desc.AddInput(x_max);

         if (output_range_given != false) desc.SetAttr("output_range_given", output_range_given);
         if (given_y_min != 0f) desc.SetAttr("given_y_min", given_y_min);
         if (given_y_max != 0f) desc.SetAttr("given_y_max", given_y_max);
         if (variance_epsilon != 1E-05f) desc.SetAttr("variance_epsilon", variance_epsilon);
         if (min_separation != 0.001f) desc.SetAttr("min_separation", min_separation);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="skip_header_lines"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] reader_handle(type: DtResource).
      ///</return>
      public Operation TextLineReaderV2 (  long skip_header_lines = 0 , string container = null , string shared_name = null ,String opName= "TextLineReaderV2" ) 
      {
         OperationDescription desc = NewOperation("TextLineReaderV2", opName);


         if (skip_header_lines != 0) desc.SetAttr("skip_header_lines", skip_header_lines);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="gradients">Input to the operation. </param>
      ///<param name="features">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] backprops(type: DtInvalid).
      ///</return>
      public Operation Relu6Grad (  Output gradients , Output features ,String opName= "Relu6Grad" ) 
      {
         OperationDescription desc = NewOperation("Relu6Grad", opName);
         desc.AddInput(gradients);
         desc.AddInput(features);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="updates">Input to the operation. </param>
      ///<param name="shape">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation ScatterNd (  Output indices , Output updates , Output shape ,String opName= "ScatterNd" ) 
      {
         OperationDescription desc = NewOperation("ScatterNd", opName);
         desc.AddInput(indices);
         desc.AddInput(updates);
         desc.AddInput(shape);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="updates">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation ScatterNdNonAliasingAdd (  Output input , Output indices , Output updates ,String opName= "ScatterNdNonAliasingAdd" ) 
      {
         OperationDescription desc = NewOperation("ScatterNdNonAliasingAdd", opName);
         desc.AddInput(input);
         desc.AddInput(indices);
         desc.AddInput(updates);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="n">Input to the operation. </param>
      ///<param name="component_types"></param>
      ///<param name="timeout_ms"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] components(type: DtInvalid).
      ///</return>
      public Operation QueueDequeueManyV2 (  Output handle , Output n , DataType[] component_types, long timeout_ms = -1 ,String opName= "QueueDequeueManyV2" ) 
      {
         OperationDescription desc = NewOperation("QueueDequeueManyV2", opName);
         desc.AddInput(handle);
         desc.AddInput(n);
         desc.SetAttr("component_types", component_types);
         if (timeout_ms != -1) desc.SetAttr("timeout_ms", timeout_ms);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="inputs">Input to the operation. </param>
      ///<param name="min"></param>
      ///<param name="max"></param>
      ///<param name="num_bits"></param>
      ///<param name="narrow_range"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] outputs(type: DtFloat).
      ///</return>
      public Operation FakeQuantWithMinMaxArgs (  Output inputs , float min = -6f , float max = 6f , long num_bits = 8 , bool narrow_range = false ,String opName= "FakeQuantWithMinMaxArgs" ) 
      {
         OperationDescription desc = NewOperation("FakeQuantWithMinMaxArgs", opName);
         desc.AddInput(inputs);

         if (min != -6f) desc.SetAttr("min", min);
         if (max != 6f) desc.SetAttr("max", max);
         if (num_bits != 8) desc.SetAttr("num_bits", num_bits);
         if (narrow_range != false) desc.SetAttr("narrow_range", narrow_range);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="image_size">Input to the operation. </param>
      ///<param name="bounding_boxes">Input to the operation. </param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="min_object_covered"></param>
      ///<param name="aspect_ratio_range"></param>
      ///<param name="area_range"></param>
      ///<param name="max_attempts"></param>
      ///<param name="use_image_if_no_bounding_boxes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] begin(type: DtInvalid).
      ///[1] size(type: DtInvalid).
      ///[2] bboxes(type: DtFloat).
      ///</return>
      public Operation SampleDistortedBoundingBox (  Output image_size , Output bounding_boxes , long seed = 0 , long seed2 = 0 , float min_object_covered = 0.1f , float[] aspect_ratio_range = null , float[] area_range = null , long max_attempts = 100 , bool use_image_if_no_bounding_boxes = false ,String opName= "SampleDistortedBoundingBox" ) 
      {
         OperationDescription desc = NewOperation("SampleDistortedBoundingBox", opName);
         desc.AddInput(image_size);
         desc.AddInput(bounding_boxes);

         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         if (min_object_covered != 0.1f) desc.SetAttr("min_object_covered", min_object_covered);
         if (aspect_ratio_range != null) desc.SetAttr("aspect_ratio_range", aspect_ratio_range);
         if (area_range != null) desc.SetAttr("area_range", area_range);
         if (max_attempts != 100) desc.SetAttr("max_attempts", max_attempts);
         if (use_image_if_no_bounding_boxes != false) desc.SetAttr("use_image_if_no_bounding_boxes", use_image_if_no_bounding_boxes);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="inputs">Input to the operation. </param>
      ///<param name="min">Input to the operation. </param>
      ///<param name="max">Input to the operation. </param>
      ///<param name="num_bits"></param>
      ///<param name="narrow_range"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] outputs(type: DtFloat).
      ///</return>
      public Operation FakeQuantWithMinMaxVars (  Output inputs , Output min , Output max , long num_bits = 8 , bool narrow_range = false ,String opName= "FakeQuantWithMinMaxVars" ) 
      {
         OperationDescription desc = NewOperation("FakeQuantWithMinMaxVars", opName);
         desc.AddInput(inputs);
         desc.AddInput(min);
         desc.AddInput(max);

         if (num_bits != 8) desc.SetAttr("num_bits", num_bits);
         if (narrow_range != false) desc.SetAttr("narrow_range", narrow_range);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="inputs">Input to the operation. </param>
      ///<param name="min">Input to the operation. </param>
      ///<param name="max">Input to the operation. </param>
      ///<param name="num_bits"></param>
      ///<param name="narrow_range"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] outputs(type: DtFloat).
      ///</return>
      public Operation FakeQuantWithMinMaxVarsPerChannel (  Output inputs , Output min , Output max , long num_bits = 8 , bool narrow_range = false ,String opName= "FakeQuantWithMinMaxVarsPerChannel" ) 
      {
         OperationDescription desc = NewOperation("FakeQuantWithMinMaxVarsPerChannel", opName);
         desc.AddInput(inputs);
         desc.AddInput(min);
         desc.AddInput(max);

         if (num_bits != 8) desc.SetAttr("num_bits", num_bits);
         if (narrow_range != false) desc.SetAttr("narrow_range", narrow_range);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceSparseApplyAdagrad (  Output var , Output accum , Output lr , Output grad , Output indices , bool use_locking = false ,String opName= "ResourceSparseApplyAdagrad" ) 
      {
         OperationDescription desc = NewOperation("ResourceSparseApplyAdagrad", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(lr);
         desc.AddInput(grad);
         desc.AddInput(indices);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="segment_ids">Input to the operation. </param>
      ///<param name="num_segments">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation UnsortedSegmentProd (  Output data , Output segment_ids , Output num_segments ,String opName= "UnsortedSegmentProd" ) 
      {
         OperationDescription desc = NewOperation("UnsortedSegmentProd", opName);
         desc.AddInput(data);
         desc.AddInput(segment_ids);
         desc.AddInput(num_segments);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="gradients">Input to the operation. </param>
      ///<param name="inputs">Input to the operation. </param>
      ///<param name="min">Input to the operation. </param>
      ///<param name="max">Input to the operation. </param>
      ///<param name="num_bits"></param>
      ///<param name="narrow_range"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] backprops_wrt_input(type: DtFloat).
      ///[1] backprop_wrt_min(type: DtFloat).
      ///[2] backprop_wrt_max(type: DtFloat).
      ///</return>
      public Operation FakeQuantWithMinMaxVarsPerChannelGradient (  Output gradients , Output inputs , Output min , Output max , long num_bits = 8 , bool narrow_range = false ,String opName= "FakeQuantWithMinMaxVarsPerChannelGradient" ) 
      {
         OperationDescription desc = NewOperation("FakeQuantWithMinMaxVarsPerChannelGradient", opName);
         desc.AddInput(gradients);
         desc.AddInput(inputs);
         desc.AddInput(min);
         desc.AddInput(max);

         if (num_bits != 8) desc.SetAttr("num_bits", num_bits);
         if (narrow_range != false) desc.SetAttr("narrow_range", narrow_range);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="diagonal">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation BatchMatrixDiag (  Output diagonal ,String opName= "BatchMatrixDiag" ) 
      {
         OperationDescription desc = NewOperation("BatchMatrixDiag", opName);
         desc.AddInput(diagonal);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="element_shape_except0"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] value(type: DtInvalid).
      ///[1] lengths(type: DtInt64).
      ///</return>
      public Operation TensorArrayConcat (  Output handle , Output flow_in , DataType dtype, long[] element_shape_except0 = null ,String opName= "TensorArrayConcat" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayConcat", opName);
         desc.AddInput(handle);
         desc.AddInput(flow_in);
         desc.SetAttr("dtype", dtype);
         if (element_shape_except0 != null) desc.SetAttrShape("element_shape_except0", element_shape_except0);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="diagonal">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation BatchMatrixSetDiag (  Output input , Output diagonal ,String opName= "BatchMatrixSetDiag" ) 
      {
         OperationDescription desc = NewOperation("BatchMatrixSetDiag", opName);
         desc.AddInput(input);
         desc.AddInput(diagonal);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="num_lower">Input to the operation. </param>
      ///<param name="num_upper">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] band(type: DtInvalid).
      ///</return>
      public Operation BatchMatrixBandPart (  Output input , Output num_lower , Output num_upper ,String opName= "BatchMatrixBandPart" ) 
      {
         OperationDescription desc = NewOperation("BatchMatrixBandPart", opName);
         desc.AddInput(input);
         desc.AddInput(num_lower);
         desc.AddInput(num_upper);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="iterator">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] components(type: DtInvalid).
      ///</return>
      public Operation IteratorGetNext (  Output iterator , DataType[] output_types, long[][] output_shapes,String opName= "IteratorGetNext" ) 
      {
         OperationDescription desc = NewOperation("IteratorGetNext", opName);
         desc.AddInput(iterator);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="contents">Input to the operation. </param>
      ///<param name="desired_channels"></param>
      ///<param name="desired_samples"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] audio(type: DtFloat).
      ///[1] sample_rate(type: DtInt32).
      ///</return>
      public Operation DecodeWav (  Output contents , long desired_channels = -1 , long desired_samples = -1 ,String opName= "DecodeWav" ) 
      {
         OperationDescription desc = NewOperation("DecodeWav", opName);
         desc.AddInput(contents);

         if (desired_channels != -1) desc.SetAttr("desired_channels", desired_channels);
         if (desired_samples != -1) desc.SetAttr("desired_samples", desired_samples);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="sparse_indices">Input to the operation. </param>
      ///<param name="output_shape">Input to the operation. </param>
      ///<param name="sparse_values">Input to the operation. </param>
      ///<param name="default_value">Input to the operation. </param>
      ///<param name="validate_indices"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] dense(type: DtInvalid).
      ///</return>
      public Operation SparseToDense (  Output sparse_indices , Output output_shape , Output sparse_values , Output default_value , bool validate_indices = true ,String opName= "SparseToDense" ) 
      {
         OperationDescription desc = NewOperation("SparseToDense", opName);
         desc.AddInput(sparse_indices);
         desc.AddInput(output_shape);
         desc.AddInput(sparse_values);
         desc.AddInput(default_value);

         if (validate_indices != true) desc.SetAttr("validate_indices", validate_indices);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="audio">Input to the operation. </param>
      ///<param name="sample_rate">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] contents(type: DtString).
      ///</return>
      public Operation EncodeWav (  Output audio , Output sample_rate ,String opName= "EncodeWav" ) 
      {
         OperationDescription desc = NewOperation("EncodeWav", opName);
         desc.AddInput(audio);
         desc.AddInput(sample_rate);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="weights">Input to the operation. </param>
      ///<param name="l1"></param>
      ///<param name="l2"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation SdcaShrinkL1 (  Output weights , float l1, float l2,String opName= "SdcaShrinkL1" ) 
      {
         OperationDescription desc = NewOperation("SdcaShrinkL1", opName);
         desc.AddInput(weights);
         desc.SetAttr("l1", l1);
         desc.SetAttr("l2", l2);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="orig_input_tensor_shape">Input to the operation. </param>
      ///<param name="out_backprop">Input to the operation. </param>
      ///<param name="row_pooling_sequence">Input to the operation. </param>
      ///<param name="col_pooling_sequence">Input to the operation. </param>
      ///<param name="overlapping"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation FractionalAvgPoolGrad (  Output orig_input_tensor_shape , Output out_backprop , Output row_pooling_sequence , Output col_pooling_sequence , bool overlapping = false ,String opName= "FractionalAvgPoolGrad" ) 
      {
         OperationDescription desc = NewOperation("FractionalAvgPoolGrad", opName);
         desc.AddInput(orig_input_tensor_shape);
         desc.AddInput(out_backprop);
         desc.AddInput(row_pooling_sequence);
         desc.AddInput(col_pooling_sequence);

         if (overlapping != false) desc.SetAttr("overlapping", overlapping);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="spectrogram">Input to the operation. </param>
      ///<param name="sample_rate">Input to the operation. </param>
      ///<param name="upper_frequency_limit"></param>
      ///<param name="lower_frequency_limit"></param>
      ///<param name="filterbank_channel_count"></param>
      ///<param name="dct_coefficient_count"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtFloat).
      ///</return>
      public Operation Mfcc (  Output spectrogram , Output sample_rate , float upper_frequency_limit = 4000f , float lower_frequency_limit = 20f , long filterbank_channel_count = 40 , long dct_coefficient_count = 13 ,String opName= "Mfcc" ) 
      {
         OperationDescription desc = NewOperation("Mfcc", opName);
         desc.AddInput(spectrogram);
         desc.AddInput(sample_rate);

         if (upper_frequency_limit != 4000f) desc.SetAttr("upper_frequency_limit", upper_frequency_limit);
         if (lower_frequency_limit != 20f) desc.SetAttr("lower_frequency_limit", lower_frequency_limit);
         if (filterbank_channel_count != 40) desc.SetAttr("filterbank_channel_count", filterbank_channel_count);
         if (dct_coefficient_count != 13) desc.SetAttr("dct_coefficient_count", dct_coefficient_count);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="y">Input to the operation. </param>
      ///<param name="dy">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation RsqrtGrad (  Output y , Output dy ,String opName= "RsqrtGrad" ) 
      {
         OperationDescription desc = NewOperation("RsqrtGrad", opName);
         desc.AddInput(y);
         desc.AddInput(dy);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="in_tensors">Input to the operation. </param>
      ///<param name="num_batch_threads"></param>
      ///<param name="max_batch_size"></param>
      ///<param name="batch_timeout_micros"></param>
      ///<param name="grad_timeout_micros"></param>
      ///<param name="max_enqueued_batches"></param>
      ///<param name="allowed_batch_sizes"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="batching_queue"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] batched_tensors(type: DtInvalid).
      ///[1] batch_index(type: DtInt64).
      ///[2] id(type: DtInt64).
      ///</return>
      public Operation Batch (  Output in_tensors , long num_batch_threads, long max_batch_size, long batch_timeout_micros, long grad_timeout_micros, long max_enqueued_batches = 10 , long[] allowed_batch_sizes = null , string container = null , string shared_name = null , string batching_queue = null ,String opName= "Batch" ) 
      {
         OperationDescription desc = NewOperation("Batch", opName);
         desc.AddInput(in_tensors);
         desc.SetAttr("num_batch_threads", num_batch_threads);
         desc.SetAttr("max_batch_size", max_batch_size);
         desc.SetAttr("batch_timeout_micros", batch_timeout_micros);
         desc.SetAttr("grad_timeout_micros", grad_timeout_micros);
         if (max_enqueued_batches != 10) desc.SetAttr("max_enqueued_batches", max_enqueued_batches);
         if (allowed_batch_sizes != null) desc.SetAttr("allowed_batch_sizes", allowed_batch_sizes);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         if (batching_queue != null) desc.SetAttr("batching_queue", batching_queue);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="predictions">Input to the operation. </param>
      ///<param name="targets">Input to the operation. </param>
      ///<param name="k"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] precision(type: DtBool).
      ///</return>
      public Operation InTopK (  Output predictions , Output targets , long k,String opName= "InTopK" ) 
      {
         OperationDescription desc = NewOperation("InTopK", opName);
         desc.AddInput(predictions);
         desc.AddInput(targets);
         desc.SetAttr("k", k);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="batched_tensor">Input to the operation. </param>
      ///<param name="batch_index">Input to the operation. </param>
      ///<param name="id">Input to the operation. </param>
      ///<param name="timeout_micros"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] unbatched_tensor(type: DtInvalid).
      ///</return>
      public Operation Unbatch (  Output batched_tensor , Output batch_index , Output id , long timeout_micros, string container = null , string shared_name = null ,String opName= "Unbatch" ) 
      {
         OperationDescription desc = NewOperation("Unbatch", opName);
         desc.AddInput(batched_tensor);
         desc.AddInput(batch_index);
         desc.AddInput(id);
         desc.SetAttr("timeout_micros", timeout_micros);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="values">Input to the operation. </param>
      ///<param name="dense_shape">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation SparseTensorSliceDataset (  Output indices , Output values , Output dense_shape ,String opName= "SparseTensorSliceDataset" ) 
      {
         OperationDescription desc = NewOperation("SparseTensorSliceDataset", opName);
         desc.AddInput(indices);
         desc.AddInput(values);
         desc.AddInput(dense_shape);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="original_input">Input to the operation. </param>
      ///<param name="batch_index">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="id">Input to the operation. </param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] batched_grad(type: DtInvalid).
      ///</return>
      public Operation UnbatchGrad (  Output original_input , Output batch_index , Output grad , Output id , string container = null , string shared_name = null ,String opName= "UnbatchGrad" ) 
      {
         OperationDescription desc = NewOperation("UnbatchGrad", opName);
         desc.AddInput(original_input);
         desc.AddInput(batch_index);
         desc.AddInput(grad);
         desc.AddInput(id);

         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation SparseApplyAdagrad (  Output var , Output accum , Output lr , Output grad , Output indices , bool use_locking = false ,String opName= "SparseApplyAdagrad" ) 
      {
         OperationDescription desc = NewOperation("SparseApplyAdagrad", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(lr);
         desc.AddInput(grad);
         desc.AddInput(indices);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Invert (  Output x ,String opName= "Invert" ) 
      {
         OperationDescription desc = NewOperation("Invert", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtUint8).
      ///</return>
      public Operation PopulationCount (  Output x ,String opName= "PopulationCount" ) 
      {
         OperationDescription desc = NewOperation("PopulationCount", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="size">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="dynamic_size"></param>
      ///<param name="clear_after_read"></param>
      ///<param name="tensor_array_name"></param>
      ///<param name="element_shape"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtString).
      ///</return>
      public Operation TensorArray (  Output size , DataType dtype, bool dynamic_size = false , bool clear_after_read = true , string tensor_array_name = null , long[] element_shape = null ,String opName= "TensorArray" ) 
      {
         OperationDescription desc = NewOperation("TensorArray", opName);
         desc.AddInput(size);
         desc.SetAttr("dtype", dtype);
         if (dynamic_size != false) desc.SetAttr("dynamic_size", dynamic_size);
         if (clear_after_read != true) desc.SetAttr("clear_after_read", clear_after_read);
         if (tensor_array_name != null) desc.SetAttr("tensor_array_name", tensor_array_name);
         if (element_shape != null) desc.SetAttrShape("element_shape", element_shape);
         return desc.FinishOperation();
      } 
      // Skipped function _If

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation BitwiseAnd (  Output x , Output y ,String opName= "BitwiseAnd" ) 
      {
         OperationDescription desc = NewOperation("BitwiseAnd", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation BitwiseXor (  Output x , Output y ,String opName= "BitwiseXor" ) 
      {
         OperationDescription desc = NewOperation("BitwiseXor", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation LeftShift (  Output x , Output y ,String opName= "LeftShift" ) 
      {
         OperationDescription desc = NewOperation("LeftShift", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="true_classes">Input to the operation. </param>
      ///<param name="num_true"></param>
      ///<param name="num_sampled"></param>
      ///<param name="unique"></param>
      ///<param name="range_max"></param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] sampled_candidates(type: DtInt64).
      ///[1] true_expected_count(type: DtFloat).
      ///[2] sampled_expected_count(type: DtFloat).
      ///</return>
      public Operation UniformCandidateSampler (  Output true_classes , long num_true, long num_sampled, bool unique, long range_max, long seed = 0 , long seed2 = 0 ,String opName= "UniformCandidateSampler" ) 
      {
         OperationDescription desc = NewOperation("UniformCandidateSampler", opName);
         desc.AddInput(true_classes);
         desc.SetAttr("num_true", num_true);
         desc.SetAttr("num_sampled", num_sampled);
         desc.SetAttr("unique", unique);
         desc.SetAttr("range_max", range_max);
         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///Debug NaN Value Counter Op
      ///</summary>
      ///<param name="input">Input to the operation: Input tensor, non-Reference type.</param>
      ///<param name="device_name"></param>
      ///<param name="tensor_name">Name of the input tensor.</param>
      ///<param name="debug_urls">List of URLs to debug targets, e.g., file:///foo/tfdbg_dump, grpc:://localhost:11011.</param>
      ///<param name="gated_grpc">Whether this op will be gated. If any of the debug_urls of this debug node is of the grpc:// scheme, when the value of this attribute is set to True, the data will not actually be sent via the grpc stream unless this debug op has been enabled at the debug_url. If all of the debug_urls of this debug node are of the grpc:// scheme and the debug op is enabled at none of them, the output will be an empty Tensor.</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInt64): An integer output tensor that is the number of NaNs in the input.
      ///</return>
      public Operation DebugNanCount (  Output input , string device_name = null , string tensor_name = null , string[] debug_urls = null , bool gated_grpc = false ,String opName= "DebugNanCount" ) 
      {
         OperationDescription desc = NewOperation("DebugNanCount", opName);
         desc.AddInput(input);

         if (device_name != null) desc.SetAttr("device_name", device_name);
         if (tensor_name != null) desc.SetAttr("tensor_name", tensor_name);
         if (debug_urls != null) desc.SetAttr("debug_urls", debug_urls);
         if (gated_grpc != false) desc.SetAttr("gated_grpc", gated_grpc);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="fft_length">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtComplex64).
      ///</return>
      public Operation RFFT3D (  Output input , Output fft_length ,String opName= "RFFT3D" ) 
      {
         OperationDescription desc = NewOperation("RFFT3D", opName);
         desc.AddInput(input);
         desc.AddInput(fft_length);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///Copy Op.
      ///</summary>
      ///<param name="input">Input to the operation: Input tensor.</param>
      ///<param name="tensor_name">The name of the input tensor.</param>
      ///<param name="debug_ops_spec">A list of debug op spec (op, url, gated_grpc) for attached debug ops. Each element of the list has the format &lt;debug_op&gt;;&lt;grpc_url&gt;;&lt;gated_grpc&gt;, wherein gated_grpc is boolean represented as 0/1. E.g., "DebugIdentity;grpc://foo:3333;1", "DebugIdentity;file:///tmp/tfdbg_1;0".</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid): Output tensor, deep-copied from input.
      ///</return>
      public Operation Copy (  Output input , string tensor_name = null , string[] debug_ops_spec = null ,String opName= "Copy" ) 
      {
         OperationDescription desc = NewOperation("Copy", opName);
         desc.AddInput(input);

         if (tensor_name != null) desc.SetAttr("tensor_name", tensor_name);
         if (debug_ops_spec != null) desc.SetAttr("debug_ops_spec", debug_ops_spec);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="ms">Input to the operation. </param>
      ///<param name="mom">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="rho">Input to the operation. </param>
      ///<param name="momentum">Input to the operation. </param>
      ///<param name="epsilon">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation SparseApplyRMSProp (  Output var , Output ms , Output mom , Output lr , Output rho , Output momentum , Output epsilon , Output grad , Output indices , bool use_locking = false ,String opName= "SparseApplyRMSProp" ) 
      {
         OperationDescription desc = NewOperation("SparseApplyRMSProp", opName);
         desc.AddInput(var);
         desc.AddInput(ms);
         desc.AddInput(mom);
         desc.AddInput(lr);
         desc.AddInput(rho);
         desc.AddInput(momentum);
         desc.AddInput(epsilon);
         desc.AddInput(grad);
         desc.AddInput(indices);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="true_classes">Input to the operation. </param>
      ///<param name="num_true"></param>
      ///<param name="num_sampled"></param>
      ///<param name="unique"></param>
      ///<param name="range_max"></param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] sampled_candidates(type: DtInt64).
      ///[1] true_expected_count(type: DtFloat).
      ///[2] sampled_expected_count(type: DtFloat).
      ///</return>
      public Operation LearnedUnigramCandidateSampler (  Output true_classes , long num_true, long num_sampled, bool unique, long range_max, long seed = 0 , long seed2 = 0 ,String opName= "LearnedUnigramCandidateSampler" ) 
      {
         OperationDescription desc = NewOperation("LearnedUnigramCandidateSampler", opName);
         desc.AddInput(true_classes);
         desc.SetAttr("num_true", num_true);
         desc.SetAttr("num_sampled", num_sampled);
         desc.SetAttr("unique", unique);
         desc.SetAttr("range_max", range_max);
         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="another_dataset">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation ConcatenateDataset (  Output input_dataset , Output another_dataset , DataType[] output_types, long[][] output_shapes,String opName= "ConcatenateDataset" ) 
      {
         OperationDescription desc = NewOperation("ConcatenateDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(another_dataset);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="key_dtype"></param>
      ///<param name="value_dtype"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="use_node_name_sharing"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] table_handle(type: DtString).
      ///</return>
      public Operation MutableHashTable (  DataType key_dtype, DataType value_dtype, string container = null , string shared_name = null , bool use_node_name_sharing = false ,String opName= "MutableHashTable" ) 
      {
         OperationDescription desc = NewOperation("MutableHashTable", opName);

         desc.SetAttr("key_dtype", key_dtype);
         desc.SetAttr("value_dtype", value_dtype);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         if (use_node_name_sharing != false) desc.SetAttr("use_node_name_sharing", use_node_name_sharing);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="true_classes">Input to the operation. </param>
      ///<param name="num_true"></param>
      ///<param name="num_sampled"></param>
      ///<param name="unique"></param>
      ///<param name="range_max"></param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] sampled_candidates(type: DtInt64).
      ///[1] true_expected_count(type: DtFloat).
      ///[2] sampled_expected_count(type: DtFloat).
      ///</return>
      public Operation ThreadUnsafeUnigramCandidateSampler (  Output true_classes , long num_true, long num_sampled, bool unique, long range_max, long seed = 0 , long seed2 = 0 ,String opName= "ThreadUnsafeUnigramCandidateSampler" ) 
      {
         OperationDescription desc = NewOperation("ThreadUnsafeUnigramCandidateSampler", opName);
         desc.AddInput(true_classes);
         desc.SetAttr("num_true", num_true);
         desc.SetAttr("num_sampled", num_sampled);
         desc.SetAttr("unique", unique);
         desc.SetAttr("range_max", range_max);
         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="sparse_handles">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] sparse_indices(type: DtInt64).
      ///[1] sparse_values(type: DtInvalid).
      ///[2] sparse_shape(type: DtInt64).
      ///</return>
      public Operation TakeManySparseFromTensorsMap (  Output sparse_handles , DataType dtype, string container = null , string shared_name = null ,String opName= "TakeManySparseFromTensorsMap" ) 
      {
         OperationDescription desc = NewOperation("TakeManySparseFromTensorsMap", opName);
         desc.AddInput(sparse_handles);
         desc.SetAttr("dtype", dtype);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="true_classes">Input to the operation. </param>
      ///<param name="num_true"></param>
      ///<param name="num_sampled"></param>
      ///<param name="unique"></param>
      ///<param name="range_max"></param>
      ///<param name="vocab_file"></param>
      ///<param name="distortion"></param>
      ///<param name="num_reserved_ids"></param>
      ///<param name="num_shards"></param>
      ///<param name="shard"></param>
      ///<param name="unigrams"></param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] sampled_candidates(type: DtInt64).
      ///[1] true_expected_count(type: DtFloat).
      ///[2] sampled_expected_count(type: DtFloat).
      ///</return>
      public Operation FixedUnigramCandidateSampler (  Output true_classes , long num_true, long num_sampled, bool unique, long range_max, string vocab_file = null , float distortion = 1f , long num_reserved_ids = 0 , long num_shards = 1 , long shard = 0 , float[] unigrams = null , long seed = 0 , long seed2 = 0 ,String opName= "FixedUnigramCandidateSampler" ) 
      {
         OperationDescription desc = NewOperation("FixedUnigramCandidateSampler", opName);
         desc.AddInput(true_classes);
         desc.SetAttr("num_true", num_true);
         desc.SetAttr("num_sampled", num_sampled);
         desc.SetAttr("unique", unique);
         desc.SetAttr("range_max", range_max);
         if (vocab_file != null) desc.SetAttr("vocab_file", vocab_file);
         if (distortion != 1f) desc.SetAttr("distortion", distortion);
         if (num_reserved_ids != 0) desc.SetAttr("num_reserved_ids", num_reserved_ids);
         if (num_shards != 1) desc.SetAttr("num_shards", num_shards);
         if (shard != 0) desc.SetAttr("shard", shard);
         if (unigrams != null) desc.SetAttr("unigrams", unigrams);
         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="ckpt_path">Input to the operation. </param>
      ///<param name="old_tensor_name">Input to the operation. </param>
      ///<param name="row_remapping">Input to the operation. </param>
      ///<param name="col_remapping">Input to the operation. </param>
      ///<param name="initializing_values">Input to the operation. </param>
      ///<param name="num_rows"></param>
      ///<param name="num_cols"></param>
      ///<param name="max_rows_in_memory"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_matrix(type: DtFloat).
      ///</return>
      public Operation LoadAndRemapMatrix (  Output ckpt_path , Output old_tensor_name , Output row_remapping , Output col_remapping , Output initializing_values , long num_rows, long num_cols, long max_rows_in_memory = -1 ,String opName= "LoadAndRemapMatrix" ) 
      {
         OperationDescription desc = NewOperation("LoadAndRemapMatrix", opName);
         desc.AddInput(ckpt_path);
         desc.AddInput(old_tensor_name);
         desc.AddInput(row_remapping);
         desc.AddInput(col_remapping);
         desc.AddInput(initializing_values);
         desc.SetAttr("num_rows", num_rows);
         desc.SetAttr("num_cols", num_cols);
         if (max_rows_in_memory != -1) desc.SetAttr("max_rows_in_memory", max_rows_in_memory);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Log (  Output x ,String opName= "Log" ) 
      {
         OperationDescription desc = NewOperation("Log", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="pred">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_false(type: DtInvalid).
      ///[1] output_true(type: DtInvalid).
      ///</return>
      public Operation Switch (  Output data , Output pred ,String opName= "Switch" ) 
      {
         OperationDescription desc = NewOperation("Switch", opName);
         desc.AddInput(data);
         desc.AddInput(pred);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="pred">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_false(type: DtInvalid).
      ///[1] output_true(type: DtInvalid).
      ///</return>
      public Operation RefSwitch (  Output data , Output pred ,String opName= "RefSwitch" ) 
      {
         OperationDescription desc = NewOperation("RefSwitch", opName);
         desc.AddInput(data);
         desc.AddInput(pred);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="full_matrices"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] q(type: DtInvalid).
      ///[1] r(type: DtInvalid).
      ///</return>
      public Operation Qr (  Output input , bool full_matrices = false ,String opName= "Qr" ) 
      {
         OperationDescription desc = NewOperation("Qr", opName);
         desc.AddInput(input);

         if (full_matrices != false) desc.SetAttr("full_matrices", full_matrices);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="y_backprop">Input to the operation. </param>
      ///<param name="x">Input to the operation. </param>
      ///<param name="scale">Input to the operation. </param>
      ///<param name="reserve_space_1">Input to the operation. </param>
      ///<param name="reserve_space_2">Input to the operation. </param>
      ///<param name="epsilon"></param>
      ///<param name="data_format"></param>
      ///<param name="is_training"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] x_backprop(type: DtInvalid).
      ///[1] scale_backprop(type: DtInvalid).
      ///[2] offset_backprop(type: DtInvalid).
      ///[3] reserve_space_3(type: DtInvalid).
      ///[4] reserve_space_4(type: DtInvalid).
      ///</return>
      public Operation FusedBatchNormGrad (  Output y_backprop , Output x , Output scale , Output reserve_space_1 , Output reserve_space_2 , float epsilon = 0.0001f , string data_format = null , bool is_training = true ,String opName= "FusedBatchNormGrad" ) 
      {
         OperationDescription desc = NewOperation("FusedBatchNormGrad", opName);
         desc.AddInput(y_backprop);
         desc.AddInput(x);
         desc.AddInput(scale);
         desc.AddInput(reserve_space_1);
         desc.AddInput(reserve_space_2);

         if (epsilon != 0.0001f) desc.SetAttr("epsilon", epsilon);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         if (is_training != true) desc.SetAttr("is_training", is_training);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="index">Input to the operation. </param>
      ///<param name="inputs">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation RefSelect (  Output index , Output inputs ,String opName= "RefSelect" ) 
      {
         OperationDescription desc = NewOperation("RefSelect", opName);
         desc.AddInput(index);
         desc.AddInput(inputs);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="tensor">Input to the operation. </param>
      ///<param name="element_shape">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_handle(type: DtVariant).
      ///</return>
      public Operation TensorListFromTensor (  Output tensor , Output element_shape ,String opName= "TensorListFromTensor" ) 
      {
         OperationDescription desc = NewOperation("TensorListFromTensor", opName);
         desc.AddInput(tensor);
         desc.AddInput(element_shape);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///Debug Numeric Summary Op.
      ///</summary>
      ///<param name="input">Input to the operation: Input tensor, non-Reference type, float or double.</param>
      ///<param name="device_name"></param>
      ///<param name="tensor_name">Name of the input tensor.</param>
      ///<param name="debug_urls">List of URLs to debug targets, e.g., file:///foo/tfdbg_dump, grpc:://localhost:11011</param>
      ///<param name="lower_bound">(float) The lower bound &lt;= which values will be included in the generalized -inf count. Default: -inf.</param>
      ///<param name="upper_bound">(float) The upper bound &gt;= which values will be included in the generalized +inf count. Default: +inf.</param>
      ///<param name="mute_if_healthy">(bool) Do not send data to the debug URLs unless at least one of elements [2], [3] and [7] (i.e., the nan count and the generalized -inf and inf counts) is non-zero.</param>
      ///<param name="gated_grpc">Whether this op will be gated. If any of the debug_urls of this debug node is of the grpc:// scheme, when the value of this attribute is set to True, the data will not actually be sent via the grpc stream unless this debug op has been enabled at the debug_url. If all of the debug_urls of this debug node are of the grpc:// scheme and the debug op is enabled at none of them, the output will be an empty Tensor.</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtDouble): A double tensor of shape [14 + nDimensions], where nDimensions is the   the number of dimensions of the tensor's shape. The elements of output are:   [0]: is initialized (1.0) or not (0.0).   [1]: total number of elements   [2]: NaN element count   [3]: generalized -inf count: elements &lt;= lower_bound. lower_bound is -inf by     default.   [4]: negative element count (excluding -inf), if lower_bound is the default     -inf. Otherwise, this is the count of elements &gt; lower_bound and &lt; 0.   [5]: zero element count   [6]: positive element count (excluding +inf), if upper_bound is the default     -inf. Otherwise, this is the count of elements &lt; upper_bound and &gt; 0.   [7]: generalized +inf count, elements &gt;= upper_bound. upper_bound is +inf by     default. Output elements [1:8] are all zero, if the tensor is uninitialized.   [8]: minimum of all non-inf and non-NaN elements.        If uninitialized or no such element exists: +inf.   [9]: maximum of all non-inf and non-NaN elements.        If uninitialized or no such element exists: -inf.   [10]: mean of all non-inf and non-NaN elements.         If uninitialized or no such element exists: NaN.   [11]: variance of all non-inf and non-NaN elements.         If uninitialized or no such element exists: NaN.   [12]: Data type of the tensor encoded as an enum integer. See the DataType         proto for more details.   [13]: Number of dimensions of the tensor (ndims).   [14+]: Sizes of the dimensions.
      ///</return>
      public Operation DebugNumericSummary (  Output input , string device_name = null , string tensor_name = null , string[] debug_urls = null , float lower_bound = Single.NegativeInfinity , float upper_bound = Single.PositiveInfinity , bool mute_if_healthy = false , bool gated_grpc = false ,String opName= "DebugNumericSummary" ) 
      {
         OperationDescription desc = NewOperation("DebugNumericSummary", opName);
         desc.AddInput(input);

         if (device_name != null) desc.SetAttr("device_name", device_name);
         if (tensor_name != null) desc.SetAttr("tensor_name", tensor_name);
         if (debug_urls != null) desc.SetAttr("debug_urls", debug_urls);
         if (lower_bound != Single.NegativeInfinity) desc.SetAttr("lower_bound", lower_bound);
         if (upper_bound != Single.PositiveInfinity) desc.SetAttr("upper_bound", upper_bound);
         if (mute_if_healthy != false) desc.SetAttr("mute_if_healthy", mute_if_healthy);
         if (gated_grpc != false) desc.SetAttr("gated_grpc", gated_grpc);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Sin (  Output x ,String opName= "Sin" ) 
      {
         OperationDescription desc = NewOperation("Sin", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="frame_name"></param>
      ///<param name="is_constant"></param>
      ///<param name="parallel_iterations"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Enter (  Output data , string frame_name, bool is_constant = false , long parallel_iterations = 10 ,String opName= "Enter" ) 
      {
         OperationDescription desc = NewOperation("Enter", opName);
         desc.AddInput(data);
         desc.SetAttr("frame_name", frame_name);
         if (is_constant != false) desc.SetAttr("is_constant", is_constant);
         if (parallel_iterations != 10) desc.SetAttr("parallel_iterations", parallel_iterations);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="frame_name"></param>
      ///<param name="is_constant"></param>
      ///<param name="parallel_iterations"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation RefEnter (  Output data , string frame_name, bool is_constant = false , long parallel_iterations = 10 ,String opName= "RefEnter" ) 
      {
         OperationDescription desc = NewOperation("RefEnter", opName);
         desc.AddInput(data);
         desc.SetAttr("frame_name", frame_name);
         if (is_constant != false) desc.SetAttr("is_constant", is_constant);
         if (parallel_iterations != 10) desc.SetAttr("parallel_iterations", parallel_iterations);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="contents">Input to the operation. </param>
      ///<param name="crop_window">Input to the operation. </param>
      ///<param name="channels"></param>
      ///<param name="ratio"></param>
      ///<param name="fancy_upscaling"></param>
      ///<param name="try_recover_truncated"></param>
      ///<param name="acceptable_fraction"></param>
      ///<param name="dct_method"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] image(type: DtUint8).
      ///</return>
      public Operation DecodeAndCropJpeg (  Output contents , Output crop_window , long channels = 0 , long ratio = 1 , bool fancy_upscaling = true , bool try_recover_truncated = false , float acceptable_fraction = 1f , string dct_method = null ,String opName= "DecodeAndCropJpeg" ) 
      {
         OperationDescription desc = NewOperation("DecodeAndCropJpeg", opName);
         desc.AddInput(contents);
         desc.AddInput(crop_window);

         if (channels != 0) desc.SetAttr("channels", channels);
         if (ratio != 1) desc.SetAttr("ratio", ratio);
         if (fancy_upscaling != true) desc.SetAttr("fancy_upscaling", fancy_upscaling);
         if (try_recover_truncated != false) desc.SetAttr("try_recover_truncated", try_recover_truncated);
         if (acceptable_fraction != 1f) desc.SetAttr("acceptable_fraction", acceptable_fraction);
         if (dct_method != null) desc.SetAttr("dct_method", dct_method);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation StackClose (  Output handle ,String opName= "StackClose" ) 
      {
         OperationDescription desc = NewOperation("StackClose", opName);
         desc.AddInput(handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Exit (  Output data ,String opName= "Exit" ) 
      {
         OperationDescription desc = NewOperation("Exit", opName);
         desc.AddInput(data);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation RefExit (  Output data ,String opName= "RefExit" ) 
      {
         OperationDescription desc = NewOperation("RefExit", opName);
         desc.AddInput(data);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation DeleteSessionTensor (  Output handle ,String opName= "DeleteSessionTensor" ) 
      {
         OperationDescription desc = NewOperation("DeleteSessionTensor", opName);
         desc.AddInput(handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation NextIteration (  Output data ,String opName= "NextIteration" ) 
      {
         OperationDescription desc = NewOperation("NextIteration", opName);
         desc.AddInput(data);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="records">Input to the operation. </param>
      ///<param name="record_defaults">Input to the operation. </param>
      ///<param name="field_delim"></param>
      ///<param name="use_quote_delim"></param>
      ///<param name="na_value"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation DecodeCSV (  Output records , Output record_defaults , string field_delim = null , bool use_quote_delim = true , string na_value = null ,String opName= "DecodeCSV" ) 
      {
         OperationDescription desc = NewOperation("DecodeCSV", opName);
         desc.AddInput(records);
         desc.AddInput(record_defaults);

         if (field_delim != null) desc.SetAttr("field_delim", field_delim);
         if (use_quote_delim != true) desc.SetAttr("use_quote_delim", use_quote_delim);
         if (na_value != null) desc.SetAttr("na_value", na_value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="error_msg"></param>
      ///<param name="exit_without_error"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation Abort (  string error_msg = null , bool exit_without_error = false ,String opName= "Abort" ) 
      {
         OperationDescription desc = NewOperation("Abort", opName);


         if (error_msg != null) desc.SetAttr("error_msg", error_msg);
         if (exit_without_error != false) desc.SetAttr("exit_without_error", exit_without_error);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Sign (  Output x ,String opName= "Sign" ) 
      {
         OperationDescription desc = NewOperation("Sign", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="inputs">Input to the operation. </param>
      ///<param name="labels_indices">Input to the operation. </param>
      ///<param name="labels_values">Input to the operation. </param>
      ///<param name="sequence_length">Input to the operation. </param>
      ///<param name="preprocess_collapse_repeated"></param>
      ///<param name="ctc_merge_repeated"></param>
      ///<param name="ignore_longer_outputs_than_inputs"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] loss(type: DtFloat).
      ///[1] gradient(type: DtFloat).
      ///</return>
      public Operation CTCLoss (  Output inputs , Output labels_indices , Output labels_values , Output sequence_length , bool preprocess_collapse_repeated = false , bool ctc_merge_repeated = true , bool ignore_longer_outputs_than_inputs = false ,String opName= "CTCLoss" ) 
      {
         OperationDescription desc = NewOperation("CTCLoss", opName);
         desc.AddInput(inputs);
         desc.AddInput(labels_indices);
         desc.AddInput(labels_values);
         desc.AddInput(sequence_length);

         if (preprocess_collapse_repeated != false) desc.SetAttr("preprocess_collapse_repeated", preprocess_collapse_repeated);
         if (ctc_merge_repeated != true) desc.SetAttr("ctc_merge_repeated", ctc_merge_repeated);
         if (ignore_longer_outputs_than_inputs != false) desc.SetAttr("ignore_longer_outputs_than_inputs", ignore_longer_outputs_than_inputs);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="inputs">Input to the operation. </param>
      ///<param name="sequence_length">Input to the operation. </param>
      ///<param name="merge_repeated"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] decoded_indices(type: DtInt64).
      ///[1] decoded_values(type: DtInt64).
      ///[2] decoded_shape(type: DtInt64).
      ///[3] log_probability(type: DtFloat).
      ///</return>
      public Operation CTCGreedyDecoder (  Output inputs , Output sequence_length , bool merge_repeated = false ,String opName= "CTCGreedyDecoder" ) 
      {
         OperationDescription desc = NewOperation("CTCGreedyDecoder", opName);
         desc.AddInput(inputs);
         desc.AddInput(sequence_length);

         if (merge_repeated != false) desc.SetAttr("merge_repeated", merge_repeated);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] reader_handle(type: DtResource).
      ///</return>
      public Operation WholeFileReaderV2 (  string container = null , string shared_name = null ,String opName= "WholeFileReaderV2" ) 
      {
         OperationDescription desc = NewOperation("WholeFileReaderV2", opName);


         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="partitions">Input to the operation. </param>
      ///<param name="num_partitions"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] outputs(type: DtInvalid).
      ///</return>
      public Operation DynamicPartition (  Output data , Output partitions , long num_partitions,String opName= "DynamicPartition" ) 
      {
         OperationDescription desc = NewOperation("DynamicPartition", opName);
         desc.AddInput(data);
         desc.AddInput(partitions);
         desc.SetAttr("num_partitions", num_partitions);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="features">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] activations(type: DtInvalid).
      ///</return>
      public Operation Relu6 (  Output features ,String opName= "Relu6" ) 
      {
         OperationDescription desc = NewOperation("Relu6", opName);
         desc.AddInput(features);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="skip_header_lines"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] reader_handle(type: DtString).
      ///</return>
      public Operation TextLineReader (  long skip_header_lines = 0 , string container = null , string shared_name = null ,String opName= "TextLineReader" ) 
      {
         OperationDescription desc = NewOperation("TextLineReader", opName);


         if (skip_header_lines != 0) desc.SetAttr("skip_header_lines", skip_header_lines);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="boundaries"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInt32).
      ///</return>
      public Operation Bucketize (  Output input , float[] boundaries,String opName= "Bucketize" ) 
      {
         OperationDescription desc = NewOperation("Bucketize", opName);
         desc.AddInput(input);
         desc.SetAttr("boundaries", boundaries);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="data">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] merged(type: DtInvalid).
      ///</return>
      public Operation DynamicStitch (  Output indices , Output data ,String opName= "DynamicStitch" ) 
      {
         OperationDescription desc = NewOperation("DynamicStitch", opName);
         desc.AddInput(indices);
         desc.AddInput(data);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reference">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="updates">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_ref(type: DtInvalid).
      ///</return>
      public Operation ScatterNdUpdate (  Output reference , Output indices , Output updates , bool use_locking = true ,String opName= "ScatterNdUpdate" ) 
      {
         OperationDescription desc = NewOperation("ScatterNdUpdate", opName);
         desc.AddInput(reference);
         desc.AddInput(indices);
         desc.AddInput(updates);

         if (use_locking != true) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="component_types"></param>
      ///<param name="shapes"></param>
      ///<param name="capacity"></param>
      ///<param name="min_after_dequeue"></param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtString).
      ///</return>
      public Operation RandomShuffleQueue (  DataType[] component_types, long[][] shapes = null , long capacity = -1 , long min_after_dequeue = 0 , long seed = 0 , long seed2 = 0 , string container = null , string shared_name = null ,String opName= "RandomShuffleQueue" ) 
      {
         OperationDescription desc = NewOperation("RandomShuffleQueue", opName);

         desc.SetAttr("component_types", component_types);
         if (shapes != null) desc.SetAttrShapeList("shapes", shapes);
         if (capacity != -1) desc.SetAttr("capacity", capacity);
         if (min_after_dequeue != 0) desc.SetAttr("min_after_dequeue", min_after_dequeue);
         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///Writes a `Summary` protocol buffer with audio.
      ///</summary>
      ///<param name="writer">Input to the operation: A handle to a summary writer.</param>
      ///<param name="step">Input to the operation: The step to write the summary for.</param>
      ///<param name="tag">Input to the operation: Scalar. Used to build the `tag` attribute of the summary values.</param>
      ///<param name="tensor">Input to the operation: 2-D of shape `[batch_size, frames]`.</param>
      ///<param name="sample_rate">Input to the operation: The sample rate of the signal in hertz.</param>
      ///<param name="max_outputs">Max number of batch elements to generate audio for.</param>
      ///<param name="opName">The name of the operation</param>
      public Operation WriteAudioSummary (  Output writer , Output step , Output tag , Output tensor , Output sample_rate , long max_outputs = 3 ,String opName= "WriteAudioSummary" ) 
      {
         OperationDescription desc = NewOperation("WriteAudioSummary", opName);
         desc.AddInput(writer);
         desc.AddInput(step);
         desc.AddInput(tag);
         desc.AddInput(tensor);
         desc.AddInput(sample_rate);

         if (max_outputs != 3) desc.SetAttr("max_outputs", max_outputs);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="set_indices">Input to the operation. </param>
      ///<param name="set_values">Input to the operation. </param>
      ///<param name="set_shape">Input to the operation. </param>
      ///<param name="validate_indices"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] size(type: DtInt32).
      ///</return>
      public Operation SetSize (  Output set_indices , Output set_values , Output set_shape , bool validate_indices = true ,String opName= "SetSize" ) 
      {
         OperationDescription desc = NewOperation("SetSize", opName);
         desc.AddInput(set_indices);
         desc.AddInput(set_values);
         desc.AddInput(set_shape);

         if (validate_indices != true) desc.SetAttr("validate_indices", validate_indices);
         return desc.FinishOperation();
      } 
      // Skipped function _Recv

      ///<summary>
      ///
      ///</summary>
      ///<param name="component_types"></param>
      ///<param name="shapes"></param>
      ///<param name="capacity"></param>
      ///<param name="min_after_dequeue"></param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtResource).
      ///</return>
      public Operation RandomShuffleQueueV2 (  DataType[] component_types, long[][] shapes = null , long capacity = -1 , long min_after_dequeue = 0 , long seed = 0 , long seed2 = 0 , string container = null , string shared_name = null ,String opName= "RandomShuffleQueueV2" ) 
      {
         OperationDescription desc = NewOperation("RandomShuffleQueueV2", opName);

         desc.SetAttr("component_types", component_types);
         if (shapes != null) desc.SetAttrShapeList("shapes", shapes);
         if (capacity != -1) desc.SetAttr("capacity", capacity);
         if (min_after_dequeue != 0) desc.SetAttr("min_after_dequeue", min_after_dequeue);
         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="num_required">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] average(type: DtInvalid).
      ///</return>
      public Operation AccumulatorTakeGradient (  Output handle , Output num_required , DataType dtype,String opName= "AccumulatorTakeGradient" ) 
      {
         OperationDescription desc = NewOperation("AccumulatorTakeGradient", opName);
         desc.AddInput(handle);
         desc.AddInput(num_required);
         desc.SetAttr("dtype", dtype);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="component_types"></param>
      ///<param name="shapes"></param>
      ///<param name="capacity"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtResource).
      ///</return>
      public Operation FIFOQueueV2 (  DataType[] component_types, long[][] shapes = null , long capacity = -1 , string container = null , string shared_name = null ,String opName= "FIFOQueueV2" ) 
      {
         OperationDescription desc = NewOperation("FIFOQueueV2", opName);

         desc.SetAttr("component_types", component_types);
         if (shapes != null) desc.SetAttrShapeList("shapes", shapes);
         if (capacity != -1) desc.SetAttr("capacity", capacity);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="linear">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="l1">Input to the operation. </param>
      ///<param name="l2">Input to the operation. </param>
      ///<param name="lr_power">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation ApplyFtrl (  Output var , Output accum , Output linear , Output grad , Output lr , Output l1 , Output l2 , Output lr_power , bool use_locking = false ,String opName= "ApplyFtrl" ) 
      {
         OperationDescription desc = NewOperation("ApplyFtrl", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(linear);
         desc.AddInput(grad);
         desc.AddInput(lr);
         desc.AddInput(l1);
         desc.AddInput(l2);
         desc.AddInput(lr_power);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="component_types"></param>
      ///<param name="shapes"></param>
      ///<param name="capacity"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtString).
      ///</return>
      public Operation PaddingFIFOQueue (  DataType[] component_types, long[][] shapes = null , long capacity = -1 , string container = null , string shared_name = null ,String opName= "PaddingFIFOQueue" ) 
      {
         OperationDescription desc = NewOperation("PaddingFIFOQueue", opName);

         desc.SetAttr("component_types", component_types);
         if (shapes != null) desc.SetAttrShapeList("shapes", shapes);
         if (capacity != -1) desc.SetAttr("capacity", capacity);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="linear">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="l1">Input to the operation. </param>
      ///<param name="l2">Input to the operation. </param>
      ///<param name="l2_shrinkage">Input to the operation. </param>
      ///<param name="lr_power">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation ApplyFtrlV2 (  Output var , Output accum , Output linear , Output grad , Output lr , Output l1 , Output l2 , Output l2_shrinkage , Output lr_power , bool use_locking = false ,String opName= "ApplyFtrlV2" ) 
      {
         OperationDescription desc = NewOperation("ApplyFtrlV2", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(linear);
         desc.AddInput(grad);
         desc.AddInput(lr);
         desc.AddInput(l1);
         desc.AddInput(l2);
         desc.AddInput(l2_shrinkage);
         desc.AddInput(lr_power);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="resource">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] is_initialized(type: DtBool).
      ///</return>
      public Operation VarIsInitializedOp (  Output resource ,String opName= "VarIsInitializedOp" ) 
      {
         OperationDescription desc = NewOperation("VarIsInitializedOp", opName);
         desc.AddInput(resource);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="component_types"></param>
      ///<param name="shapes"></param>
      ///<param name="capacity"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtResource).
      ///</return>
      public Operation PaddingFIFOQueueV2 (  DataType[] component_types, long[][] shapes = null , long capacity = -1 , string container = null , string shared_name = null ,String opName= "PaddingFIFOQueueV2" ) 
      {
         OperationDescription desc = NewOperation("PaddingFIFOQueueV2", opName);

         desc.SetAttr("component_types", component_types);
         if (shapes != null) desc.SetAttrShapeList("shapes", shapes);
         if (capacity != -1) desc.SetAttr("capacity", capacity);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation MatrixExponential (  Output input ,String opName= "MatrixExponential" ) 
      {
         OperationDescription desc = NewOperation("MatrixExponential", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="shapes"></param>
      ///<param name="component_types"></param>
      ///<param name="capacity"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtString).
      ///</return>
      public Operation PriorityQueue (  long[][] shapes, DataType[] component_types = null , long capacity = -1 , string container = null , string shared_name = null ,String opName= "PriorityQueue" ) 
      {
         OperationDescription desc = NewOperation("PriorityQueue", opName);

         desc.SetAttrShapeList("shapes", shapes);
         if (component_types != null) desc.SetAttr("component_types", component_types);
         if (capacity != -1) desc.SetAttr("capacity", capacity);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="Tout"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Imag (  Output input , DataType? Tout = null ,String opName= "Imag" ) 
      {
         OperationDescription desc = NewOperation("Imag", opName);
         desc.AddInput(input);

         if (Tout.HasValue) desc.SetAttr("Tout", Tout.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Round (  Output x ,String opName= "Round" ) 
      {
         OperationDescription desc = NewOperation("Round", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="resource">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtString).
      ///</return>
      public Operation FakeQueue (  Output resource ,String opName= "FakeQueue" ) 
      {
         OperationDescription desc = NewOperation("FakeQueue", opName);
         desc.AddInput(resource);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="max_size">Input to the operation. </param>
      ///<param name="elem_type"></param>
      ///<param name="stack_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtResource).
      ///</return>
      public Operation StackV2 (  Output max_size , DataType elem_type, string stack_name = null ,String opName= "StackV2" ) 
      {
         OperationDescription desc = NewOperation("StackV2", opName);
         desc.AddInput(max_size);
         desc.SetAttr("elem_type", elem_type);
         if (stack_name != null) desc.SetAttr("stack_name", stack_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="components">Input to the operation. </param>
      ///<param name="timeout_ms"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation QueueEnqueue (  Output handle , Output components , long timeout_ms = -1 ,String opName= "QueueEnqueue" ) 
      {
         OperationDescription desc = NewOperation("QueueEnqueue", opName);
         desc.AddInput(handle);
         desc.AddInput(components);

         if (timeout_ms != -1) desc.SetAttr("timeout_ms", timeout_ms);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="components">Input to the operation. </param>
      ///<param name="timeout_ms"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation QueueEnqueueV2 (  Output handle , Output components , long timeout_ms = -1 ,String opName= "QueueEnqueueV2" ) 
      {
         OperationDescription desc = NewOperation("QueueEnqueueV2", opName);
         desc.AddInput(handle);
         desc.AddInput(components);

         if (timeout_ms != -1) desc.SetAttr("timeout_ms", timeout_ms);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="components">Input to the operation. </param>
      ///<param name="timeout_ms"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation QueueEnqueueMany (  Output handle , Output components , long timeout_ms = -1 ,String opName= "QueueEnqueueMany" ) 
      {
         OperationDescription desc = NewOperation("QueueEnqueueMany", opName);
         desc.AddInput(handle);
         desc.AddInput(components);

         if (timeout_ms != -1) desc.SetAttr("timeout_ms", timeout_ms);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reader_handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation ReaderResetV2 (  Output reader_handle ,String opName= "ReaderResetV2" ) 
      {
         OperationDescription desc = NewOperation("ReaderResetV2", opName);
         desc.AddInput(reader_handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="components">Input to the operation. </param>
      ///<param name="timeout_ms"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation QueueEnqueueManyV2 (  Output handle , Output components , long timeout_ms = -1 ,String opName= "QueueEnqueueManyV2" ) 
      {
         OperationDescription desc = NewOperation("QueueEnqueueManyV2", opName);
         desc.AddInput(handle);
         desc.AddInput(components);

         if (timeout_ms != -1) desc.SetAttr("timeout_ms", timeout_ms);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="segment_ids">Input to the operation. </param>
      ///<param name="num_segments">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation UnsortedSegmentMax (  Output data , Output segment_ids , Output num_segments ,String opName= "UnsortedSegmentMax" ) 
      {
         OperationDescription desc = NewOperation("UnsortedSegmentMax", opName);
         desc.AddInput(data);
         desc.AddInput(segment_ids);
         desc.AddInput(num_segments);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="component_types"></param>
      ///<param name="timeout_ms"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] components(type: DtInvalid).
      ///</return>
      public Operation QueueDequeue (  Output handle , DataType[] component_types, long timeout_ms = -1 ,String opName= "QueueDequeue" ) 
      {
         OperationDescription desc = NewOperation("QueueDequeue", opName);
         desc.AddInput(handle);
         desc.SetAttr("component_types", component_types);
         if (timeout_ms != -1) desc.SetAttr("timeout_ms", timeout_ms);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="seed">Input to the operation. </param>
      ///<param name="seed2">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation RandomDataset (  Output seed , Output seed2 , DataType[] output_types, long[][] output_shapes,String opName= "RandomDataset" ) 
      {
         OperationDescription desc = NewOperation("RandomDataset", opName);
         desc.AddInput(seed);
         desc.AddInput(seed2);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="component_types"></param>
      ///<param name="timeout_ms"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] components(type: DtInvalid).
      ///</return>
      public Operation QueueDequeueV2 (  Output handle , DataType[] component_types, long timeout_ms = -1 ,String opName= "QueueDequeueV2" ) 
      {
         OperationDescription desc = NewOperation("QueueDequeueV2", opName);
         desc.AddInput(handle);
         desc.SetAttr("component_types", component_types);
         if (timeout_ms != -1) desc.SetAttr("timeout_ms", timeout_ms);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="segment_ids">Input to the operation. </param>
      ///<param name="num_segments">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SparseSegmentSumWithNumSegments (  Output data , Output indices , Output segment_ids , Output num_segments ,String opName= "SparseSegmentSumWithNumSegments" ) 
      {
         OperationDescription desc = NewOperation("SparseSegmentSumWithNumSegments", opName);
         desc.AddInput(data);
         desc.AddInput(indices);
         desc.AddInput(segment_ids);
         desc.AddInput(num_segments);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation TruncateMod (  Output x , Output y ,String opName= "TruncateMod" ) 
      {
         OperationDescription desc = NewOperation("TruncateMod", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="batch_size">Input to the operation. </param>
      ///<param name="row_shape">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation DenseToSparseBatchDataset (  Output input_dataset , Output batch_size , Output row_shape , DataType[] output_types, long[][] output_shapes,String opName= "DenseToSparseBatchDataset" ) 
      {
         OperationDescription desc = NewOperation("DenseToSparseBatchDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(batch_size);
         desc.AddInput(row_shape);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="n">Input to the operation. </param>
      ///<param name="component_types"></param>
      ///<param name="timeout_ms"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] components(type: DtInvalid).
      ///</return>
      public Operation QueueDequeueMany (  Output handle , Output n , DataType[] component_types, long timeout_ms = -1 ,String opName= "QueueDequeueMany" ) 
      {
         OperationDescription desc = NewOperation("QueueDequeueMany", opName);
         desc.AddInput(handle);
         desc.AddInput(n);
         desc.SetAttr("component_types", component_types);
         if (timeout_ms != -1) desc.SetAttr("timeout_ms", timeout_ms);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="n">Input to the operation. </param>
      ///<param name="component_types"></param>
      ///<param name="timeout_ms"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] components(type: DtInvalid).
      ///</return>
      public Operation QueueDequeueUpTo (  Output handle , Output n , DataType[] component_types, long timeout_ms = -1 ,String opName= "QueueDequeueUpTo" ) 
      {
         OperationDescription desc = NewOperation("QueueDequeueUpTo", opName);
         desc.AddInput(handle);
         desc.AddInput(n);
         desc.SetAttr("component_types", component_types);
         if (timeout_ms != -1) desc.SetAttr("timeout_ms", timeout_ms);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="contents">Input to the operation. </param>
      ///<param name="channels"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] image(type: DtUint8).
      ///</return>
      public Operation DecodeBmp (  Output contents , long channels = 0 ,String opName= "DecodeBmp" ) 
      {
         OperationDescription desc = NewOperation("DecodeBmp", opName);
         desc.AddInput(contents);

         if (channels != 0) desc.SetAttr("channels", channels);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="src_format"></param>
      ///<param name="dst_format"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation DataFormatDimMap (  Output x , string src_format = null , string dst_format = null ,String opName= "DataFormatDimMap" ) 
      {
         OperationDescription desc = NewOperation("DataFormatDimMap", opName);
         desc.AddInput(x);

         if (src_format != null) desc.SetAttr("src_format", src_format);
         if (dst_format != null) desc.SetAttr("dst_format", dst_format);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="contents">Input to the operation. </param>
      ///<param name="channels"></param>
      ///<param name="dtype"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] image(type: DtInvalid).
      ///</return>
      public Operation DecodePng (  Output contents , long channels = 0 , DataType? dtype = null ,String opName= "DecodePng" ) 
      {
         OperationDescription desc = NewOperation("DecodePng", opName);
         desc.AddInput(contents);

         if (channels != 0) desc.SetAttr("channels", channels);
         if (dtype.HasValue) desc.SetAttr("dtype", dtype.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="n">Input to the operation. </param>
      ///<param name="component_types"></param>
      ///<param name="timeout_ms"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] components(type: DtInvalid).
      ///</return>
      public Operation QueueDequeueUpToV2 (  Output handle , Output n , DataType[] component_types, long timeout_ms = -1 ,String opName= "QueueDequeueUpToV2" ) 
      {
         OperationDescription desc = NewOperation("QueueDequeueUpToV2", opName);
         desc.AddInput(handle);
         desc.AddInput(n);
         desc.SetAttr("component_types", component_types);
         if (timeout_ms != -1) desc.SetAttr("timeout_ms", timeout_ms);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="cancel_pending_enqueues"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation QueueClose (  Output handle , bool cancel_pending_enqueues = false ,String opName= "QueueClose" ) 
      {
         OperationDescription desc = NewOperation("QueueClose", opName);
         desc.AddInput(handle);

         if (cancel_pending_enqueues != false) desc.SetAttr("cancel_pending_enqueues", cancel_pending_enqueues);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="other_arguments">Input to the operation. </param>
      ///<param name="num_parallel_calls">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      //The following attributes are not known: f: func
      public Operation ParallelMapDataset (  Output input_dataset , Output other_arguments , Output num_parallel_calls , DataType[] output_types, long[][] output_shapes,String opName= "ParallelMapDataset" ) 
      {
         OperationDescription desc = NewOperation("ParallelMapDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(other_arguments);
         desc.AddInput(num_parallel_calls);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_handle">Input to the operation. </param>
      ///<param name="element_dtype"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_handle(type: DtVariant).
      ///[1] tensor(type: DtInvalid).
      ///</return>
      public Operation TensorListPopBack (  Output input_handle , DataType element_dtype,String opName= "TensorListPopBack" ) 
      {
         OperationDescription desc = NewOperation("TensorListPopBack", opName);
         desc.AddInput(input_handle);
         desc.SetAttr("element_dtype", element_dtype);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="cancel_pending_enqueues"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation QueueCloseV2 (  Output handle , bool cancel_pending_enqueues = false ,String opName= "QueueCloseV2" ) 
      {
         OperationDescription desc = NewOperation("QueueCloseV2", opName);
         desc.AddInput(handle);

         if (cancel_pending_enqueues != false) desc.SetAttr("cancel_pending_enqueues", cancel_pending_enqueues);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="images">Input to the operation. </param>
      ///<param name="contrast_factor">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtFloat).
      ///</return>
      public Operation AdjustContrastv2 (  Output images , Output contrast_factor ,String opName= "AdjustContrastv2" ) 
      {
         OperationDescription desc = NewOperation("AdjustContrastv2", opName);
         desc.AddInput(images);
         desc.AddInput(contrast_factor);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] is_closed(type: DtBool).
      ///</return>
      public Operation QueueIsClosed (  Output handle ,String opName= "QueueIsClosed" ) 
      {
         OperationDescription desc = NewOperation("QueueIsClosed", opName);
         desc.AddInput(handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] is_closed(type: DtBool).
      ///</return>
      public Operation QueueIsClosedV2 (  Output handle ,String opName= "QueueIsClosedV2" ) 
      {
         OperationDescription desc = NewOperation("QueueIsClosedV2", opName);
         desc.AddInput(handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] size(type: DtInt32).
      ///</return>
      public Operation QueueSize (  Output handle ,String opName= "QueueSize" ) 
      {
         OperationDescription desc = NewOperation("QueueSize", opName);
         desc.AddInput(handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] size(type: DtInt32).
      ///</return>
      public Operation QueueSizeV2 (  Output handle ,String opName= "QueueSizeV2" ) 
      {
         OperationDescription desc = NewOperation("QueueSizeV2", opName);
         desc.AddInput(handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="segment_ids">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SegmentProd (  Output data , Output segment_ids ,String opName= "SegmentProd" ) 
      {
         OperationDescription desc = NewOperation("SegmentProd", opName);
         desc.AddInput(data);
         desc.AddInput(segment_ids);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] num_accumulated(type: DtInt32).
      ///</return>
      public Operation AccumulatorNumAccumulated (  Output handle ,String opName= "AccumulatorNumAccumulated" ) 
      {
         OperationDescription desc = NewOperation("AccumulatorNumAccumulated", opName);
         desc.AddInput(handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="filename">Input to the operation. </param>
      ///<param name="tensor_names">Input to the operation. </param>
      ///<param name="shapes_and_slices">Input to the operation. </param>
      ///<param name="data">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation SaveSlices (  Output filename , Output tensor_names , Output shapes_and_slices , Output data ,String opName= "SaveSlices" ) 
      {
         OperationDescription desc = NewOperation("SaveSlices", opName);
         desc.AddInput(filename);
         desc.AddInput(tensor_names);
         desc.AddInput(shapes_and_slices);
         desc.AddInput(data);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="dtype"></param>
      ///<param name="shape"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtString).
      ///</return>
      public Operation ConditionalAccumulator (  DataType dtype, long[] shape, string container = null , string shared_name = null ,String opName= "ConditionalAccumulator" ) 
      {
         OperationDescription desc = NewOperation("ConditionalAccumulator", opName);

         desc.SetAttr("dtype", dtype);
         desc.SetAttrShape("shape", shape);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="local_step">Input to the operation. </param>
      ///<param name="gradient">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation AccumulatorApplyGradient (  Output handle , Output local_step , Output gradient ,String opName= "AccumulatorApplyGradient" ) 
      {
         OperationDescription desc = NewOperation("AccumulatorApplyGradient", opName);
         desc.AddInput(handle);
         desc.AddInput(local_step);
         desc.AddInput(gradient);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="m">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="alpha">Input to the operation. </param>
      ///<param name="sign_decay">Input to the operation. </param>
      ///<param name="beta">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation ApplyAddSign (  Output var , Output m , Output lr , Output alpha , Output sign_decay , Output beta , Output grad , bool use_locking = false ,String opName= "ApplyAddSign" ) 
      {
         OperationDescription desc = NewOperation("ApplyAddSign", opName);
         desc.AddInput(var);
         desc.AddInput(m);
         desc.AddInput(lr);
         desc.AddInput(alpha);
         desc.AddInput(sign_decay);
         desc.AddInput(beta);
         desc.AddInput(grad);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="dtype"></param>
      ///<param name="shape"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtString).
      ///</return>
      public Operation SparseConditionalAccumulator (  DataType dtype, long[] shape, string container = null , string shared_name = null ,String opName= "SparseConditionalAccumulator" ) 
      {
         OperationDescription desc = NewOperation("SparseConditionalAccumulator", opName);

         desc.SetAttr("dtype", dtype);
         desc.SetAttrShape("shape", shape);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtBool).
      ///</return>
      public Operation GreaterEqual (  Output x , Output y ,String opName= "GreaterEqual" ) 
      {
         OperationDescription desc = NewOperation("GreaterEqual", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="local_step">Input to the operation. </param>
      ///<param name="gradient_indices">Input to the operation. </param>
      ///<param name="gradient_values">Input to the operation. </param>
      ///<param name="gradient_shape">Input to the operation. </param>
      ///<param name="has_known_shape"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation SparseAccumulatorApplyGradient (  Output handle , Output local_step , Output gradient_indices , Output gradient_values , Output gradient_shape , bool has_known_shape,String opName= "SparseAccumulatorApplyGradient" ) 
      {
         OperationDescription desc = NewOperation("SparseAccumulatorApplyGradient", opName);
         desc.AddInput(handle);
         desc.AddInput(local_step);
         desc.AddInput(gradient_indices);
         desc.AddInput(gradient_values);
         desc.AddInput(gradient_shape);
         desc.SetAttr("has_known_shape", has_known_shape);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="elem_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] elem(type: DtInvalid).
      ///</return>
      public Operation StackPopV2 (  Output handle , DataType elem_type,String opName= "StackPopV2" ) 
      {
         OperationDescription desc = NewOperation("StackPopV2", opName);
         desc.AddInput(handle);
         desc.SetAttr("elem_type", elem_type);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="count">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation RepeatDataset (  Output input_dataset , Output count , DataType[] output_types, long[][] output_shapes,String opName= "RepeatDataset" ) 
      {
         OperationDescription desc = NewOperation("RepeatDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(count);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation StackCloseV2 (  Output handle ,String opName= "StackCloseV2" ) 
      {
         OperationDescription desc = NewOperation("StackCloseV2", opName);
         desc.AddInput(handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="mg">Input to the operation. </param>
      ///<param name="ms">Input to the operation. </param>
      ///<param name="mom">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="rho">Input to the operation. </param>
      ///<param name="momentum">Input to the operation. </param>
      ///<param name="epsilon">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceSparseApplyCenteredRMSProp (  Output var , Output mg , Output ms , Output mom , Output lr , Output rho , Output momentum , Output epsilon , Output grad , Output indices , bool use_locking = false ,String opName= "ResourceSparseApplyCenteredRMSProp" ) 
      {
         OperationDescription desc = NewOperation("ResourceSparseApplyCenteredRMSProp", opName);
         desc.AddInput(var);
         desc.AddInput(mg);
         desc.AddInput(ms);
         desc.AddInput(mom);
         desc.AddInput(lr);
         desc.AddInput(rho);
         desc.AddInput(momentum);
         desc.AddInput(epsilon);
         desc.AddInput(grad);
         desc.AddInput(indices);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="size">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="element_shape"></param>
      ///<param name="dynamic_size"></param>
      ///<param name="clear_after_read"></param>
      ///<param name="identical_element_shapes"></param>
      ///<param name="tensor_array_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtResource).
      ///[1] flow(type: DtFloat).
      ///</return>
      public Operation TensorArrayV3 (  Output size , DataType dtype, long[] element_shape = null , bool dynamic_size = false , bool clear_after_read = true , bool identical_element_shapes = false , string tensor_array_name = null ,String opName= "TensorArrayV3" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayV3", opName);
         desc.AddInput(size);
         desc.SetAttr("dtype", dtype);
         if (element_shape != null) desc.SetAttrShape("element_shape", element_shape);
         if (dynamic_size != false) desc.SetAttr("dynamic_size", dynamic_size);
         if (clear_after_read != true) desc.SetAttr("clear_after_read", clear_after_read);
         if (identical_element_shapes != false) desc.SetAttr("identical_element_shapes", identical_element_shapes);
         if (tensor_array_name != null) desc.SetAttr("tensor_array_name", tensor_array_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="source"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] grad_handle(type: DtResource).
      ///[1] flow_out(type: DtFloat).
      ///</return>
      public Operation TensorArrayGradV3 (  Output handle , Output flow_in , string source,String opName= "TensorArrayGradV3" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayGradV3", opName);
         desc.AddInput(handle);
         desc.AddInput(flow_in);
         desc.SetAttr("source", source);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="index">Input to the operation. </param>
      ///<param name="value">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] flow_out(type: DtFloat).
      ///</return>
      public Operation TensorArrayWriteV3 (  Output handle , Output index , Output value , Output flow_in ,String opName= "TensorArrayWriteV3" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayWriteV3", opName);
         desc.AddInput(handle);
         desc.AddInput(index);
         desc.AddInput(value);
         desc.AddInput(flow_in);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="index">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] value(type: DtInvalid).
      ///</return>
      public Operation TensorArrayReadV3 (  Output handle , Output index , Output flow_in , DataType dtype,String opName= "TensorArrayReadV3" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayReadV3", opName);
         desc.AddInput(handle);
         desc.AddInput(index);
         desc.AddInput(flow_in);
         desc.SetAttr("dtype", dtype);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="element_shape"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] value(type: DtInvalid).
      ///</return>
      public Operation TensorArrayGatherV3 (  Output handle , Output indices , Output flow_in , DataType dtype, long[] element_shape = null ,String opName= "TensorArrayGatherV3" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayGatherV3", opName);
         desc.AddInput(handle);
         desc.AddInput(indices);
         desc.AddInput(flow_in);
         desc.SetAttr("dtype", dtype);
         if (element_shape != null) desc.SetAttrShape("element_shape", element_shape);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] size(type: DtInt32).
      ///</return>
      public Operation BarrierReadySize (  Output handle ,String opName= "BarrierReadySize" ) 
      {
         OperationDescription desc = NewOperation("BarrierReadySize", opName);
         desc.AddInput(handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="orig_input">Input to the operation. </param>
      ///<param name="orig_output">Input to the operation. </param>
      ///<param name="out_backprop">Input to the operation. </param>
      ///<param name="row_pooling_sequence">Input to the operation. </param>
      ///<param name="col_pooling_sequence">Input to the operation. </param>
      ///<param name="overlapping"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation FractionalMaxPoolGrad (  Output orig_input , Output orig_output , Output out_backprop , Output row_pooling_sequence , Output col_pooling_sequence , bool overlapping = false ,String opName= "FractionalMaxPoolGrad" ) 
      {
         OperationDescription desc = NewOperation("FractionalMaxPoolGrad", opName);
         desc.AddInput(orig_input);
         desc.AddInput(orig_output);
         desc.AddInput(out_backprop);
         desc.AddInput(row_pooling_sequence);
         desc.AddInput(col_pooling_sequence);

         if (overlapping != false) desc.SetAttr("overlapping", overlapping);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="value">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] flow_out(type: DtFloat).
      ///</return>
      public Operation TensorArrayScatterV3 (  Output handle , Output indices , Output value , Output flow_in ,String opName= "TensorArrayScatterV3" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayScatterV3", opName);
         desc.AddInput(handle);
         desc.AddInput(indices);
         desc.AddInput(value);
         desc.AddInput(flow_in);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation RealDiv (  Output x , Output y ,String opName= "RealDiv" ) 
      {
         OperationDescription desc = NewOperation("RealDiv", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation TensorArrayCloseV3 (  Output handle ,String opName= "TensorArrayCloseV3" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayCloseV3", opName);
         desc.AddInput(handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="orig_input_shape">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="ksize"></param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="data_format"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation AvgPoolGrad (  Output orig_input_shape , Output grad , long[] ksize, long[] strides, string padding, string data_format = null ,String opName= "AvgPoolGrad" ) 
      {
         OperationDescription desc = NewOperation("AvgPoolGrad", opName);
         desc.AddInput(orig_input_shape);
         desc.AddInput(grad);
         desc.SetAttr("ksize", ksize);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="size">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="element_shape"></param>
      ///<param name="dynamic_size"></param>
      ///<param name="clear_after_read"></param>
      ///<param name="tensor_array_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtString).
      ///</return>
      public Operation TensorArrayV2 (  Output size , DataType dtype, long[] element_shape = null , bool dynamic_size = false , bool clear_after_read = true , string tensor_array_name = null ,String opName= "TensorArrayV2" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayV2", opName);
         desc.AddInput(size);
         desc.SetAttr("dtype", dtype);
         if (element_shape != null) desc.SetAttrShape("element_shape", element_shape);
         if (dynamic_size != false) desc.SetAttr("dynamic_size", dynamic_size);
         if (clear_after_read != true) desc.SetAttr("clear_after_read", clear_after_read);
         if (tensor_array_name != null) desc.SetAttr("tensor_array_name", tensor_array_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="source"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] grad_handle(type: DtString).
      ///</return>
      public Operation TensorArrayGradV2 (  Output handle , Output flow_in , string source,String opName= "TensorArrayGradV2" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayGradV2", opName);
         desc.AddInput(handle);
         desc.AddInput(flow_in);
         desc.SetAttr("source", source);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="segment_ids">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SegmentSum (  Output data , Output segment_ids ,String opName= "SegmentSum" ) 
      {
         OperationDescription desc = NewOperation("SegmentSum", opName);
         desc.AddInput(data);
         desc.AddInput(segment_ids);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="index">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] value(type: DtInvalid).
      ///</return>
      public Operation TensorArrayRead (  Output handle , Output index , Output flow_in , DataType dtype,String opName= "TensorArrayRead" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayRead", opName);
         desc.AddInput(handle);
         desc.AddInput(index);
         desc.AddInput(flow_in);
         desc.SetAttr("dtype", dtype);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Floor (  Output x ,String opName= "Floor" ) 
      {
         OperationDescription desc = NewOperation("Floor", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="index">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] value(type: DtInvalid).
      ///</return>
      public Operation TensorArrayReadV2 (  Output handle , Output index , Output flow_in , DataType dtype,String opName= "TensorArrayReadV2" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayReadV2", opName);
         desc.AddInput(handle);
         desc.AddInput(index);
         desc.AddInput(flow_in);
         desc.SetAttr("dtype", dtype);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="element_shape"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] value(type: DtInvalid).
      ///</return>
      public Operation TensorArrayPack (  Output handle , Output flow_in , DataType dtype, long[] element_shape = null ,String opName= "TensorArrayPack" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayPack", opName);
         desc.AddInput(handle);
         desc.AddInput(flow_in);
         desc.SetAttr("dtype", dtype);
         if (element_shape != null) desc.SetAttrShape("element_shape", element_shape);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="element_shape"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] value(type: DtInvalid).
      ///</return>
      public Operation TensorArrayGather (  Output handle , Output indices , Output flow_in , DataType dtype, long[] element_shape = null ,String opName= "TensorArrayGather" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayGather", opName);
         desc.AddInput(handle);
         desc.AddInput(indices);
         desc.AddInput(flow_in);
         desc.SetAttr("dtype", dtype);
         if (element_shape != null) desc.SetAttrShape("element_shape", element_shape);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="buffer_size">Input to the operation. </param>
      ///<param name="seed">Input to the operation. </param>
      ///<param name="seed2">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="reshuffle_each_iteration"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation ShuffleDataset (  Output input_dataset , Output buffer_size , Output seed , Output seed2 , DataType[] output_types, long[][] output_shapes, bool reshuffle_each_iteration = true ,String opName= "ShuffleDataset" ) 
      {
         OperationDescription desc = NewOperation("ShuffleDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(buffer_size);
         desc.AddInput(seed);
         desc.AddInput(seed2);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);
         if (reshuffle_each_iteration != true) desc.SetAttr("reshuffle_each_iteration", reshuffle_each_iteration);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="element_shape"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] value(type: DtInvalid).
      ///</return>
      public Operation TensorArrayGatherV2 (  Output handle , Output indices , Output flow_in , DataType dtype, long[] element_shape = null ,String opName= "TensorArrayGatherV2" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayGatherV2", opName);
         desc.AddInput(handle);
         desc.AddInput(indices);
         desc.AddInput(flow_in);
         desc.SetAttr("dtype", dtype);
         if (element_shape != null) desc.SetAttrShape("element_shape", element_shape);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="value">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] flow_out(type: DtFloat).
      ///</return>
      public Operation TensorArrayScatterV2 (  Output handle , Output indices , Output value , Output flow_in ,String opName= "TensorArrayScatterV2" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayScatterV2", opName);
         desc.AddInput(handle);
         desc.AddInput(indices);
         desc.AddInput(value);
         desc.AddInput(flow_in);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_sizes">Input to the operation. </param>
      ///<param name="filter">Input to the operation. </param>
      ///<param name="out_backprop">Input to the operation. </param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="use_cudnn_on_gpu"></param>
      ///<param name="data_format"></param>
      ///<param name="dilations"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Conv2DBackpropInput (  Output input_sizes , Output filter , Output out_backprop , long[] strides, string padding, bool use_cudnn_on_gpu = true , string data_format = null , long[] dilations = null ,String opName= "Conv2DBackpropInput" ) 
      {
         OperationDescription desc = NewOperation("Conv2DBackpropInput", opName);
         desc.AddInput(input_sizes);
         desc.AddInput(filter);
         desc.AddInput(out_backprop);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);
         if (use_cudnn_on_gpu != true) desc.SetAttr("use_cudnn_on_gpu", use_cudnn_on_gpu);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         if (dilations != null) desc.SetAttr("dilations", dilations);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="a">Input to the operation. </param>
      ///<param name="b">Input to the operation. </param>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation Betainc (  Output a , Output b , Output x ,String opName= "Betainc" ) 
      {
         OperationDescription desc = NewOperation("Betainc", opName);
         desc.AddInput(a);
         desc.AddInput(b);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="driver_name">Input to the operation. </param>
      ///<param name="data_source_name">Input to the operation. </param>
      ///<param name="query">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation SqlDataset (  Output driver_name , Output data_source_name , Output query , DataType[] output_types, long[][] output_shapes,String opName= "SqlDataset" ) 
      {
         OperationDescription desc = NewOperation("SqlDataset", opName);
         desc.AddInput(driver_name);
         desc.AddInput(data_source_name);
         desc.AddInput(query);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="pattern">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] filenames(type: DtString).
      ///</return>
      public Operation MatchingFiles (  Output pattern ,String opName= "MatchingFiles" ) 
      {
         OperationDescription desc = NewOperation("MatchingFiles", opName);
         desc.AddInput(pattern);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="element_shape_except0"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] value(type: DtInvalid).
      ///[1] lengths(type: DtInt64).
      ///</return>
      public Operation TensorArrayConcatV2 (  Output handle , Output flow_in , DataType dtype, long[] element_shape_except0 = null ,String opName= "TensorArrayConcatV2" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayConcatV2", opName);
         desc.AddInput(handle);
         desc.AddInput(flow_in);
         desc.SetAttr("dtype", dtype);
         if (element_shape_except0 != null) desc.SetAttrShape("element_shape_except0", element_shape_except0);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="dtypes"></param>
      ///<param name="capacity"></param>
      ///<param name="memory_limit"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation OrderedMapClear (  DataType[] dtypes, long capacity = 0 , long memory_limit = 0 , string container = null , string shared_name = null ,String opName= "OrderedMapClear" ) 
      {
         OperationDescription desc = NewOperation("OrderedMapClear", opName);

         desc.SetAttr("dtypes", dtypes);
         if (capacity != 0) desc.SetAttr("capacity", capacity);
         if (memory_limit != 0) desc.SetAttr("memory_limit", memory_limit);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="ksize">Input to the operation. </param>
      ///<param name="strides">Input to the operation. </param>
      ///<param name="padding"></param>
      ///<param name="data_format"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation MaxPoolV2 (  Output input , Output ksize , Output strides , string padding, string data_format = null ,String opName= "MaxPoolV2" ) 
      {
         OperationDescription desc = NewOperation("MaxPoolV2", opName);
         desc.AddInput(input);
         desc.AddInput(ksize);
         desc.AddInput(strides);
         desc.SetAttr("padding", padding);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="y">Input to the operation. </param>
      ///<param name="dy">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation SqrtGrad (  Output y , Output dy ,String opName= "SqrtGrad" ) 
      {
         OperationDescription desc = NewOperation("SqrtGrad", opName);
         desc.AddInput(y);
         desc.AddInput(dy);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="value">Input to the operation. </param>
      ///<param name="lengths">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] flow_out(type: DtFloat).
      ///</return>
      public Operation TensorArraySplitV2 (  Output handle , Output value , Output lengths , Output flow_in ,String opName= "TensorArraySplitV2" ) 
      {
         OperationDescription desc = NewOperation("TensorArraySplitV2", opName);
         desc.AddInput(handle);
         desc.AddInput(value);
         desc.AddInput(lengths);
         desc.AddInput(flow_in);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] size(type: DtInt32).
      ///</return>
      public Operation TensorArraySizeV2 (  Output handle , Output flow_in ,String opName= "TensorArraySizeV2" ) 
      {
         OperationDescription desc = NewOperation("TensorArraySizeV2", opName);
         desc.AddInput(handle);
         desc.AddInput(flow_in);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///Writes a `Summary` protocol buffer with a histogram.
      ///</summary>
      ///<param name="writer">Input to the operation: A handle to a summary writer.</param>
      ///<param name="step">Input to the operation: The step to write the summary for.</param>
      ///<param name="tag">Input to the operation: Scalar.  Tag to use for the `Summary.Value`.</param>
      ///<param name="values">Input to the operation: Any shape. Values to use to build the histogram.</param>
      ///<param name="opName">The name of the operation</param>
      public Operation WriteHistogramSummary (  Output writer , Output step , Output tag , Output values ,String opName= "WriteHistogramSummary" ) 
      {
         OperationDescription desc = NewOperation("WriteHistogramSummary", opName);
         desc.AddInput(writer);
         desc.AddInput(step);
         desc.AddInput(tag);
         desc.AddInput(values);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="keys">Input to the operation. </param>
      ///<param name="values">Input to the operation. </param>
      ///<param name="component_index"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation BarrierInsertMany (  Output handle , Output keys , Output values , long component_index,String opName= "BarrierInsertMany" ) 
      {
         OperationDescription desc = NewOperation("BarrierInsertMany", opName);
         desc.AddInput(handle);
         desc.AddInput(keys);
         desc.AddInput(values);
         desc.SetAttr("component_index", component_index);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="num_elements">Input to the operation. </param>
      ///<param name="component_types"></param>
      ///<param name="allow_small_batch"></param>
      ///<param name="wait_for_incomplete"></param>
      ///<param name="timeout_ms"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] indices(type: DtInt64).
      ///[1] keys(type: DtString).
      ///[2] values(type: DtInvalid).
      ///</return>
      public Operation BarrierTakeMany (  Output handle , Output num_elements , DataType[] component_types, bool allow_small_batch = false , bool wait_for_incomplete = false , long timeout_ms = -1 ,String opName= "BarrierTakeMany" ) 
      {
         OperationDescription desc = NewOperation("BarrierTakeMany", opName);
         desc.AddInput(handle);
         desc.AddInput(num_elements);
         desc.SetAttr("component_types", component_types);
         if (allow_small_batch != false) desc.SetAttr("allow_small_batch", allow_small_batch);
         if (wait_for_incomplete != false) desc.SetAttr("wait_for_incomplete", wait_for_incomplete);
         if (timeout_ms != -1) desc.SetAttr("timeout_ms", timeout_ms);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="cancel_pending_enqueues"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation BarrierClose (  Output handle , bool cancel_pending_enqueues = false ,String opName= "BarrierClose" ) 
      {
         OperationDescription desc = NewOperation("BarrierClose", opName);
         desc.AddInput(handle);

         if (cancel_pending_enqueues != false) desc.SetAttr("cancel_pending_enqueues", cancel_pending_enqueues);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] size(type: DtInt32).
      ///</return>
      public Operation BarrierIncompleteSize (  Output handle ,String opName= "BarrierIncompleteSize" ) 
      {
         OperationDescription desc = NewOperation("BarrierIncompleteSize", opName);
         desc.AddInput(handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="value">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtString).
      ///</return>
      public Operation GetSessionHandle (  Output value ,String opName= "GetSessionHandle" ) 
      {
         OperationDescription desc = NewOperation("GetSessionHandle", opName);
         desc.AddInput(value);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="value">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtResource).
      ///</return>
      public Operation GetSessionHandleV2 (  Output value ,String opName= "GetSessionHandleV2" ) 
      {
         OperationDescription desc = NewOperation("GetSessionHandleV2", opName);
         desc.AddInput(value);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="serialized_sparse">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] sparse_indices(type: DtInt64).
      ///[1] sparse_values(type: DtInvalid).
      ///[2] sparse_shape(type: DtInt64).
      ///</return>
      public Operation DeserializeSparse (  Output serialized_sparse , DataType dtype,String opName= "DeserializeSparse" ) 
      {
         OperationDescription desc = NewOperation("DeserializeSparse", opName);
         desc.AddInput(serialized_sparse);
         desc.SetAttr("dtype", dtype);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="adjoint"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation MatrixInverse (  Output input , bool adjoint = false ,String opName= "MatrixInverse" ) 
      {
         OperationDescription desc = NewOperation("MatrixInverse", opName);
         desc.AddInput(input);

         if (adjoint != false) desc.SetAttr("adjoint", adjoint);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] value(type: DtInvalid).
      ///</return>
      public Operation GetSessionTensor (  Output handle , DataType dtype,String opName= "GetSessionTensor" ) 
      {
         OperationDescription desc = NewOperation("GetSessionTensor", opName);
         desc.AddInput(handle);
         desc.SetAttr("dtype", dtype);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="condition">Input to the operation. </param>
      ///<param name="t">Input to the operation. </param>
      ///<param name="e">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Select (  Output condition , Output t , Output e ,String opName= "Select" ) 
      {
         OperationDescription desc = NewOperation("Select", opName);
         desc.AddInput(condition);
         desc.AddInput(t);
         desc.AddInput(e);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="values">Input to the operation. </param>
      ///<param name="capacity"></param>
      ///<param name="memory_limit"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation Stage (  Output values , long capacity = 0 , long memory_limit = 0 , string container = null , string shared_name = null ,String opName= "Stage" ) 
      {
         OperationDescription desc = NewOperation("Stage", opName);
         desc.AddInput(values);

         if (capacity != 0) desc.SetAttr("capacity", capacity);
         if (memory_limit != 0) desc.SetAttr("memory_limit", memory_limit);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="dtypes"></param>
      ///<param name="capacity"></param>
      ///<param name="memory_limit"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] values(type: DtInvalid).
      ///</return>
      public Operation Unstage (  DataType[] dtypes, long capacity = 0 , long memory_limit = 0 , string container = null , string shared_name = null ,String opName= "Unstage" ) 
      {
         OperationDescription desc = NewOperation("Unstage", opName);

         desc.SetAttr("dtypes", dtypes);
         if (capacity != 0) desc.SetAttr("capacity", capacity);
         if (memory_limit != 0) desc.SetAttr("memory_limit", memory_limit);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="index">Input to the operation. </param>
      ///<param name="dtypes"></param>
      ///<param name="capacity"></param>
      ///<param name="memory_limit"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] values(type: DtInvalid).
      ///</return>
      public Operation StagePeek (  Output index , DataType[] dtypes, long capacity = 0 , long memory_limit = 0 , string container = null , string shared_name = null ,String opName= "StagePeek" ) 
      {
         OperationDescription desc = NewOperation("StagePeek", opName);
         desc.AddInput(index);
         desc.SetAttr("dtypes", dtypes);
         if (capacity != 0) desc.SetAttr("capacity", capacity);
         if (memory_limit != 0) desc.SetAttr("memory_limit", memory_limit);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="dtypes"></param>
      ///<param name="capacity"></param>
      ///<param name="memory_limit"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] size(type: DtInt32).
      ///</return>
      public Operation StageSize (  DataType[] dtypes, long capacity = 0 , long memory_limit = 0 , string container = null , string shared_name = null ,String opName= "StageSize" ) 
      {
         OperationDescription desc = NewOperation("StageSize", opName);

         desc.SetAttr("dtypes", dtypes);
         if (capacity != 0) desc.SetAttr("capacity", capacity);
         if (memory_limit != 0) desc.SetAttr("memory_limit", memory_limit);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///Creates a summary file writer accessible by the given resource handle.
      ///</summary>
      ///<param name="writer">Input to the operation: A handle to the summary writer resource</param>
      ///<param name="logdir">Input to the operation: Directory where the event file will be written.</param>
      ///<param name="max_queue">Input to the operation: Size of the queue of pending events and summaries.</param>
      ///<param name="flush_millis">Input to the operation: How often, in milliseconds, to flush the pending events and summaries to disk.</param>
      ///<param name="filename_suffix">Input to the operation: Every event file's name is suffixed with this suffix.</param>
      ///<param name="opName">The name of the operation</param>
      public Operation CreateSummaryFileWriter (  Output writer , Output logdir , Output max_queue , Output flush_millis , Output filename_suffix ,String opName= "CreateSummaryFileWriter" ) 
      {
         OperationDescription desc = NewOperation("CreateSummaryFileWriter", opName);
         desc.AddInput(writer);
         desc.AddInput(logdir);
         desc.AddInput(max_queue);
         desc.AddInput(flush_millis);
         desc.AddInput(filename_suffix);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Asinh (  Output x ,String opName= "Asinh" ) 
      {
         OperationDescription desc = NewOperation("Asinh", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="dtypes"></param>
      ///<param name="capacity"></param>
      ///<param name="memory_limit"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation StageClear (  DataType[] dtypes, long capacity = 0 , long memory_limit = 0 , string container = null , string shared_name = null ,String opName= "StageClear" ) 
      {
         OperationDescription desc = NewOperation("StageClear", opName);

         desc.SetAttr("dtypes", dtypes);
         if (capacity != 0) desc.SetAttr("capacity", capacity);
         if (memory_limit != 0) desc.SetAttr("memory_limit", memory_limit);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="key">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="dtypes"></param>
      ///<param name="capacity"></param>
      ///<param name="memory_limit"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] values(type: DtInvalid).
      ///</return>
      public Operation MapPeek (  Output key , Output indices , DataType[] dtypes, long capacity = 0 , long memory_limit = 0 , string container = null , string shared_name = null ,String opName= "MapPeek" ) 
      {
         OperationDescription desc = NewOperation("MapPeek", opName);
         desc.AddInput(key);
         desc.AddInput(indices);
         desc.SetAttr("dtypes", dtypes);
         if (capacity != 0) desc.SetAttr("capacity", capacity);
         if (memory_limit != 0) desc.SetAttr("memory_limit", memory_limit);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="sparse_indices">Input to the operation. </param>
      ///<param name="sparse_values">Input to the operation. </param>
      ///<param name="sparse_shape">Input to the operation. </param>
      ///<param name="out_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] serialized_sparse(type: DtInvalid).
      ///</return>
      public Operation SerializeSparse (  Output sparse_indices , Output sparse_values , Output sparse_shape , DataType? out_type = null ,String opName= "SerializeSparse" ) 
      {
         OperationDescription desc = NewOperation("SerializeSparse", opName);
         desc.AddInput(sparse_indices);
         desc.AddInput(sparse_values);
         desc.AddInput(sparse_shape);

         if (out_type.HasValue) desc.SetAttr("out_type", out_type.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="compute_v"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] e(type: DtInvalid).
      ///[1] v(type: DtInvalid).
      ///</return>
      public Operation SelfAdjointEigV2 (  Output input , bool compute_v = true ,String opName= "SelfAdjointEigV2" ) 
      {
         OperationDescription desc = NewOperation("SelfAdjointEigV2", opName);
         desc.AddInput(input);

         if (compute_v != true) desc.SetAttr("compute_v", compute_v);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="key">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="values">Input to the operation. </param>
      ///<param name="dtypes"></param>
      ///<param name="capacity"></param>
      ///<param name="memory_limit"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation MapStage (  Output key , Output indices , Output values , DataType[] dtypes, long capacity = 0 , long memory_limit = 0 , string container = null , string shared_name = null ,String opName= "MapStage" ) 
      {
         OperationDescription desc = NewOperation("MapStage", opName);
         desc.AddInput(key);
         desc.AddInput(indices);
         desc.AddInput(values);
         desc.SetAttr("dtypes", dtypes);
         if (capacity != 0) desc.SetAttr("capacity", capacity);
         if (memory_limit != 0) desc.SetAttr("memory_limit", memory_limit);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="key">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="dtypes"></param>
      ///<param name="capacity"></param>
      ///<param name="memory_limit"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] values(type: DtInvalid).
      ///</return>
      public Operation MapUnstage (  Output key , Output indices , DataType[] dtypes, long capacity = 0 , long memory_limit = 0 , string container = null , string shared_name = null ,String opName= "MapUnstage" ) 
      {
         OperationDescription desc = NewOperation("MapUnstage", opName);
         desc.AddInput(key);
         desc.AddInput(indices);
         desc.SetAttr("dtypes", dtypes);
         if (capacity != 0) desc.SetAttr("capacity", capacity);
         if (memory_limit != 0) desc.SetAttr("memory_limit", memory_limit);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="dtypes"></param>
      ///<param name="capacity"></param>
      ///<param name="memory_limit"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] key(type: DtInt64).
      ///[1] values(type: DtInvalid).
      ///</return>
      public Operation MapUnstageNoKey (  Output indices , DataType[] dtypes, long capacity = 0 , long memory_limit = 0 , string container = null , string shared_name = null ,String opName= "MapUnstageNoKey" ) 
      {
         OperationDescription desc = NewOperation("MapUnstageNoKey", opName);
         desc.AddInput(indices);
         desc.SetAttr("dtypes", dtypes);
         if (capacity != 0) desc.SetAttr("capacity", capacity);
         if (memory_limit != 0) desc.SetAttr("memory_limit", memory_limit);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="string_handle">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] resource_handle(type: DtResource).
      ///</return>
      public Operation IteratorFromStringHandle (  Output string_handle , DataType[] output_types = null , long[][] output_shapes = null ,String opName= "IteratorFromStringHandle" ) 
      {
         OperationDescription desc = NewOperation("IteratorFromStringHandle", opName);
         desc.AddInput(string_handle);

         if (output_types != null) desc.SetAttr("output_types", output_types);
         if (output_shapes != null) desc.SetAttrShapeList("output_shapes", output_shapes);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="dtypes"></param>
      ///<param name="capacity"></param>
      ///<param name="memory_limit"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] size(type: DtInt32).
      ///</return>
      public Operation MapSize (  DataType[] dtypes, long capacity = 0 , long memory_limit = 0 , string container = null , string shared_name = null ,String opName= "MapSize" ) 
      {
         OperationDescription desc = NewOperation("MapSize", opName);

         desc.SetAttr("dtypes", dtypes);
         if (capacity != 0) desc.SetAttr("capacity", capacity);
         if (memory_limit != 0) desc.SetAttr("memory_limit", memory_limit);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="dtypes"></param>
      ///<param name="capacity"></param>
      ///<param name="memory_limit"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation MapClear (  DataType[] dtypes, long capacity = 0 , long memory_limit = 0 , string container = null , string shared_name = null ,String opName= "MapClear" ) 
      {
         OperationDescription desc = NewOperation("MapClear", opName);

         desc.SetAttr("dtypes", dtypes);
         if (capacity != 0) desc.SetAttr("capacity", capacity);
         if (memory_limit != 0) desc.SetAttr("memory_limit", memory_limit);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reference">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="updates">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_ref(type: DtInvalid).
      ///</return>
      public Operation ScatterNdSub (  Output reference , Output indices , Output updates , bool use_locking = false ,String opName= "ScatterNdSub" ) 
      {
         OperationDescription desc = NewOperation("ScatterNdSub", opName);
         desc.AddInput(reference);
         desc.AddInput(indices);
         desc.AddInput(updates);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="key">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="dtypes"></param>
      ///<param name="capacity"></param>
      ///<param name="memory_limit"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] values(type: DtInvalid).
      ///</return>
      public Operation OrderedMapUnstage (  Output key , Output indices , DataType[] dtypes, long capacity = 0 , long memory_limit = 0 , string container = null , string shared_name = null ,String opName= "OrderedMapUnstage" ) 
      {
         OperationDescription desc = NewOperation("OrderedMapUnstage", opName);
         desc.AddInput(key);
         desc.AddInput(indices);
         desc.SetAttr("dtypes", dtypes);
         if (capacity != 0) desc.SetAttr("capacity", capacity);
         if (memory_limit != 0) desc.SetAttr("memory_limit", memory_limit);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="serialized">Input to the operation. </param>
      ///<param name="feature_list_dense_missing_assumed_empty">Input to the operation. </param>
      ///<param name="context_sparse_keys">Input to the operation. </param>
      ///<param name="context_dense_keys">Input to the operation. </param>
      ///<param name="feature_list_sparse_keys">Input to the operation. </param>
      ///<param name="feature_list_dense_keys">Input to the operation. </param>
      ///<param name="context_dense_defaults">Input to the operation. </param>
      ///<param name="debug_name">Input to the operation. </param>
      ///<param name="context_sparse_types"></param>
      ///<param name="feature_list_dense_types"></param>
      ///<param name="context_dense_shapes"></param>
      ///<param name="feature_list_sparse_types"></param>
      ///<param name="feature_list_dense_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] context_sparse_indices(type: DtInt64).
      ///[1] context_sparse_values(type: DtInvalid).
      ///[2] context_sparse_shapes(type: DtInt64).
      ///[3] context_dense_values(type: DtInvalid).
      ///[4] feature_list_sparse_indices(type: DtInt64).
      ///[5] feature_list_sparse_values(type: DtInvalid).
      ///[6] feature_list_sparse_shapes(type: DtInt64).
      ///[7] feature_list_dense_values(type: DtInvalid).
      ///</return>
      public Operation ParseSingleSequenceExample (  Output serialized , Output feature_list_dense_missing_assumed_empty , Output context_sparse_keys , Output context_dense_keys , Output feature_list_sparse_keys , Output feature_list_dense_keys , Output context_dense_defaults , Output debug_name , DataType[] context_sparse_types = null , DataType[] feature_list_dense_types = null , long[][] context_dense_shapes = null , DataType[] feature_list_sparse_types = null , long[][] feature_list_dense_shapes = null ,String opName= "ParseSingleSequenceExample" ) 
      {
         OperationDescription desc = NewOperation("ParseSingleSequenceExample", opName);
         desc.AddInput(serialized);
         desc.AddInput(feature_list_dense_missing_assumed_empty);
         desc.AddInput(context_sparse_keys);
         desc.AddInput(context_dense_keys);
         desc.AddInput(feature_list_sparse_keys);
         desc.AddInput(feature_list_dense_keys);
         desc.AddInput(context_dense_defaults);
         desc.AddInput(debug_name);

         if (context_sparse_types != null) desc.SetAttr("context_sparse_types", context_sparse_types);
         if (feature_list_dense_types != null) desc.SetAttr("feature_list_dense_types", feature_list_dense_types);
         if (context_dense_shapes != null) desc.SetAttrShapeList("context_dense_shapes", context_dense_shapes);
         if (feature_list_sparse_types != null) desc.SetAttr("feature_list_sparse_types", feature_list_sparse_types);
         if (feature_list_dense_shapes != null) desc.SetAttrShapeList("feature_list_dense_shapes", feature_list_dense_shapes);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="matrix">Input to the operation. </param>
      ///<param name="rhs">Input to the operation. </param>
      ///<param name="adjoint"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation BatchMatrixSolve (  Output matrix , Output rhs , bool adjoint = false ,String opName= "BatchMatrixSolve" ) 
      {
         OperationDescription desc = NewOperation("BatchMatrixSolve", opName);
         desc.AddInput(matrix);
         desc.AddInput(rhs);

         if (adjoint != false) desc.SetAttr("adjoint", adjoint);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="a_indices">Input to the operation. </param>
      ///<param name="a_values">Input to the operation. </param>
      ///<param name="a_shape">Input to the operation. </param>
      ///<param name="b_indices">Input to the operation. </param>
      ///<param name="b_values">Input to the operation. </param>
      ///<param name="b_shape">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_indices(type: DtInt64).
      ///[1] output_values(type: DtInvalid).
      ///</return>
      public Operation SparseSparseMaximum (  Output a_indices , Output a_values , Output a_shape , Output b_indices , Output b_values , Output b_shape ,String opName= "SparseSparseMaximum" ) 
      {
         OperationDescription desc = NewOperation("SparseSparseMaximum", opName);
         desc.AddInput(a_indices);
         desc.AddInput(a_values);
         desc.AddInput(a_shape);
         desc.AddInput(b_indices);
         desc.AddInput(b_values);
         desc.AddInput(b_shape);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="dtypes"></param>
      ///<param name="capacity"></param>
      ///<param name="memory_limit"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] size(type: DtInt32).
      ///</return>
      public Operation OrderedMapSize (  DataType[] dtypes, long capacity = 0 , long memory_limit = 0 , string container = null , string shared_name = null ,String opName= "OrderedMapSize" ) 
      {
         OperationDescription desc = NewOperation("OrderedMapSize", opName);

         desc.SetAttr("dtypes", dtypes);
         if (capacity != 0) desc.SetAttr("capacity", capacity);
         if (memory_limit != 0) desc.SetAttr("memory_limit", memory_limit);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="dataset">Input to the operation. </param>
      ///<param name="iterator">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation MakeIterator (  Output dataset , Output iterator ,String opName= "MakeIterator" ) 
      {
         OperationDescription desc = NewOperation("MakeIterator", opName);
         desc.AddInput(dataset);
         desc.AddInput(iterator);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="alpha">Input to the operation. </param>
      ///<param name="l1">Input to the operation. </param>
      ///<param name="l2">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceSparseApplyProximalGradientDescent (  Output var , Output alpha , Output l1 , Output l2 , Output grad , Output indices , bool use_locking = false ,String opName= "ResourceSparseApplyProximalGradientDescent" ) 
      {
         OperationDescription desc = NewOperation("ResourceSparseApplyProximalGradientDescent", opName);
         desc.AddInput(var);
         desc.AddInput(alpha);
         desc.AddInput(l1);
         desc.AddInput(l2);
         desc.AddInput(grad);
         desc.AddInput(indices);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="dtypes"></param>
      ///<param name="capacity"></param>
      ///<param name="memory_limit"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] size(type: DtInt32).
      ///</return>
      public Operation OrderedMapIncompleteSize (  DataType[] dtypes, long capacity = 0 , long memory_limit = 0 , string container = null , string shared_name = null ,String opName= "OrderedMapIncompleteSize" ) 
      {
         OperationDescription desc = NewOperation("OrderedMapIncompleteSize", opName);

         desc.SetAttr("dtypes", dtypes);
         if (capacity != 0) desc.SetAttr("capacity", capacity);
         if (memory_limit != 0) desc.SetAttr("memory_limit", memory_limit);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] reader_handle(type: DtString).
      ///</return>
      public Operation IdentityReader (  string container = null , string shared_name = null ,String opName= "IdentityReader" ) 
      {
         OperationDescription desc = NewOperation("IdentityReader", opName);


         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="components">Input to the operation. </param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation TensorDataset (  Output components , long[][] output_shapes,String opName= "TensorDataset" ) 
      {
         OperationDescription desc = NewOperation("TensorDataset", opName);
         desc.AddInput(components);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="components">Input to the operation. </param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation TensorSliceDataset (  Output components , long[][] output_shapes,String opName= "TensorSliceDataset" ) 
      {
         OperationDescription desc = NewOperation("TensorSliceDataset", opName);
         desc.AddInput(components);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///Creates summary database writer accessible by given resource handle.
      ///</summary>
      ///<param name="writer">Input to the operation: Handle to SummaryWriter resource to overwrite.</param>
      ///<param name="db_uri">Input to the operation: For example "file:/tmp/foo.sqlite".</param>
      ///<param name="experiment_name">Input to the operation: Can't contain ASCII control characters or &lt;&gt;. Case sensitive. If empty, then the Run will not be associated with any Experiment.</param>
      ///<param name="run_name">Input to the operation: Can't contain ASCII control characters or &lt;&gt;. Case sensitive. If empty, then each Tag will not be associated with any Run.</param>
      ///<param name="user_name">Input to the operation: Must be valid as both a DNS label and Linux username. If empty, then the Experiment will not be associated with any User.</param>
      ///<param name="opName">The name of the operation</param>
      public Operation CreateSummaryDbWriter (  Output writer , Output db_uri , Output experiment_name , Output run_name , Output user_name ,String opName= "CreateSummaryDbWriter" ) 
      {
         OperationDescription desc = NewOperation("CreateSummaryDbWriter", opName);
         desc.AddInput(writer);
         desc.AddInput(db_uri);
         desc.AddInput(experiment_name);
         desc.AddInput(run_name);
         desc.AddInput(user_name);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="a">Input to the operation. </param>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation Igammac (  Output a , Output x ,String opName= "Igammac" ) 
      {
         OperationDescription desc = NewOperation("Igammac", opName);
         desc.AddInput(a);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="count">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation SkipDataset (  Output input_dataset , Output count , DataType[] output_types, long[][] output_shapes,String opName= "SkipDataset" ) 
      {
         OperationDescription desc = NewOperation("SkipDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(count);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="tag">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation LatencyStatsDataset (  Output input_dataset , Output tag , DataType[] output_types, long[][] output_shapes,String opName= "LatencyStatsDataset" ) 
      {
         OperationDescription desc = NewOperation("LatencyStatsDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(tag);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="gradient_accumulator">Input to the operation. </param>
      ///<param name="gradient_squared_accumulator">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="l1">Input to the operation. </param>
      ///<param name="l2">Input to the operation. </param>
      ///<param name="global_step">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceSparseApplyAdagradDA (  Output var , Output gradient_accumulator , Output gradient_squared_accumulator , Output grad , Output indices , Output lr , Output l1 , Output l2 , Output global_step , bool use_locking = false ,String opName= "ResourceSparseApplyAdagradDA" ) 
      {
         OperationDescription desc = NewOperation("ResourceSparseApplyAdagradDA", opName);
         desc.AddInput(var);
         desc.AddInput(gradient_accumulator);
         desc.AddInput(gradient_squared_accumulator);
         desc.AddInput(grad);
         desc.AddInput(indices);
         desc.AddInput(lr);
         desc.AddInput(l1);
         desc.AddInput(l2);
         desc.AddInput(global_step);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_sizes">Input to the operation. </param>
      ///<param name="filter">Input to the operation. </param>
      ///<param name="out_backprop">Input to the operation. </param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="data_format"></param>
      ///<param name="dilations"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Conv3DBackpropInputV2 (  Output input_sizes , Output filter , Output out_backprop , long[] strides, string padding, string data_format = null , long[] dilations = null ,String opName= "Conv3DBackpropInputV2" ) 
      {
         OperationDescription desc = NewOperation("Conv3DBackpropInputV2", opName);
         desc.AddInput(input_sizes);
         desc.AddInput(filter);
         desc.AddInput(out_backprop);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         if (dilations != null) desc.SetAttr("dilations", dilations);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Expm1 (  Output x ,String opName= "Expm1" ) 
      {
         OperationDescription desc = NewOperation("Expm1", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="buffer_size">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation PrefetchDataset (  Output input_dataset , Output buffer_size , DataType[] output_types, long[][] output_shapes,String opName= "PrefetchDataset" ) 
      {
         OperationDescription desc = NewOperation("PrefetchDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(buffer_size);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="other_arguments">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      //The following attributes are not known: f: func
      public Operation FlatMapDataset (  Output input_dataset , Output other_arguments , DataType[] output_types, long[][] output_shapes,String opName= "FlatMapDataset" ) 
      {
         OperationDescription desc = NewOperation("FlatMapDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(other_arguments);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="other_arguments">Input to the operation. </param>
      ///<param name="cycle_length">Input to the operation. </param>
      ///<param name="block_length">Input to the operation. </param>
      ///<param name="sloppy">Input to the operation. </param>
      ///<param name="buffer_output_elements">Input to the operation. </param>
      ///<param name="prefetch_input_elements">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      //The following attributes are not known: f: func
      public Operation ParallelInterleaveDataset (  Output input_dataset , Output other_arguments , Output cycle_length , Output block_length , Output sloppy , Output buffer_output_elements , Output prefetch_input_elements , DataType[] output_types, long[][] output_shapes,String opName= "ParallelInterleaveDataset" ) 
      {
         OperationDescription desc = NewOperation("ParallelInterleaveDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(other_arguments);
         desc.AddInput(cycle_length);
         desc.AddInput(block_length);
         desc.AddInput(sloppy);
         desc.AddInput(buffer_output_elements);
         desc.AddInput(prefetch_input_elements);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation ApplyAdagrad (  Output var , Output accum , Output lr , Output grad , bool use_locking = false ,String opName= "ApplyAdagrad" ) 
      {
         OperationDescription desc = NewOperation("ApplyAdagrad", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(lr);
         desc.AddInput(grad);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="batch_size">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation BatchDataset (  Output input_dataset , Output batch_size , DataType[] output_types, long[][] output_shapes,String opName= "BatchDataset" ) 
      {
         OperationDescription desc = NewOperation("BatchDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(batch_size);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtComplex64).
      ///</return>
      public Operation IFFT3D (  Output input ,String opName= "IFFT3D" ) 
      {
         OperationDescription desc = NewOperation("IFFT3D", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="resource_handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] serialized(type: DtVariant).
      ///</return>
      public Operation SerializeIterator (  Output resource_handle ,String opName= "SerializeIterator" ) 
      {
         OperationDescription desc = NewOperation("SerializeIterator", opName);
         desc.AddInput(resource_handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="batch_size">Input to the operation. </param>
      ///<param name="padded_shapes">Input to the operation. </param>
      ///<param name="padding_values">Input to the operation. </param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation PaddedBatchDataset (  Output input_dataset , Output batch_size , Output padded_shapes , Output padding_values , long[][] output_shapes,String opName= "PaddedBatchDataset" ) 
      {
         OperationDescription desc = NewOperation("PaddedBatchDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(batch_size);
         desc.AddInput(padded_shapes);
         desc.AddInput(padding_values);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="start">Input to the operation. </param>
      ///<param name="stop">Input to the operation. </param>
      ///<param name="step">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation RangeDataset (  Output start , Output stop , Output step , DataType[] output_types, long[][] output_shapes,String opName= "RangeDataset" ) 
      {
         OperationDescription desc = NewOperation("RangeDataset", opName);
         desc.AddInput(start);
         desc.AddInput(stop);
         desc.AddInput(step);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="buffer_size">Input to the operation. </param>
      ///<param name="seed">Input to the operation. </param>
      ///<param name="seed2">Input to the operation. </param>
      ///<param name="count">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation ShuffleAndRepeatDataset (  Output input_dataset , Output buffer_size , Output seed , Output seed2 , Output count , DataType[] output_types, long[][] output_shapes,String opName= "ShuffleAndRepeatDataset" ) 
      {
         OperationDescription desc = NewOperation("ShuffleAndRepeatDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(buffer_size);
         desc.AddInput(seed);
         desc.AddInput(seed2);
         desc.AddInput(count);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="images">Input to the operation. </param>
      ///<param name="size">Input to the operation. </param>
      ///<param name="align_corners"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] resized_images(type: DtFloat).
      ///</return>
      public Operation ResizeArea (  Output images , Output size , bool align_corners = false ,String opName= "ResizeArea" ) 
      {
         OperationDescription desc = NewOperation("ResizeArea", opName);
         desc.AddInput(images);
         desc.AddInput(size);

         if (align_corners != false) desc.SetAttr("align_corners", align_corners);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="filename">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation CacheDataset (  Output input_dataset , Output filename , DataType[] output_types, long[][] output_shapes,String opName= "CacheDataset" ) 
      {
         OperationDescription desc = NewOperation("CacheDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(filename);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="filenames">Input to the operation. </param>
      ///<param name="compression_type">Input to the operation. </param>
      ///<param name="buffer_size">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation TextLineDataset (  Output filenames , Output compression_type , Output buffer_size ,String opName= "TextLineDataset" ) 
      {
         OperationDescription desc = NewOperation("TextLineDataset", opName);
         desc.AddInput(filenames);
         desc.AddInput(compression_type);
         desc.AddInput(buffer_size);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="filenames">Input to the operation. </param>
      ///<param name="compression_type">Input to the operation. </param>
      ///<param name="buffer_size">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation TFRecordDataset (  Output filenames , Output compression_type , Output buffer_size ,String opName= "TFRecordDataset" ) 
      {
         OperationDescription desc = NewOperation("TFRecordDataset", opName);
         desc.AddInput(filenames);
         desc.AddInput(compression_type);
         desc.AddInput(buffer_size);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reader_handle">Input to the operation. </param>
      ///<param name="queue_handle">Input to the operation. </param>
      ///<param name="num_records">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] keys(type: DtString).
      ///[1] values(type: DtString).
      ///</return>
      public Operation ReaderReadUpTo (  Output reader_handle , Output queue_handle , Output num_records ,String opName= "ReaderReadUpTo" ) 
      {
         OperationDescription desc = NewOperation("ReaderReadUpTo", opName);
         desc.AddInput(reader_handle);
         desc.AddInput(queue_handle);
         desc.AddInput(num_records);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="shared_name"></param>
      ///<param name="container"></param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtResource).
      ///</return>
      public Operation Iterator (  string shared_name, string container, DataType[] output_types, long[][] output_shapes,String opName= "Iterator" ) 
      {
         OperationDescription desc = NewOperation("Iterator", opName);

         desc.SetAttr("shared_name", shared_name);
         desc.SetAttr("container", container);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="argmax">Input to the operation. </param>
      ///<param name="ksize"></param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation MaxPoolGradWithArgmax (  Output input , Output grad , Output argmax , long[] ksize, long[] strides, string padding,String opName= "MaxPoolGradWithArgmax" ) 
      {
         OperationDescription desc = NewOperation("MaxPoolGradWithArgmax", opName);
         desc.AddInput(input);
         desc.AddInput(grad);
         desc.AddInput(argmax);
         desc.SetAttr("ksize", ksize);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtResource).
      ///</return>
      //The following attributes are not known: dataset_factory: func
      public Operation OneShotIterator (  DataType[] output_types, long[][] output_shapes, string container = null , string shared_name = null ,String opName= "OneShotIterator" ) 
      {
         OperationDescription desc = NewOperation("OneShotIterator", opName);

         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="iterator">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] components(type: DtInvalid).
      ///</return>
      public Operation IteratorGetNextSync (  Output iterator , DataType[] output_types, long[][] output_shapes,String opName= "IteratorGetNextSync" ) 
      {
         OperationDescription desc = NewOperation("IteratorGetNextSync", opName);
         desc.AddInput(iterator);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="dataset">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] components(type: DtInvalid).
      ///</return>
      public Operation DatasetToSingleElement (  Output dataset , DataType[] output_types, long[][] output_shapes,String opName= "DatasetToSingleElement" ) 
      {
         OperationDescription desc = NewOperation("DatasetToSingleElement", opName);
         desc.AddInput(dataset);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="images">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation RGBToHSV (  Output images ,String opName= "RGBToHSV" ) 
      {
         OperationDescription desc = NewOperation("RGBToHSV", opName);
         desc.AddInput(images);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtResource).
      ///</return>
      public Operation StatsAggregatorHandle (  string container = null , string shared_name = null ,String opName= "StatsAggregatorHandle" ) 
      {
         OperationDescription desc = NewOperation("StatsAggregatorHandle", opName);


         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="filename">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] contents(type: DtString).
      ///</return>
      public Operation ReadFile (  Output filename ,String opName= "ReadFile" ) 
      {
         OperationDescription desc = NewOperation("ReadFile", opName);
         desc.AddInput(filename);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="iterator_handle">Input to the operation. </param>
      ///<param name="stats_aggregator_handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation IteratorSetStatsAggregator (  Output iterator_handle , Output stats_aggregator_handle ,String opName= "IteratorSetStatsAggregator" ) 
      {
         OperationDescription desc = NewOperation("IteratorSetStatsAggregator", opName);
         desc.AddInput(iterator_handle);
         desc.AddInput(stats_aggregator_handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="iterator">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] summary(type: DtString).
      ///</return>
      public Operation StatsAggregatorSummary (  Output iterator ,String opName= "StatsAggregatorSummary" ) 
      {
         OperationDescription desc = NewOperation("StatsAggregatorSummary", opName);
         desc.AddInput(iterator);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="batch_size">Input to the operation. </param>
      ///<param name="padded_shapes">Input to the operation. </param>
      ///<param name="padding_values">Input to the operation. </param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation PrependFromQueueAndPaddedBatchDataset (  Output input_dataset , Output batch_size , Output padded_shapes , Output padding_values , long[][] output_shapes,String opName= "PrependFromQueueAndPaddedBatchDataset" ) 
      {
         OperationDescription desc = NewOperation("PrependFromQueueAndPaddedBatchDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(batch_size);
         desc.AddInput(padded_shapes);
         desc.AddInput(padding_values);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="matrix">Input to the operation. </param>
      ///<param name="rhs">Input to the operation. </param>
      ///<param name="adjoint"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation MatrixSolve (  Output matrix , Output rhs , bool adjoint = false ,String opName= "MatrixSolve" ) 
      {
         OperationDescription desc = NewOperation("MatrixSolve", opName);
         desc.AddInput(matrix);
         desc.AddInput(rhs);

         if (adjoint != false) desc.SetAttr("adjoint", adjoint);
         return desc.FinishOperation();
      } 
      // Skipped function _HostCast

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_handle">Input to the operation. </param>
      ///<param name="index">Input to the operation. </param>
      ///<param name="element_dtype"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] item(type: DtInvalid).
      ///</return>
      public Operation TensorListGetItem (  Output input_handle , Output index , DataType element_dtype,String opName= "TensorListGetItem" ) 
      {
         OperationDescription desc = NewOperation("TensorListGetItem", opName);
         desc.AddInput(input_handle);
         desc.AddInput(index);
         desc.SetAttr("element_dtype", element_dtype);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="queue">Input to the operation. </param>
      ///<param name="components">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation EnqueueInQueueDataset (  Output queue , Output components ,String opName= "EnqueueInQueueDataset" ) 
      {
         OperationDescription desc = NewOperation("EnqueueInQueueDataset", opName);
         desc.AddInput(queue);
         desc.AddInput(components);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///Copy Host Op.
      ///</summary>
      ///<param name="input">Input to the operation: Input tensor.</param>
      ///<param name="tensor_name">The name of the input tensor.</param>
      ///<param name="debug_ops_spec">A list of debug op spec (op, url, gated_grpc) for attached debug ops. Each element of the list has the format &lt;debug_op&gt;;&lt;grpc_url&gt;;&lt;gated_grpc&gt;, wherein gated_grpc is boolean represented as 0/1. E.g., "DebugIdentity;grpc://foo:3333;1", "DebugIdentity;file:///tmp/tfdbg_1;0".</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid): Output tensor, deep-copied from input.
      ///</return>
      public Operation CopyHost (  Output input , string tensor_name = null , string[] debug_ops_spec = null ,String opName= "CopyHost" ) 
      {
         OperationDescription desc = NewOperation("CopyHost", opName);
         desc.AddInput(input);

         if (tensor_name != null) desc.SetAttr("tensor_name", tensor_name);
         if (debug_ops_spec != null) desc.SetAttr("debug_ops_spec", debug_ops_spec);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="gradient_accumulator">Input to the operation. </param>
      ///<param name="gradient_squared_accumulator">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="l1">Input to the operation. </param>
      ///<param name="l2">Input to the operation. </param>
      ///<param name="global_step">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation ApplyAdagradDA (  Output var , Output gradient_accumulator , Output gradient_squared_accumulator , Output grad , Output lr , Output l1 , Output l2 , Output global_step , bool use_locking = false ,String opName= "ApplyAdagradDA" ) 
      {
         OperationDescription desc = NewOperation("ApplyAdagradDA", opName);
         desc.AddInput(var);
         desc.AddInput(gradient_accumulator);
         desc.AddInput(gradient_squared_accumulator);
         desc.AddInput(grad);
         desc.AddInput(lr);
         desc.AddInput(l1);
         desc.AddInput(l2);
         desc.AddInput(global_step);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///Debug Identity Op.
      ///</summary>
      ///<param name="input">Input to the operation: Input tensor, non-Reference type.</param>
      ///<param name="device_name"></param>
      ///<param name="tensor_name">Name of the input tensor.</param>
      ///<param name="debug_urls">List of URLs to debug targets, e.g., file:///foo/tfdbg_dump, grpc:://localhost:11011</param>
      ///<param name="gated_grpc">Whether this op will be gated. If any of the debug_urls of this debug node is of the grpc:// scheme, when the value of this attribute is set to True, the data will not actually be sent via the grpc stream unless this debug op has been enabled at the debug_url. If all of the debug_urls of this debug node are of the grpc:// scheme and the debug op is enabled at none of them, the output will be an empty Tensor.</param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid): Output tensor that equals the input tensor.
      ///</return>
      public Operation DebugIdentity (  Output input , string device_name = null , string tensor_name = null , string[] debug_urls = null , bool gated_grpc = false ,String opName= "DebugIdentity" ) 
      {
         OperationDescription desc = NewOperation("DebugIdentity", opName);
         desc.AddInput(input);

         if (device_name != null) desc.SetAttr("device_name", device_name);
         if (tensor_name != null) desc.SetAttr("tensor_name", tensor_name);
         if (debug_urls != null) desc.SetAttr("debug_urls", debug_urls);
         if (gated_grpc != false) desc.SetAttr("gated_grpc", gated_grpc);
         return desc.FinishOperation();
      } 
      // Skipped function _Arg
      // Skipped function _Retval

      ///<summary>
      ///
      ///</summary>
      ///<param name="a">Input to the operation. </param>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation Polygamma (  Output a , Output x ,String opName= "Polygamma" ) 
      {
         OperationDescription desc = NewOperation("Polygamma", opName);
         desc.AddInput(a);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation AddV2 (  Output x , Output y ,String opName= "AddV2" ) 
      {
         OperationDescription desc = NewOperation("AddV2", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 
      // Skipped function _ListToArray

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="Tout"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      //The following attributes are not known: f: func
      public Operation SymbolicGradient (  Output input , DataType[] Tout,String opName= "SymbolicGradient" ) 
      {
         OperationDescription desc = NewOperation("SymbolicGradient", opName);
         desc.AddInput(input);
         desc.SetAttr("Tout", Tout);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation Mod (  Output x , Output y ,String opName= "Mod" ) 
      {
         OperationDescription desc = NewOperation("Mod", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="target">Input to the operation. </param>
      ///<param name="args">Input to the operation. </param>
      ///<param name="Tout"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      //The following attributes are not known: f: func
      public Operation RemoteCall (  Output target , Output args , DataType[] Tout,String opName= "RemoteCall" ) 
      {
         OperationDescription desc = NewOperation("RemoteCall", opName);
         desc.AddInput(target);
         desc.AddInput(args);
         desc.SetAttr("Tout", Tout);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="predictions">Input to the operation. </param>
      ///<param name="targets">Input to the operation. </param>
      ///<param name="k">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] precision(type: DtBool).
      ///</return>
      public Operation InTopKV2 (  Output predictions , Output targets , Output k ,String opName= "InTopKV2" ) 
      {
         OperationDescription desc = NewOperation("InTopKV2", opName);
         desc.AddInput(predictions);
         desc.AddInput(targets);
         desc.AddInput(k);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="grads">Input to the operation. </param>
      ///<param name="original_image">Input to the operation. </param>
      ///<param name="align_corners"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation ResizeBicubicGrad (  Output grads , Output original_image , bool align_corners = false ,String opName= "ResizeBicubicGrad" ) 
      {
         OperationDescription desc = NewOperation("ResizeBicubicGrad", opName);
         desc.AddInput(grads);
         desc.AddInput(original_image);

         if (align_corners != false) desc.SetAttr("align_corners", align_corners);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="grads">Input to the operation. </param>
      ///<param name="original_image">Input to the operation. </param>
      ///<param name="align_corners"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation ResizeBilinearGrad (  Output grads , Output original_image , bool align_corners = false ,String opName= "ResizeBilinearGrad" ) 
      {
         OperationDescription desc = NewOperation("ResizeBilinearGrad", opName);
         desc.AddInput(grads);
         desc.AddInput(original_image);

         if (align_corners != false) desc.SetAttr("align_corners", align_corners);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="image">Input to the operation. </param>
      ///<param name="size">Input to the operation. </param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation RandomCrop (  Output image , Output size , long seed = 0 , long seed2 = 0 ,String opName= "RandomCrop" ) 
      {
         OperationDescription desc = NewOperation("RandomCrop", opName);
         desc.AddInput(image);
         desc.AddInput(size);

         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_sizes">Input to the operation. </param>
      ///<param name="filter">Input to the operation. </param>
      ///<param name="out_backprop">Input to the operation. </param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="data_format"></param>
      ///<param name="dilations"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation DepthwiseConv2dNativeBackpropInput (  Output input_sizes , Output filter , Output out_backprop , long[] strides, string padding, string data_format = null , long[] dilations = null ,String opName= "DepthwiseConv2dNativeBackpropInput" ) 
      {
         OperationDescription desc = NewOperation("DepthwiseConv2dNativeBackpropInput", opName);
         desc.AddInput(input_sizes);
         desc.AddInput(filter);
         desc.AddInput(out_backprop);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         if (dilations != null) desc.SetAttr("dilations", dilations);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="Tout"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Real (  Output input , DataType? Tout = null ,String opName= "Real" ) 
      {
         OperationDescription desc = NewOperation("Real", opName);
         desc.AddInput(input);

         if (Tout.HasValue) desc.SetAttr("Tout", Tout.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="contents">Input to the operation. </param>
      ///<param name="channels"></param>
      ///<param name="ratio"></param>
      ///<param name="fancy_upscaling"></param>
      ///<param name="try_recover_truncated"></param>
      ///<param name="acceptable_fraction"></param>
      ///<param name="dct_method"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] image(type: DtUint8).
      ///</return>
      public Operation DecodeJpeg (  Output contents , long channels = 0 , long ratio = 1 , bool fancy_upscaling = true , bool try_recover_truncated = false , float acceptable_fraction = 1f , string dct_method = null ,String opName= "DecodeJpeg" ) 
      {
         OperationDescription desc = NewOperation("DecodeJpeg", opName);
         desc.AddInput(contents);

         if (channels != 0) desc.SetAttr("channels", channels);
         if (ratio != 1) desc.SetAttr("ratio", ratio);
         if (fancy_upscaling != true) desc.SetAttr("fancy_upscaling", fancy_upscaling);
         if (try_recover_truncated != false) desc.SetAttr("try_recover_truncated", try_recover_truncated);
         if (acceptable_fraction != 1f) desc.SetAttr("acceptable_fraction", acceptable_fraction);
         if (dct_method != null) desc.SetAttr("dct_method", dct_method);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="image">Input to the operation. </param>
      ///<param name="format"></param>
      ///<param name="quality"></param>
      ///<param name="progressive"></param>
      ///<param name="optimize_size"></param>
      ///<param name="chroma_downsampling"></param>
      ///<param name="density_unit"></param>
      ///<param name="x_density"></param>
      ///<param name="y_density"></param>
      ///<param name="xmp_metadata"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] contents(type: DtString).
      ///</return>
      public Operation EncodeJpeg (  Output image , string format = null , long quality = 95 , bool progressive = false , bool optimize_size = false , bool chroma_downsampling = true , string density_unit = null , long x_density = 300 , long y_density = 300 , string xmp_metadata = null ,String opName= "EncodeJpeg" ) 
      {
         OperationDescription desc = NewOperation("EncodeJpeg", opName);
         desc.AddInput(image);

         if (format != null) desc.SetAttr("format", format);
         if (quality != 95) desc.SetAttr("quality", quality);
         if (progressive != false) desc.SetAttr("progressive", progressive);
         if (optimize_size != false) desc.SetAttr("optimize_size", optimize_size);
         if (chroma_downsampling != true) desc.SetAttr("chroma_downsampling", chroma_downsampling);
         if (density_unit != null) desc.SetAttr("density_unit", density_unit);
         if (x_density != 300) desc.SetAttr("x_density", x_density);
         if (y_density != 300) desc.SetAttr("y_density", y_density);
         if (xmp_metadata != null) desc.SetAttr("xmp_metadata", xmp_metadata);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="contents">Input to the operation. </param>
      ///<param name="output_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] image_shape(type: DtInvalid).
      ///</return>
      public Operation ExtractJpegShape (  Output contents , DataType? output_type = null ,String opName= "ExtractJpegShape" ) 
      {
         OperationDescription desc = NewOperation("ExtractJpegShape", opName);
         desc.AddInput(contents);

         if (output_type.HasValue) desc.SetAttr("output_type", output_type.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="images">Input to the operation. </param>
      ///<param name="contrast_factor">Input to the operation. </param>
      ///<param name="min_value">Input to the operation. </param>
      ///<param name="max_value">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtFloat).
      ///</return>
      public Operation AdjustContrast (  Output images , Output contrast_factor , Output min_value , Output max_value ,String opName= "AdjustContrast" ) 
      {
         OperationDescription desc = NewOperation("AdjustContrast", opName);
         desc.AddInput(images);
         desc.AddInput(contrast_factor);
         desc.AddInput(min_value);
         desc.AddInput(max_value);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="images">Input to the operation. </param>
      ///<param name="delta">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtFloat).
      ///</return>
      public Operation AdjustHue (  Output images , Output delta ,String opName= "AdjustHue" ) 
      {
         OperationDescription desc = NewOperation("AdjustHue", opName);
         desc.AddInput(images);
         desc.AddInput(delta);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="image">Input to the operation. </param>
      ///<param name="compression"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] contents(type: DtString).
      ///</return>
      public Operation EncodePng (  Output image , long compression = -1 ,String opName= "EncodePng" ) 
      {
         OperationDescription desc = NewOperation("EncodePng", opName);
         desc.AddInput(image);

         if (compression != -1) desc.SetAttr("compression", compression);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="contents">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] image(type: DtUint8).
      ///</return>
      public Operation DecodeGif (  Output contents ,String opName= "DecodeGif" ) 
      {
         OperationDescription desc = NewOperation("DecodeGif", opName);
         desc.AddInput(contents);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="images">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation HSVToRGB (  Output images ,String opName= "HSVToRGB" ) 
      {
         OperationDescription desc = NewOperation("HSVToRGB", opName);
         desc.AddInput(images);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="images">Input to the operation. </param>
      ///<param name="boxes">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation DrawBoundingBoxes (  Output images , Output boxes ,String opName= "DrawBoundingBoxes" ) 
      {
         OperationDescription desc = NewOperation("DrawBoundingBoxes", opName);
         desc.AddInput(images);
         desc.AddInput(boxes);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] reader_handle(type: DtResource).
      ///</return>
      public Operation IdentityReaderV2 (  string container = null , string shared_name = null ,String opName= "IdentityReaderV2" ) 
      {
         OperationDescription desc = NewOperation("IdentityReaderV2", opName);


         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="image_size">Input to the operation. </param>
      ///<param name="bounding_boxes">Input to the operation. </param>
      ///<param name="min_object_covered">Input to the operation. </param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="aspect_ratio_range"></param>
      ///<param name="area_range"></param>
      ///<param name="max_attempts"></param>
      ///<param name="use_image_if_no_bounding_boxes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] begin(type: DtInvalid).
      ///[1] size(type: DtInvalid).
      ///[2] bboxes(type: DtFloat).
      ///</return>
      public Operation SampleDistortedBoundingBoxV2 (  Output image_size , Output bounding_boxes , Output min_object_covered , long seed = 0 , long seed2 = 0 , float[] aspect_ratio_range = null , float[] area_range = null , long max_attempts = 100 , bool use_image_if_no_bounding_boxes = false ,String opName= "SampleDistortedBoundingBoxV2" ) 
      {
         OperationDescription desc = NewOperation("SampleDistortedBoundingBoxV2", opName);
         desc.AddInput(image_size);
         desc.AddInput(bounding_boxes);
         desc.AddInput(min_object_covered);

         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         if (aspect_ratio_range != null) desc.SetAttr("aspect_ratio_range", aspect_ratio_range);
         if (area_range != null) desc.SetAttr("area_range", area_range);
         if (max_attempts != 100) desc.SetAttr("max_attempts", max_attempts);
         if (use_image_if_no_bounding_boxes != false) desc.SetAttr("use_image_if_no_bounding_boxes", use_image_if_no_bounding_boxes);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reader_handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] state(type: DtString).
      ///</return>
      public Operation ReaderSerializeState (  Output reader_handle ,String opName= "ReaderSerializeState" ) 
      {
         OperationDescription desc = NewOperation("ReaderSerializeState", opName);
         desc.AddInput(reader_handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="size">Input to the operation. </param>
      ///<param name="offsets">Input to the operation. </param>
      ///<param name="centered"></param>
      ///<param name="normalized"></param>
      ///<param name="uniform_noise"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] glimpse(type: DtFloat).
      ///</return>
      public Operation ExtractGlimpse (  Output input , Output size , Output offsets , bool centered = true , bool normalized = true , bool uniform_noise = true ,String opName= "ExtractGlimpse" ) 
      {
         OperationDescription desc = NewOperation("ExtractGlimpse", opName);
         desc.AddInput(input);
         desc.AddInput(size);
         desc.AddInput(offsets);

         if (centered != true) desc.SetAttr("centered", centered);
         if (normalized != true) desc.SetAttr("normalized", normalized);
         if (uniform_noise != true) desc.SetAttr("uniform_noise", uniform_noise);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtBool).
      ///</return>
      public Operation IsInf (  Output x ,String opName= "IsInf" ) 
      {
         OperationDescription desc = NewOperation("IsInf", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="key_dtype"></param>
      ///<param name="value_dtype"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="use_node_name_sharing"></param>
      ///<param name="value_shape"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] table_handle(type: DtResource).
      ///</return>
      public Operation MutableHashTableOfTensorsV2 (  DataType key_dtype, DataType value_dtype, string container = null , string shared_name = null , bool use_node_name_sharing = false , long[] value_shape = null ,String opName= "MutableHashTableOfTensorsV2" ) 
      {
         OperationDescription desc = NewOperation("MutableHashTableOfTensorsV2", opName);

         desc.SetAttr("key_dtype", key_dtype);
         desc.SetAttr("value_dtype", value_dtype);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         if (use_node_name_sharing != false) desc.SetAttr("use_node_name_sharing", use_node_name_sharing);
         if (value_shape != null) desc.SetAttrShape("value_shape", value_shape);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="image">Input to the operation. </param>
      ///<param name="boxes">Input to the operation. </param>
      ///<param name="box_ind">Input to the operation. </param>
      ///<param name="crop_size">Input to the operation. </param>
      ///<param name="method"></param>
      ///<param name="extrapolation_value"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] crops(type: DtFloat).
      ///</return>
      public Operation CropAndResize (  Output image , Output boxes , Output box_ind , Output crop_size , string method = null , float extrapolation_value = 0f ,String opName= "CropAndResize" ) 
      {
         OperationDescription desc = NewOperation("CropAndResize", opName);
         desc.AddInput(image);
         desc.AddInput(boxes);
         desc.AddInput(box_ind);
         desc.AddInput(crop_size);

         if (method != null) desc.SetAttr("method", method);
         if (extrapolation_value != 0f) desc.SetAttr("extrapolation_value", extrapolation_value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="prefix">Input to the operation. </param>
      ///<param name="tensor_names">Input to the operation. </param>
      ///<param name="shape_and_slices">Input to the operation. </param>
      ///<param name="tensors">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation SaveV2 (  Output prefix , Output tensor_names , Output shape_and_slices , Output tensors ,String opName= "SaveV2" ) 
      {
         OperationDescription desc = NewOperation("SaveV2", opName);
         desc.AddInput(prefix);
         desc.AddInput(tensor_names);
         desc.AddInput(shape_and_slices);
         desc.AddInput(tensors);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="grads">Input to the operation. </param>
      ///<param name="boxes">Input to the operation. </param>
      ///<param name="box_ind">Input to the operation. </param>
      ///<param name="image_size">Input to the operation. </param>
      ///<param name="T"></param>
      ///<param name="method"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation CropAndResizeGradImage (  Output grads , Output boxes , Output box_ind , Output image_size , DataType T, string method = null ,String opName= "CropAndResizeGradImage" ) 
      {
         OperationDescription desc = NewOperation("CropAndResizeGradImage", opName);
         desc.AddInput(grads);
         desc.AddInput(boxes);
         desc.AddInput(box_ind);
         desc.AddInput(image_size);
         desc.SetAttr("T", T);
         if (method != null) desc.SetAttr("method", method);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="compression_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] reader_handle(type: DtResource).
      ///</return>
      public Operation TFRecordReaderV2 (  string container = null , string shared_name = null , string compression_type = null ,String opName= "TFRecordReaderV2" ) 
      {
         OperationDescription desc = NewOperation("TFRecordReaderV2", opName);


         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         if (compression_type != null) desc.SetAttr("compression_type", compression_type);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Atanh (  Output x ,String opName= "Atanh" ) 
      {
         OperationDescription desc = NewOperation("Atanh", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="boxes">Input to the operation. </param>
      ///<param name="scores">Input to the operation. </param>
      ///<param name="max_output_size">Input to the operation. </param>
      ///<param name="iou_threshold"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] selected_indices(type: DtInt32).
      ///</return>
      public Operation NonMaxSuppression (  Output boxes , Output scores , Output max_output_size , float iou_threshold = 0.5f ,String opName= "NonMaxSuppression" ) 
      {
         OperationDescription desc = NewOperation("NonMaxSuppression", opName);
         desc.AddInput(boxes);
         desc.AddInput(scores);
         desc.AddInput(max_output_size);

         if (iou_threshold != 0.5f) desc.SetAttr("iou_threshold", iou_threshold);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="grads">Input to the operation. </param>
      ///<param name="image">Input to the operation. </param>
      ///<param name="boxes">Input to the operation. </param>
      ///<param name="box_ind">Input to the operation. </param>
      ///<param name="method"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtFloat).
      ///</return>
      public Operation CropAndResizeGradBoxes (  Output grads , Output image , Output boxes , Output box_ind , string method = null ,String opName= "CropAndResizeGradBoxes" ) 
      {
         OperationDescription desc = NewOperation("CropAndResizeGradBoxes", opName);
         desc.AddInput(grads);
         desc.AddInput(image);
         desc.AddInput(boxes);
         desc.AddInput(box_ind);

         if (method != null) desc.SetAttr("method", method);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="filter_sizes">Input to the operation. </param>
      ///<param name="out_backprop">Input to the operation. </param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="data_format"></param>
      ///<param name="dilations"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Conv3DBackpropFilterV2 (  Output input , Output filter_sizes , Output out_backprop , long[] strides, string padding, string data_format = null , long[] dilations = null ,String opName= "Conv3DBackpropFilterV2" ) 
      {
         OperationDescription desc = NewOperation("Conv3DBackpropFilterV2", opName);
         desc.AddInput(input);
         desc.AddInput(filter_sizes);
         desc.AddInput(out_backprop);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         if (dilations != null) desc.SetAttr("dilations", dilations);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="segment_ids">Input to the operation. </param>
      ///<param name="num_segments">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation UnsortedSegmentMin (  Output data , Output segment_ids , Output num_segments ,String opName= "UnsortedSegmentMin" ) 
      {
         OperationDescription desc = NewOperation("UnsortedSegmentMin", opName);
         desc.AddInput(data);
         desc.AddInput(segment_ids);
         desc.AddInput(num_segments);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="key_dtype"></param>
      ///<param name="value_dtype"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="use_node_name_sharing"></param>
      ///<param name="value_shape"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] table_handle(type: DtString).
      ///</return>
      public Operation MutableHashTableOfTensors (  DataType key_dtype, DataType value_dtype, string container = null , string shared_name = null , bool use_node_name_sharing = false , long[] value_shape = null ,String opName= "MutableHashTableOfTensors" ) 
      {
         OperationDescription desc = NewOperation("MutableHashTableOfTensors", opName);

         desc.SetAttr("key_dtype", key_dtype);
         desc.SetAttr("value_dtype", value_dtype);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         if (use_node_name_sharing != false) desc.SetAttr("use_node_name_sharing", use_node_name_sharing);
         if (value_shape != null) desc.SetAttrShape("value_shape", value_shape);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="filename">Input to the operation. </param>
      ///<param name="tensor_names">Input to the operation. </param>
      ///<param name="data">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation Save (  Output filename , Output tensor_names , Output data ,String opName= "Save" ) 
      {
         OperationDescription desc = NewOperation("Save", opName);
         desc.AddInput(filename);
         desc.AddInput(tensor_names);
         desc.AddInput(data);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="k">Input to the operation. </param>
      ///<param name="sorted"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] values(type: DtInvalid).
      ///[1] indices(type: DtInt32).
      ///</return>
      public Operation TopKV2 (  Output input , Output k , bool sorted = true ,String opName= "TopKV2" ) 
      {
         OperationDescription desc = NewOperation("TopKV2", opName);
         desc.AddInput(input);
         desc.AddInput(k);

         if (sorted != true) desc.SetAttr("sorted", sorted);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="file_pattern">Input to the operation. </param>
      ///<param name="tensor_name">Input to the operation. </param>
      ///<param name="dt"></param>
      ///<param name="preferred_shard"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] tensor(type: DtInvalid).
      ///</return>
      public Operation Restore (  Output file_pattern , Output tensor_name , DataType dt, long preferred_shard = -1 ,String opName= "Restore" ) 
      {
         OperationDescription desc = NewOperation("Restore", opName);
         desc.AddInput(file_pattern);
         desc.AddInput(tensor_name);
         desc.SetAttr("dt", dt);
         if (preferred_shard != -1) desc.SetAttr("preferred_shard", preferred_shard);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="basename">Input to the operation. </param>
      ///<param name="shard">Input to the operation. </param>
      ///<param name="num_shards">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] filename(type: DtString).
      ///</return>
      public Operation ShardedFilename (  Output basename , Output shard , Output num_shards ,String opName= "ShardedFilename" ) 
      {
         OperationDescription desc = NewOperation("ShardedFilename", opName);
         desc.AddInput(basename);
         desc.AddInput(shard);
         desc.AddInput(num_shards);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="value">Input to the operation. </param>
      ///<param name="bias">Input to the operation. </param>
      ///<param name="data_format"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation BiasAdd (  Output value , Output bias , string data_format = null ,String opName= "BiasAdd" ) 
      {
         OperationDescription desc = NewOperation("BiasAdd", opName);
         desc.AddInput(value);
         desc.AddInput(bias);

         if (data_format != null) desc.SetAttr("data_format", data_format);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="basename">Input to the operation. </param>
      ///<param name="num_shards">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] filename(type: DtString).
      ///</return>
      public Operation ShardedFilespec (  Output basename , Output num_shards ,String opName= "ShardedFilespec" ) 
      {
         OperationDescription desc = NewOperation("ShardedFilespec", opName);
         desc.AddInput(basename);
         desc.AddInput(num_shards);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reference">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="updates">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_ref(type: DtInvalid).
      ///</return>
      public Operation ScatterMul (  Output reference , Output indices , Output updates , bool use_locking = false ,String opName= "ScatterMul" ) 
      {
         OperationDescription desc = NewOperation("ScatterMul", opName);
         desc.AddInput(reference);
         desc.AddInput(indices);
         desc.AddInput(updates);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] reader_handle(type: DtString).
      ///</return>
      public Operation WholeFileReader (  string container = null , string shared_name = null ,String opName= "WholeFileReader" ) 
      {
         OperationDescription desc = NewOperation("WholeFileReader", opName);


         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reader_handle">Input to the operation. </param>
      ///<param name="queue_handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] key(type: DtString).
      ///[1] value(type: DtString).
      ///</return>
      public Operation ReaderRead (  Output reader_handle , Output queue_handle ,String opName= "ReaderRead" ) 
      {
         OperationDescription desc = NewOperation("ReaderRead", opName);
         desc.AddInput(reader_handle);
         desc.AddInput(queue_handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reader_handle">Input to the operation. </param>
      ///<param name="queue_handle">Input to the operation. </param>
      ///<param name="num_records">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] keys(type: DtString).
      ///[1] values(type: DtString).
      ///</return>
      public Operation ReaderReadUpToV2 (  Output reader_handle , Output queue_handle , Output num_records ,String opName= "ReaderReadUpToV2" ) 
      {
         OperationDescription desc = NewOperation("ReaderReadUpToV2", opName);
         desc.AddInput(reader_handle);
         desc.AddInput(queue_handle);
         desc.AddInput(num_records);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reader_handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] records_produced(type: DtInt64).
      ///</return>
      public Operation ReaderNumRecordsProduced (  Output reader_handle ,String opName= "ReaderNumRecordsProduced" ) 
      {
         OperationDescription desc = NewOperation("ReaderNumRecordsProduced", opName);
         desc.AddInput(reader_handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reader_handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] units_completed(type: DtInt64).
      ///</return>
      public Operation ReaderNumWorkUnitsCompleted (  Output reader_handle ,String opName= "ReaderNumWorkUnitsCompleted" ) 
      {
         OperationDescription desc = NewOperation("ReaderNumWorkUnitsCompleted", opName);
         desc.AddInput(reader_handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] sign(type: DtInvalid).
      ///[1] log_abs_determinant(type: DtInvalid).
      ///</return>
      public Operation LogMatrixDeterminant (  Output input ,String opName= "LogMatrixDeterminant" ) 
      {
         OperationDescription desc = NewOperation("LogMatrixDeterminant", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reader_handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] units_completed(type: DtInt64).
      ///</return>
      public Operation ReaderNumWorkUnitsCompletedV2 (  Output reader_handle ,String opName= "ReaderNumWorkUnitsCompletedV2" ) 
      {
         OperationDescription desc = NewOperation("ReaderNumWorkUnitsCompletedV2", opName);
         desc.AddInput(reader_handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reader_handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] state(type: DtString).
      ///</return>
      public Operation ReaderSerializeStateV2 (  Output reader_handle ,String opName= "ReaderSerializeStateV2" ) 
      {
         OperationDescription desc = NewOperation("ReaderSerializeStateV2", opName);
         desc.AddInput(reader_handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reader_handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation ReaderReset (  Output reader_handle ,String opName= "ReaderReset" ) 
      {
         OperationDescription desc = NewOperation("ReaderReset", opName);
         desc.AddInput(reader_handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="k"></param>
      ///<param name="sorted"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] values(type: DtInvalid).
      ///[1] indices(type: DtInt32).
      ///</return>
      public Operation TopK (  Output input , long k, bool sorted = true ,String opName= "TopK" ) 
      {
         OperationDescription desc = NewOperation("TopK", opName);
         desc.AddInput(input);
         desc.SetAttr("k", k);
         if (sorted != true) desc.SetAttr("sorted", sorted);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Cholesky (  Output input ,String opName= "Cholesky" ) 
      {
         OperationDescription desc = NewOperation("Cholesky", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="m">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="logbase">Input to the operation. </param>
      ///<param name="sign_decay">Input to the operation. </param>
      ///<param name="beta">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation ApplyPowerSign (  Output var , Output m , Output lr , Output logbase , Output sign_decay , Output beta , Output grad , bool use_locking = false ,String opName= "ApplyPowerSign" ) 
      {
         OperationDescription desc = NewOperation("ApplyPowerSign", opName);
         desc.AddInput(var);
         desc.AddInput(m);
         desc.AddInput(lr);
         desc.AddInput(logbase);
         desc.AddInput(sign_decay);
         desc.AddInput(beta);
         desc.AddInput(grad);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SelfAdjointEig (  Output input ,String opName= "SelfAdjointEig" ) 
      {
         OperationDescription desc = NewOperation("SelfAdjointEig", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="matrix">Input to the operation. </param>
      ///<param name="rhs">Input to the operation. </param>
      ///<param name="lower"></param>
      ///<param name="adjoint"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation MatrixTriangularSolve (  Output matrix , Output rhs , bool lower = true , bool adjoint = false ,String opName= "MatrixTriangularSolve" ) 
      {
         OperationDescription desc = NewOperation("MatrixTriangularSolve", opName);
         desc.AddInput(matrix);
         desc.AddInput(rhs);

         if (lower != true) desc.SetAttr("lower", lower);
         if (adjoint != false) desc.SetAttr("adjoint", adjoint);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reference">Input to the operation. </param>
      ///<param name="limit"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation CountUpTo (  Output reference , long limit,String opName= "CountUpTo" ) 
      {
         OperationDescription desc = NewOperation("CountUpTo", opName);
         desc.AddInput(reference);
         desc.SetAttr("limit", limit);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Exp (  Output x ,String opName= "Exp" ) 
      {
         OperationDescription desc = NewOperation("Exp", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="compute_uv"></param>
      ///<param name="full_matrices"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] s(type: DtInvalid).
      ///[1] u(type: DtInvalid).
      ///[2] v(type: DtInvalid).
      ///</return>
      public Operation Svd (  Output input , bool compute_uv = true , bool full_matrices = false ,String opName= "Svd" ) 
      {
         OperationDescription desc = NewOperation("Svd", opName);
         desc.AddInput(input);

         if (compute_uv != true) desc.SetAttr("compute_uv", compute_uv);
         if (full_matrices != false) desc.SetAttr("full_matrices", full_matrices);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="value">Input to the operation. </param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation RandomShuffle (  Output value , long seed = 0 , long seed2 = 0 ,String opName= "RandomShuffle" ) 
      {
         OperationDescription desc = NewOperation("RandomShuffle", opName);
         desc.AddInput(value);

         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="input_min">Input to the operation. </param>
      ///<param name="input_max">Input to the operation. </param>
      ///<param name="requested_output_min">Input to the operation. </param>
      ///<param name="requested_output_max">Input to the operation. </param>
      ///<param name="out_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///[1] output_min(type: DtFloat).
      ///[2] output_max(type: DtFloat).
      ///</return>
      public Operation Requantize (  Output input , Output input_min , Output input_max , Output requested_output_min , Output requested_output_max , DataType out_type,String opName= "Requantize" ) 
      {
         OperationDescription desc = NewOperation("Requantize", opName);
         desc.AddInput(input);
         desc.AddInput(input_min);
         desc.AddInput(input_max);
         desc.AddInput(requested_output_min);
         desc.AddInput(requested_output_max);
         desc.SetAttr("out_type", out_type);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation BatchSelfAdjointEig (  Output input ,String opName= "BatchSelfAdjointEig" ) 
      {
         OperationDescription desc = NewOperation("BatchSelfAdjointEig", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="l">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation BatchCholeskyGrad (  Output l , Output grad ,String opName= "BatchCholeskyGrad" ) 
      {
         OperationDescription desc = NewOperation("BatchCholeskyGrad", opName);
         desc.AddInput(l);
         desc.AddInput(grad);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="matrix">Input to the operation. </param>
      ///<param name="rhs">Input to the operation. </param>
      ///<param name="lower"></param>
      ///<param name="adjoint"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation BatchMatrixTriangularSolve (  Output matrix , Output rhs , bool lower = true , bool adjoint = false ,String opName= "BatchMatrixTriangularSolve" ) 
      {
         OperationDescription desc = NewOperation("BatchMatrixTriangularSolve", opName);
         desc.AddInput(matrix);
         desc.AddInput(rhs);

         if (lower != true) desc.SetAttr("lower", lower);
         if (adjoint != false) desc.SetAttr("adjoint", adjoint);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="table_handle">Input to the operation. </param>
      ///<param name="keys">Input to the operation. </param>
      ///<param name="values">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation LookupTableImport (  Output table_handle , Output keys , Output values ,String opName= "LookupTableImport" ) 
      {
         OperationDescription desc = NewOperation("LookupTableImport", opName);
         desc.AddInput(table_handle);
         desc.AddInput(keys);
         desc.AddInput(values);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="matrix">Input to the operation. </param>
      ///<param name="rhs">Input to the operation. </param>
      ///<param name="l2_regularizer">Input to the operation. </param>
      ///<param name="fast"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation BatchMatrixSolveLs (  Output matrix , Output rhs , Output l2_regularizer , bool fast = true ,String opName= "BatchMatrixSolveLs" ) 
      {
         OperationDescription desc = NewOperation("BatchMatrixSolveLs", opName);
         desc.AddInput(matrix);
         desc.AddInput(rhs);
         desc.AddInput(l2_regularizer);

         if (fast != true) desc.SetAttr("fast", fast);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtBool).
      ///</return>
      public Operation IsNan (  Output x ,String opName= "IsNan" ) 
      {
         OperationDescription desc = NewOperation("IsNan", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="compute_uv"></param>
      ///<param name="full_matrices"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] s(type: DtInvalid).
      ///[1] u(type: DtInvalid).
      ///[2] v(type: DtInvalid).
      ///</return>
      public Operation BatchSvd (  Output input , bool compute_uv = true , bool full_matrices = false ,String opName= "BatchSvd" ) 
      {
         OperationDescription desc = NewOperation("BatchSvd", opName);
         desc.AddInput(input);

         if (compute_uv != true) desc.SetAttr("compute_uv", compute_uv);
         if (full_matrices != false) desc.SetAttr("full_matrices", full_matrices);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_handle">Input to the operation. </param>
      ///<param name="tensor">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_handle(type: DtVariant).
      ///</return>
      public Operation TensorListPushBack (  Output input_handle , Output tensor ,String opName= "TensorListPushBack" ) 
      {
         OperationDescription desc = NewOperation("TensorListPushBack", opName);
         desc.AddInput(input_handle);
         desc.AddInput(tensor);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="reduction_indices">Input to the operation. </param>
      ///<param name="keep_dims"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Mean (  Output input , Output reduction_indices , bool keep_dims = false ,String opName= "Mean" ) 
      {
         OperationDescription desc = NewOperation("Mean", opName);
         desc.AddInput(input);
         desc.AddInput(reduction_indices);

         if (keep_dims != false) desc.SetAttr("keep_dims", keep_dims);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_handle">Input to the operation. </param>
      ///<param name="element_dtype"></param>
      ///<param name="num_elements"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] tensor(type: DtInvalid).
      ///</return>
      public Operation TensorListStack (  Output input_handle , DataType element_dtype, long num_elements = -1 ,String opName= "TensorListStack" ) 
      {
         OperationDescription desc = NewOperation("TensorListStack", opName);
         desc.AddInput(input_handle);
         desc.SetAttr("element_dtype", element_dtype);
         if (num_elements != -1) desc.SetAttr("num_elements", num_elements);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_handle">Input to the operation. </param>
      ///<param name="shape_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] element_shape(type: DtInvalid).
      ///</return>
      public Operation TensorListElementShape (  Output input_handle , DataType shape_type,String opName= "TensorListElementShape" ) 
      {
         OperationDescription desc = NewOperation("TensorListElementShape", opName);
         desc.AddInput(input_handle);
         desc.SetAttr("shape_type", shape_type);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reference">Input to the operation. </param>
      ///<param name="value">Input to the operation. </param>
      ///<param name="validate_shape"></param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_ref(type: DtInvalid).
      ///</return>
      public Operation Assign (  Output reference , Output value , bool validate_shape = true , bool use_locking = true ,String opName= "Assign" ) 
      {
         OperationDescription desc = NewOperation("Assign", opName);
         desc.AddInput(reference);
         desc.AddInput(value);

         if (validate_shape != true) desc.SetAttr("validate_shape", validate_shape);
         if (use_locking != true) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="element_shape">Input to the operation. </param>
      ///<param name="num_elements">Input to the operation. </param>
      ///<param name="element_dtype"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation TensorListReserve (  Output element_shape , Output num_elements , DataType element_dtype,String opName= "TensorListReserve" ) 
      {
         OperationDescription desc = NewOperation("TensorListReserve", opName);
         desc.AddInput(element_shape);
         desc.AddInput(num_elements);
         desc.SetAttr("element_dtype", element_dtype);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="condition">Input to the operation. </param>
      ///<param name="data">Input to the operation. </param>
      ///<param name="summarize"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation Assert (  Output condition , Output data , long summarize = 3 ,String opName= "Assert" ) 
      {
         OperationDescription desc = NewOperation("Assert", opName);
         desc.AddInput(condition);
         desc.AddInput(data);

         if (summarize != 3) desc.SetAttr("summarize", summarize);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="tag">Input to the operation. </param>
      ///<param name="tensor">Input to the operation. </param>
      ///<param name="serialized_summary_metadata">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] summary(type: DtString).
      ///</return>
      public Operation TensorSummaryV2 (  Output tag , Output tensor , Output serialized_summary_metadata ,String opName= "TensorSummaryV2" ) 
      {
         OperationDescription desc = NewOperation("TensorSummaryV2", opName);
         desc.AddInput(tag);
         desc.AddInput(tensor);
         desc.AddInput(serialized_summary_metadata);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="tensor">Input to the operation. </param>
      ///<param name="description"></param>
      ///<param name="labels"></param>
      ///<param name="display_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] summary(type: DtString).
      ///</return>
      public Operation TensorSummary (  Output tensor , string description = null , string[] labels = null , string display_name = null ,String opName= "TensorSummary" ) 
      {
         OperationDescription desc = NewOperation("TensorSummary", opName);
         desc.AddInput(tensor);

         if (description != null) desc.SetAttr("description", description);
         if (labels != null) desc.SetAttr("labels", labels);
         if (display_name != null) desc.SetAttr("display_name", display_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="tag">Input to the operation. </param>
      ///<param name="values">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] summary(type: DtString).
      ///</return>
      public Operation HistogramSummary (  Output tag , Output values ,String opName= "HistogramSummary" ) 
      {
         OperationDescription desc = NewOperation("HistogramSummary", opName);
         desc.AddInput(tag);
         desc.AddInput(values);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="tag">Input to the operation. </param>
      ///<param name="tensor">Input to the operation. </param>
      ///<param name="sample_rate">Input to the operation. </param>
      ///<param name="max_outputs"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] summary(type: DtString).
      ///</return>
      public Operation AudioSummaryV2 (  Output tag , Output tensor , Output sample_rate , long max_outputs = 3 ,String opName= "AudioSummaryV2" ) 
      {
         OperationDescription desc = NewOperation("AudioSummaryV2", opName);
         desc.AddInput(tag);
         desc.AddInput(tensor);
         desc.AddInput(sample_rate);

         if (max_outputs != 3) desc.SetAttr("max_outputs", max_outputs);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="tag">Input to the operation. </param>
      ///<param name="tensor">Input to the operation. </param>
      ///<param name="sample_rate"></param>
      ///<param name="max_outputs"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] summary(type: DtString).
      ///</return>
      public Operation AudioSummary (  Output tag , Output tensor , float sample_rate, long max_outputs = 3 ,String opName= "AudioSummary" ) 
      {
         OperationDescription desc = NewOperation("AudioSummary", opName);
         desc.AddInput(tag);
         desc.AddInput(tensor);
         desc.SetAttr("sample_rate", sample_rate);
         if (max_outputs != 3) desc.SetAttr("max_outputs", max_outputs);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="inputs">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] summary(type: DtString).
      ///</return>
      public Operation MergeSummary (  Output inputs ,String opName= "MergeSummary" ) 
      {
         OperationDescription desc = NewOperation("MergeSummary", opName);
         desc.AddInput(inputs);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] ts(type: DtDouble).
      ///</return>
      public Operation Timestamp ( String opName= "Timestamp" ) 
      {
         OperationDescription desc = NewOperation("Timestamp", opName);



         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="table_handle">Input to the operation. </param>
      ///<param name="keys">Input to the operation. </param>
      ///<param name="default_value">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] values(type: DtInvalid).
      ///</return>
      public Operation LookupTableFind (  Output table_handle , Output keys , Output default_value ,String opName= "LookupTableFind" ) 
      {
         OperationDescription desc = NewOperation("LookupTableFind", opName);
         desc.AddInput(table_handle);
         desc.AddInput(keys);
         desc.AddInput(default_value);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="gradients">Input to the operation. </param>
      ///<param name="outputs">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] backprops(type: DtInvalid).
      ///</return>
      public Operation SeluGrad (  Output gradients , Output outputs ,String opName= "SeluGrad" ) 
      {
         OperationDescription desc = NewOperation("SeluGrad", opName);
         desc.AddInput(gradients);
         desc.AddInput(outputs);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="table_handle">Input to the operation. </param>
      ///<param name="keys">Input to the operation. </param>
      ///<param name="default_value">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] values(type: DtInvalid).
      ///</return>
      public Operation LookupTableFindV2 (  Output table_handle , Output keys , Output default_value ,String opName= "LookupTableFindV2" ) 
      {
         OperationDescription desc = NewOperation("LookupTableFindV2", opName);
         desc.AddInput(table_handle);
         desc.AddInput(keys);
         desc.AddInput(default_value);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="tensor">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] serialized(type: DtString).
      ///</return>
      public Operation SerializeTensor (  Output tensor ,String opName= "SerializeTensor" ) 
      {
         OperationDescription desc = NewOperation("SerializeTensor", opName);
         desc.AddInput(tensor);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="table_handle">Input to the operation. </param>
      ///<param name="keys">Input to the operation. </param>
      ///<param name="values">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation LookupTableInsert (  Output table_handle , Output keys , Output values ,String opName= "LookupTableInsert" ) 
      {
         OperationDescription desc = NewOperation("LookupTableInsert", opName);
         desc.AddInput(table_handle);
         desc.AddInput(keys);
         desc.AddInput(values);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="y">Input to the operation. </param>
      ///<param name="dy">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation InvGrad (  Output y , Output dy ,String opName= "InvGrad" ) 
      {
         OperationDescription desc = NewOperation("InvGrad", opName);
         desc.AddInput(y);
         desc.AddInput(dy);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="table_handle">Input to the operation. </param>
      ///<param name="keys">Input to the operation. </param>
      ///<param name="values">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation LookupTableInsertV2 (  Output table_handle , Output keys , Output values ,String opName= "LookupTableInsertV2" ) 
      {
         OperationDescription desc = NewOperation("LookupTableInsertV2", opName);
         desc.AddInput(table_handle);
         desc.AddInput(keys);
         desc.AddInput(values);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="table_handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] size(type: DtInt64).
      ///</return>
      public Operation LookupTableSizeV2 (  Output table_handle ,String opName= "LookupTableSizeV2" ) 
      {
         OperationDescription desc = NewOperation("LookupTableSizeV2", opName);
         desc.AddInput(table_handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="table_handle">Input to the operation. </param>
      ///<param name="Tkeys"></param>
      ///<param name="Tvalues"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] keys(type: DtInvalid).
      ///[1] values(type: DtInvalid).
      ///</return>
      public Operation LookupTableExport (  Output table_handle , DataType Tkeys, DataType Tvalues,String opName= "LookupTableExport" ) 
      {
         OperationDescription desc = NewOperation("LookupTableExport", opName);
         desc.AddInput(table_handle);
         desc.SetAttr("Tkeys", Tkeys);
         desc.SetAttr("Tvalues", Tvalues);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Rsqrt (  Output x ,String opName= "Rsqrt" ) 
      {
         OperationDescription desc = NewOperation("Rsqrt", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="table_handle">Input to the operation. </param>
      ///<param name="Tkeys"></param>
      ///<param name="Tvalues"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] keys(type: DtInvalid).
      ///[1] values(type: DtInvalid).
      ///</return>
      public Operation LookupTableExportV2 (  Output table_handle , DataType Tkeys, DataType Tvalues,String opName= "LookupTableExportV2" ) 
      {
         OperationDescription desc = NewOperation("LookupTableExportV2", opName);
         desc.AddInput(table_handle);
         desc.SetAttr("Tkeys", Tkeys);
         desc.SetAttr("Tvalues", Tvalues);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="resource">Input to the operation. </param>
      ///<param name="value">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation AssignAddVariableOp (  Output resource , Output value ,String opName= "AssignAddVariableOp" ) 
      {
         OperationDescription desc = NewOperation("AssignAddVariableOp", opName);
         desc.AddInput(resource);
         desc.AddInput(value);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="table_handle">Input to the operation. </param>
      ///<param name="keys">Input to the operation. </param>
      ///<param name="values">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation LookupTableImportV2 (  Output table_handle , Output keys , Output values ,String opName= "LookupTableImportV2" ) 
      {
         OperationDescription desc = NewOperation("LookupTableImportV2", opName);
         desc.AddInput(table_handle);
         desc.AddInput(keys);
         desc.AddInput(values);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="key_dtype"></param>
      ///<param name="value_dtype"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="use_node_name_sharing"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] table_handle(type: DtString).
      ///</return>
      public Operation HashTable (  DataType key_dtype, DataType value_dtype, string container = null , string shared_name = null , bool use_node_name_sharing = false ,String opName= "HashTable" ) 
      {
         OperationDescription desc = NewOperation("HashTable", opName);

         desc.SetAttr("key_dtype", key_dtype);
         desc.SetAttr("value_dtype", value_dtype);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         if (use_node_name_sharing != false) desc.SetAttr("use_node_name_sharing", use_node_name_sharing);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="key_dtype"></param>
      ///<param name="value_dtype"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="use_node_name_sharing"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] table_handle(type: DtResource).
      ///</return>
      public Operation MutableHashTableV2 (  DataType key_dtype, DataType value_dtype, string container = null , string shared_name = null , bool use_node_name_sharing = false ,String opName= "MutableHashTableV2" ) 
      {
         OperationDescription desc = NewOperation("MutableHashTableV2", opName);

         desc.SetAttr("key_dtype", key_dtype);
         desc.SetAttr("value_dtype", value_dtype);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         if (use_node_name_sharing != false) desc.SetAttr("use_node_name_sharing", use_node_name_sharing);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="empty_key">Input to the operation. </param>
      ///<param name="value_dtype"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="use_node_name_sharing"></param>
      ///<param name="value_shape"></param>
      ///<param name="initial_num_buckets"></param>
      ///<param name="max_load_factor"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] table_handle(type: DtString).
      ///</return>
      public Operation MutableDenseHashTable (  Output empty_key , DataType value_dtype, string container = null , string shared_name = null , bool use_node_name_sharing = false , long[] value_shape = null , long initial_num_buckets = 131072 , float max_load_factor = 0.8f ,String opName= "MutableDenseHashTable" ) 
      {
         OperationDescription desc = NewOperation("MutableDenseHashTable", opName);
         desc.AddInput(empty_key);
         desc.SetAttr("value_dtype", value_dtype);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         if (use_node_name_sharing != false) desc.SetAttr("use_node_name_sharing", use_node_name_sharing);
         if (value_shape != null) desc.SetAttrShape("value_shape", value_shape);
         if (initial_num_buckets != 131072) desc.SetAttr("initial_num_buckets", initial_num_buckets);
         if (max_load_factor != 0.8f) desc.SetAttr("max_load_factor", max_load_factor);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="empty_key">Input to the operation. </param>
      ///<param name="value_dtype"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="use_node_name_sharing"></param>
      ///<param name="value_shape"></param>
      ///<param name="initial_num_buckets"></param>
      ///<param name="max_load_factor"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] table_handle(type: DtResource).
      ///</return>
      public Operation MutableDenseHashTableV2 (  Output empty_key , DataType value_dtype, string container = null , string shared_name = null , bool use_node_name_sharing = false , long[] value_shape = null , long initial_num_buckets = 131072 , float max_load_factor = 0.8f ,String opName= "MutableDenseHashTableV2" ) 
      {
         OperationDescription desc = NewOperation("MutableDenseHashTableV2", opName);
         desc.AddInput(empty_key);
         desc.SetAttr("value_dtype", value_dtype);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         if (use_node_name_sharing != false) desc.SetAttr("use_node_name_sharing", use_node_name_sharing);
         if (value_shape != null) desc.SetAttrShape("value_shape", value_shape);
         if (initial_num_buckets != 131072) desc.SetAttr("initial_num_buckets", initial_num_buckets);
         if (max_load_factor != 0.8f) desc.SetAttr("max_load_factor", max_load_factor);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="set1">Input to the operation. </param>
      ///<param name="set2">Input to the operation. </param>
      ///<param name="set_operation"></param>
      ///<param name="validate_indices"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] result_indices(type: DtInt64).
      ///[1] result_values(type: DtInvalid).
      ///[2] result_shape(type: DtInt64).
      ///</return>
      public Operation DenseToDenseSetOperation (  Output set1 , Output set2 , string set_operation, bool validate_indices = true ,String opName= "DenseToDenseSetOperation" ) 
      {
         OperationDescription desc = NewOperation("DenseToDenseSetOperation", opName);
         desc.AddInput(set1);
         desc.AddInput(set2);
         desc.SetAttr("set_operation", set_operation);
         if (validate_indices != true) desc.SetAttr("validate_indices", validate_indices);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="shape">Input to the operation. </param>
      ///<param name="rate">Input to the operation. </param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation RandomPoisson (  Output shape , Output rate , long seed = 0 , long seed2 = 0 ,String opName= "RandomPoisson" ) 
      {
         OperationDescription desc = NewOperation("RandomPoisson", opName);
         desc.AddInput(shape);
         desc.AddInput(rate);

         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="table_handle">Input to the operation. </param>
      ///<param name="keys">Input to the operation. </param>
      ///<param name="values">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation InitializeTable (  Output table_handle , Output keys , Output values ,String opName= "InitializeTable" ) 
      {
         OperationDescription desc = NewOperation("InitializeTable", opName);
         desc.AddInput(table_handle);
         desc.AddInput(keys);
         desc.AddInput(values);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="shape">Input to the operation. </param>
      ///<param name="rate">Input to the operation. </param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="dtype"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation RandomPoissonV2 (  Output shape , Output rate , long seed = 0 , long seed2 = 0 , DataType? dtype = null ,String opName= "RandomPoissonV2" ) 
      {
         OperationDescription desc = NewOperation("RandomPoissonV2", opName);
         desc.AddInput(shape);
         desc.AddInput(rate);

         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         if (dtype.HasValue) desc.SetAttr("dtype", dtype.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="a">Input to the operation. </param>
      ///<param name="b">Input to the operation. </param>
      ///<param name="transpose_a"></param>
      ///<param name="transpose_b"></param>
      ///<param name="a_is_sparse"></param>
      ///<param name="b_is_sparse"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] product(type: DtFloat).
      ///</return>
      public Operation SparseMatMul (  Output a , Output b , bool transpose_a = false , bool transpose_b = false , bool a_is_sparse = false , bool b_is_sparse = false ,String opName= "SparseMatMul" ) 
      {
         OperationDescription desc = NewOperation("SparseMatMul", opName);
         desc.AddInput(a);
         desc.AddInput(b);

         if (transpose_a != false) desc.SetAttr("transpose_a", transpose_a);
         if (transpose_b != false) desc.SetAttr("transpose_b", transpose_b);
         if (a_is_sparse != false) desc.SetAttr("a_is_sparse", a_is_sparse);
         if (b_is_sparse != false) desc.SetAttr("b_is_sparse", b_is_sparse);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="table_handle">Input to the operation. </param>
      ///<param name="keys">Input to the operation. </param>
      ///<param name="values">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation InitializeTableV2 (  Output table_handle , Output keys , Output values ,String opName= "InitializeTableV2" ) 
      {
         OperationDescription desc = NewOperation("InitializeTableV2", opName);
         desc.AddInput(table_handle);
         desc.AddInput(keys);
         desc.AddInput(values);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="m">Input to the operation. </param>
      ///<param name="v">Input to the operation. </param>
      ///<param name="beta1_power">Input to the operation. </param>
      ///<param name="beta2_power">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="beta1">Input to the operation. </param>
      ///<param name="beta2">Input to the operation. </param>
      ///<param name="epsilon">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="use_nesterov"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation ApplyAdam (  Output var , Output m , Output v , Output beta1_power , Output beta2_power , Output lr , Output beta1 , Output beta2 , Output epsilon , Output grad , bool use_locking = false , bool use_nesterov = false ,String opName= "ApplyAdam" ) 
      {
         OperationDescription desc = NewOperation("ApplyAdam", opName);
         desc.AddInput(var);
         desc.AddInput(m);
         desc.AddInput(v);
         desc.AddInput(beta1_power);
         desc.AddInput(beta2_power);
         desc.AddInput(lr);
         desc.AddInput(beta1);
         desc.AddInput(beta2);
         desc.AddInput(epsilon);
         desc.AddInput(grad);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         if (use_nesterov != false) desc.SetAttr("use_nesterov", use_nesterov);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="table_handle">Input to the operation. </param>
      ///<param name="filename">Input to the operation. </param>
      ///<param name="key_index"></param>
      ///<param name="value_index"></param>
      ///<param name="vocab_size"></param>
      ///<param name="delimiter"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation InitializeTableFromTextFile (  Output table_handle , Output filename , long key_index, long value_index, long vocab_size = -1 , string delimiter = null ,String opName= "InitializeTableFromTextFile" ) 
      {
         OperationDescription desc = NewOperation("InitializeTableFromTextFile", opName);
         desc.AddInput(table_handle);
         desc.AddInput(filename);
         desc.SetAttr("key_index", key_index);
         desc.SetAttr("value_index", value_index);
         if (vocab_size != -1) desc.SetAttr("vocab_size", vocab_size);
         if (delimiter != null) desc.SetAttr("delimiter", delimiter);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Tanh (  Output x ,String opName= "Tanh" ) 
      {
         OperationDescription desc = NewOperation("Tanh", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="table_handle">Input to the operation. </param>
      ///<param name="filename">Input to the operation. </param>
      ///<param name="key_index"></param>
      ///<param name="value_index"></param>
      ///<param name="vocab_size"></param>
      ///<param name="delimiter"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation InitializeTableFromTextFileV2 (  Output table_handle , Output filename , long key_index, long value_index, long vocab_size = -1 , string delimiter = null ,String opName= "InitializeTableFromTextFileV2" ) 
      {
         OperationDescription desc = NewOperation("InitializeTableFromTextFileV2", opName);
         desc.AddInput(table_handle);
         desc.AddInput(filename);
         desc.SetAttr("key_index", key_index);
         desc.SetAttr("value_index", value_index);
         if (vocab_size != -1) desc.SetAttr("vocab_size", vocab_size);
         if (delimiter != null) desc.SetAttr("delimiter", delimiter);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="linear">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="l1">Input to the operation. </param>
      ///<param name="l2">Input to the operation. </param>
      ///<param name="l2_shrinkage">Input to the operation. </param>
      ///<param name="lr_power">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceSparseApplyFtrlV2 (  Output var , Output accum , Output linear , Output grad , Output indices , Output lr , Output l1 , Output l2 , Output l2_shrinkage , Output lr_power , bool use_locking = false ,String opName= "ResourceSparseApplyFtrlV2" ) 
      {
         OperationDescription desc = NewOperation("ResourceSparseApplyFtrlV2", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(linear);
         desc.AddInput(grad);
         desc.AddInput(indices);
         desc.AddInput(lr);
         desc.AddInput(l1);
         desc.AddInput(l2);
         desc.AddInput(l2_shrinkage);
         desc.AddInput(lr_power);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="inputs">Input to the operation. </param>
      ///<param name="shape"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] sum(type: DtInvalid).
      ///</return>
      public Operation AccumulateNV2 (  Output inputs , long[] shape,String opName= "AccumulateNV2" ) 
      {
         OperationDescription desc = NewOperation("AccumulateNV2", opName);
         desc.AddInput(inputs);
         desc.SetAttrShape("shape", shape);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="adj_x"></param>
      ///<param name="adj_y"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation BatchMatMul (  Output x , Output y , bool adj_x = false , bool adj_y = false ,String opName= "BatchMatMul" ) 
      {
         OperationDescription desc = NewOperation("BatchMatMul", opName);
         desc.AddInput(x);
         desc.AddInput(y);

         if (adj_x != false) desc.SetAttr("adj_x", adj_x);
         if (adj_y != false) desc.SetAttr("adj_y", adj_y);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="DstT"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Cast (  Output x , DataType DstT,String opName= "Cast" ) 
      {
         OperationDescription desc = NewOperation("Cast", opName);
         desc.AddInput(x);
         desc.SetAttr("DstT", DstT);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Abs (  Output x ,String opName= "Abs" ) 
      {
         OperationDescription desc = NewOperation("Abs", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="filter">Input to the operation. </param>
      ///<param name="strides"></param>
      ///<param name="rates"></param>
      ///<param name="padding"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Dilation2D (  Output input , Output filter , long[] strides, long[] rates, string padding,String opName= "Dilation2D" ) 
      {
         OperationDescription desc = NewOperation("Dilation2D", opName);
         desc.AddInput(input);
         desc.AddInput(filter);
         desc.SetAttr("strides", strides);
         desc.SetAttr("rates", rates);
         desc.SetAttr("padding", padding);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Neg (  Output x ,String opName= "Neg" ) 
      {
         OperationDescription desc = NewOperation("Neg", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Reciprocal (  Output x ,String opName= "Reciprocal" ) 
      {
         OperationDescription desc = NewOperation("Reciprocal", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="logits">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] softmax(type: DtInvalid).
      ///</return>
      public Operation Softmax (  Output logits ,String opName= "Softmax" ) 
      {
         OperationDescription desc = NewOperation("Softmax", opName);
         desc.AddInput(logits);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Erfc (  Output x ,String opName= "Erfc" ) 
      {
         OperationDescription desc = NewOperation("Erfc", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="y">Input to the operation. </param>
      ///<param name="dy">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation ReciprocalGrad (  Output y , Output dy ,String opName= "ReciprocalGrad" ) 
      {
         OperationDescription desc = NewOperation("ReciprocalGrad", opName);
         desc.AddInput(y);
         desc.AddInput(dy);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="src_format"></param>
      ///<param name="dst_format"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation DataFormatVecPermute (  Output x , string src_format = null , string dst_format = null ,String opName= "DataFormatVecPermute" ) 
      {
         OperationDescription desc = NewOperation("DataFormatVecPermute", opName);
         desc.AddInput(x);

         if (src_format != null) desc.SetAttr("src_format", src_format);
         if (dst_format != null) desc.SetAttr("dst_format", dst_format);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Square (  Output x ,String opName= "Square" ) 
      {
         OperationDescription desc = NewOperation("Square", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Sqrt (  Output x ,String opName= "Sqrt" ) 
      {
         OperationDescription desc = NewOperation("Sqrt", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Log1p (  Output x ,String opName= "Log1p" ) 
      {
         OperationDescription desc = NewOperation("Log1p", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Cosh (  Output x ,String opName= "Cosh" ) 
      {
         OperationDescription desc = NewOperation("Cosh", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Acosh (  Output x ,String opName= "Acosh" ) 
      {
         OperationDescription desc = NewOperation("Acosh", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="shape">Input to the operation. </param>
      ///<param name="seed">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation StatelessRandomUniform (  Output shape , Output seed , DataType? dtype = null ,String opName= "StatelessRandomUniform" ) 
      {
         OperationDescription desc = NewOperation("StatelessRandomUniform", opName);
         desc.AddInput(shape);
         desc.AddInput(seed);

         if (dtype.HasValue) desc.SetAttr("dtype", dtype.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="y">Input to the operation. </param>
      ///<param name="dy">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation TanhGrad (  Output y , Output dy ,String opName= "TanhGrad" ) 
      {
         OperationDescription desc = NewOperation("TanhGrad", opName);
         desc.AddInput(y);
         desc.AddInput(dy);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Digamma (  Output x ,String opName= "Digamma" ) 
      {
         OperationDescription desc = NewOperation("Digamma", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="ksize"></param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="data_format"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation MaxPool3D (  Output input , long[] ksize, long[] strides, string padding, string data_format = null ,String opName= "MaxPool3D" ) 
      {
         OperationDescription desc = NewOperation("MaxPool3D", opName);
         desc.AddInput(input);
         desc.SetAttr("ksize", ksize);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Erf (  Output x ,String opName= "Erf" ) 
      {
         OperationDescription desc = NewOperation("Erf", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="y">Input to the operation. </param>
      ///<param name="dy">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation SigmoidGrad (  Output y , Output dy ,String opName= "SigmoidGrad" ) 
      {
         OperationDescription desc = NewOperation("SigmoidGrad", opName);
         desc.AddInput(y);
         desc.AddInput(dy);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="shape">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation RandomStandardNormal (  Output shape , DataType dtype, long seed = 0 , long seed2 = 0 ,String opName= "RandomStandardNormal" ) 
      {
         OperationDescription desc = NewOperation("RandomStandardNormal", opName);
         desc.AddInput(shape);
         desc.SetAttr("dtype", dtype);
         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Cos (  Output x ,String opName= "Cos" ) 
      {
         OperationDescription desc = NewOperation("Cos", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="input_min">Input to the operation. </param>
      ///<param name="input_max">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_min(type: DtFloat).
      ///[1] output_max(type: DtFloat).
      ///</return>
      public Operation RequantizationRange (  Output input , Output input_min , Output input_max ,String opName= "RequantizationRange" ) 
      {
         OperationDescription desc = NewOperation("RequantizationRange", opName);
         desc.AddInput(input);
         desc.AddInput(input_min);
         desc.AddInput(input_max);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Asin (  Output x ,String opName= "Asin" ) 
      {
         OperationDescription desc = NewOperation("Asin", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Acos (  Output x ,String opName= "Acos" ) 
      {
         OperationDescription desc = NewOperation("Acos", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Atan (  Output x ,String opName= "Atan" ) 
      {
         OperationDescription desc = NewOperation("Atan", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtBool).
      ///</return>
      public Operation IsFinite (  Output x ,String opName= "IsFinite" ) 
      {
         OperationDescription desc = NewOperation("IsFinite", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation Add (  Output x , Output y ,String opName= "Add" ) 
      {
         OperationDescription desc = NewOperation("Add", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 
      // Skipped function _MklAdd

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation Sub (  Output x , Output y ,String opName= "Sub" ) 
      {
         OperationDescription desc = NewOperation("Sub", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 
      // Skipped function _MklSub

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation Mul (  Output x , Output y ,String opName= "Mul" ) 
      {
         OperationDescription desc = NewOperation("Mul", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 
      // Skipped function _MklMul

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation FloorDiv (  Output x , Output y ,String opName= "FloorDiv" ) 
      {
         OperationDescription desc = NewOperation("FloorDiv", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="filter">Input to the operation. </param>
      ///<param name="out_backprop">Input to the operation. </param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Conv3DBackpropInput (  Output input , Output filter , Output out_backprop , long[] strides, string padding,String opName= "Conv3DBackpropInput" ) 
      {
         OperationDescription desc = NewOperation("Conv3DBackpropInput", opName);
         desc.AddInput(input);
         desc.AddInput(filter);
         desc.AddInput(out_backprop);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation TruncateDiv (  Output x , Output y ,String opName= "TruncateDiv" ) 
      {
         OperationDescription desc = NewOperation("TruncateDiv", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 
      // Skipped function _MklSquaredDifference
      // Skipped function _MklMaximum

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation Minimum (  Output x , Output y ,String opName= "Minimum" ) 
      {
         OperationDescription desc = NewOperation("Minimum", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation Pow (  Output x , Output y ,String opName= "Pow" ) 
      {
         OperationDescription desc = NewOperation("Pow", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="a">Input to the operation. </param>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation Igamma (  Output a , Output x ,String opName= "Igamma" ) 
      {
         OperationDescription desc = NewOperation("Igamma", opName);
         desc.AddInput(a);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="alpha">Input to the operation. </param>
      ///<param name="delta">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation ApplyGradientDescent (  Output var , Output alpha , Output delta , bool use_locking = false ,String opName= "ApplyGradientDescent" ) 
      {
         OperationDescription desc = NewOperation("ApplyGradientDescent", opName);
         desc.AddInput(var);
         desc.AddInput(alpha);
         desc.AddInput(delta);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="q">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation Zeta (  Output x , Output q ,String opName= "Zeta" ) 
      {
         OperationDescription desc = NewOperation("Zeta", opName);
         desc.AddInput(x);
         desc.AddInput(q);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="y">Input to the operation. </param>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation Atan2 (  Output y , Output x ,String opName= "Atan2" ) 
      {
         OperationDescription desc = NewOperation("Atan2", opName);
         desc.AddInput(y);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtBool).
      ///</return>
      public Operation LessEqual (  Output x , Output y ,String opName= "LessEqual" ) 
      {
         OperationDescription desc = NewOperation("LessEqual", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtBool).
      ///</return>
      public Operation Greater (  Output x , Output y ,String opName= "Greater" ) 
      {
         OperationDescription desc = NewOperation("Greater", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="alpha">Input to the operation. </param>
      ///<param name="delta">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceApplyGradientDescent (  Output var , Output alpha , Output delta , bool use_locking = false ,String opName= "ResourceApplyGradientDescent" ) 
      {
         OperationDescription desc = NewOperation("ResourceApplyGradientDescent", opName);
         desc.AddInput(var);
         desc.AddInput(alpha);
         desc.AddInput(delta);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtBool).
      ///</return>
      public Operation Equal (  Output x , Output y ,String opName= "Equal" ) 
      {
         OperationDescription desc = NewOperation("Equal", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="start">Input to the operation. </param>
      ///<param name="stop">Input to the operation. </param>
      ///<param name="num">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation LinSpace (  Output start , Output stop , Output num ,String opName= "LinSpace" ) 
      {
         OperationDescription desc = NewOperation("LinSpace", opName);
         desc.AddInput(start);
         desc.AddInput(stop);
         desc.AddInput(num);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtBool).
      ///</return>
      public Operation NotEqual (  Output x , Output y ,String opName= "NotEqual" ) 
      {
         OperationDescription desc = NewOperation("NotEqual", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="shape"></param>
      ///<param name="dtype"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] ref(type: DtInvalid).
      ///</return>
      public Operation Variable (  long[] shape, DataType dtype, string container = null , string shared_name = null ,String opName= "Variable" ) 
      {
         OperationDescription desc = NewOperation("Variable", opName);

         desc.SetAttrShape("shape", shape);
         desc.SetAttr("dtype", dtype);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtBool).
      ///</return>
      public Operation LogicalNot (  Output x ,String opName= "LogicalNot" ) 
      {
         OperationDescription desc = NewOperation("LogicalNot", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtBool).
      ///</return>
      public Operation LogicalAnd (  Output x , Output y ,String opName= "LogicalAnd" ) 
      {
         OperationDescription desc = NewOperation("LogicalAnd", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtBool).
      ///</return>
      public Operation LogicalOr (  Output x , Output y ,String opName= "LogicalOr" ) 
      {
         OperationDescription desc = NewOperation("LogicalOr", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="reduction_indices">Input to the operation. </param>
      ///<param name="keep_dims"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Sum (  Output input , Output reduction_indices , bool keep_dims = false ,String opName= "Sum" ) 
      {
         OperationDescription desc = NewOperation("Sum", opName);
         desc.AddInput(input);
         desc.AddInput(reduction_indices);

         if (keep_dims != false) desc.SetAttr("keep_dims", keep_dims);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="reduction_indices">Input to the operation. </param>
      ///<param name="keep_dims"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Max (  Output input , Output reduction_indices , bool keep_dims = false ,String opName= "Max" ) 
      {
         OperationDescription desc = NewOperation("Max", opName);
         desc.AddInput(input);
         desc.AddInput(reduction_indices);

         if (keep_dims != false) desc.SetAttr("keep_dims", keep_dims);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="dimension">Input to the operation. </param>
      ///<param name="output_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation ArgMax (  Output input , Output dimension , DataType? output_type = null ,String opName= "ArgMax" ) 
      {
         OperationDescription desc = NewOperation("ArgMax", opName);
         desc.AddInput(input);
         desc.AddInput(dimension);

         if (output_type.HasValue) desc.SetAttr("output_type", output_type.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="dimension">Input to the operation. </param>
      ///<param name="output_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation ArgMin (  Output input , Output dimension , DataType? output_type = null ,String opName= "ArgMin" ) 
      {
         OperationDescription desc = NewOperation("ArgMin", opName);
         desc.AddInput(input);
         desc.AddInput(dimension);

         if (output_type.HasValue) desc.SetAttr("output_type", output_type.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_grads">Input to the operation. </param>
      ///<param name="input_image">Input to the operation. </param>
      ///<param name="output_image">Input to the operation. </param>
      ///<param name="depth_radius"></param>
      ///<param name="bias"></param>
      ///<param name="alpha"></param>
      ///<param name="beta"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation LRNGrad (  Output input_grads , Output input_image , Output output_image , long depth_radius = 5 , float bias = 1f , float alpha = 1f , float beta = 0.5f ,String opName= "LRNGrad" ) 
      {
         OperationDescription desc = NewOperation("LRNGrad", opName);
         desc.AddInput(input_grads);
         desc.AddInput(input_image);
         desc.AddInput(output_image);

         if (depth_radius != 5) desc.SetAttr("depth_radius", depth_radius);
         if (bias != 1f) desc.SetAttr("bias", bias);
         if (alpha != 1f) desc.SetAttr("alpha", alpha);
         if (beta != 0.5f) desc.SetAttr("beta", beta);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="segment_ids">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SegmentMean (  Output data , Output segment_ids ,String opName= "SegmentMean" ) 
      {
         OperationDescription desc = NewOperation("SegmentMean", opName);
         desc.AddInput(data);
         desc.AddInput(segment_ids);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///Flushes and closes the summary writer.
      ///</summary>
      ///<param name="writer">Input to the operation: A handle to the summary writer resource.</param>
      ///<param name="opName">The name of the operation</param>
      public Operation CloseSummaryWriter (  Output writer ,String opName= "CloseSummaryWriter" ) 
      {
         OperationDescription desc = NewOperation("CloseSummaryWriter", opName);
         desc.AddInput(writer);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="segment_ids">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SegmentMin (  Output data , Output segment_ids ,String opName= "SegmentMin" ) 
      {
         OperationDescription desc = NewOperation("SegmentMin", opName);
         desc.AddInput(data);
         desc.AddInput(segment_ids);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="segment_ids">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SegmentMax (  Output data , Output segment_ids ,String opName= "SegmentMax" ) 
      {
         OperationDescription desc = NewOperation("SegmentMax", opName);
         desc.AddInput(data);
         desc.AddInput(segment_ids);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="segment_ids">Input to the operation. </param>
      ///<param name="num_segments">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation UnsortedSegmentSum (  Output data , Output segment_ids , Output num_segments ,String opName= "UnsortedSegmentSum" ) 
      {
         OperationDescription desc = NewOperation("UnsortedSegmentSum", opName);
         desc.AddInput(data);
         desc.AddInput(segment_ids);
         desc.AddInput(num_segments);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="segment_ids">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SparseSegmentSum (  Output data , Output indices , Output segment_ids ,String opName= "SparseSegmentSum" ) 
      {
         OperationDescription desc = NewOperation("SparseSegmentSum", opName);
         desc.AddInput(data);
         desc.AddInput(indices);
         desc.AddInput(segment_ids);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="m">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="alpha">Input to the operation. </param>
      ///<param name="sign_decay">Input to the operation. </param>
      ///<param name="beta">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceApplyAddSign (  Output var , Output m , Output lr , Output alpha , Output sign_decay , Output beta , Output grad , bool use_locking = false ,String opName= "ResourceApplyAddSign" ) 
      {
         OperationDescription desc = NewOperation("ResourceApplyAddSign", opName);
         desc.AddInput(var);
         desc.AddInput(m);
         desc.AddInput(lr);
         desc.AddInput(alpha);
         desc.AddInput(sign_decay);
         desc.AddInput(beta);
         desc.AddInput(grad);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="segment_ids">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SparseSegmentMean (  Output data , Output indices , Output segment_ids ,String opName= "SparseSegmentMean" ) 
      {
         OperationDescription desc = NewOperation("SparseSegmentMean", opName);
         desc.AddInput(data);
         desc.AddInput(indices);
         desc.AddInput(segment_ids);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="l1">Input to the operation. </param>
      ///<param name="l2">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation SparseApplyProximalAdagrad (  Output var , Output accum , Output lr , Output l1 , Output l2 , Output grad , Output indices , bool use_locking = false ,String opName= "SparseApplyProximalAdagrad" ) 
      {
         OperationDescription desc = NewOperation("SparseApplyProximalAdagrad", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(lr);
         desc.AddInput(l1);
         desc.AddInput(l2);
         desc.AddInput(grad);
         desc.AddInput(indices);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="segment_ids">Input to the operation. </param>
      ///<param name="output_dim0">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SparseSegmentMeanGrad (  Output grad , Output indices , Output segment_ids , Output output_dim0 ,String opName= "SparseSegmentMeanGrad" ) 
      {
         OperationDescription desc = NewOperation("SparseSegmentMeanGrad", opName);
         desc.AddInput(grad);
         desc.AddInput(indices);
         desc.AddInput(segment_ids);
         desc.AddInput(output_dim0);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="segment_ids">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SparseSegmentSqrtN (  Output data , Output indices , Output segment_ids ,String opName= "SparseSegmentSqrtN" ) 
      {
         OperationDescription desc = NewOperation("SparseSegmentSqrtN", opName);
         desc.AddInput(data);
         desc.AddInput(indices);
         desc.AddInput(segment_ids);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="ms">Input to the operation. </param>
      ///<param name="mom">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="rho">Input to the operation. </param>
      ///<param name="momentum">Input to the operation. </param>
      ///<param name="epsilon">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceSparseApplyRMSProp (  Output var , Output ms , Output mom , Output lr , Output rho , Output momentum , Output epsilon , Output grad , Output indices , bool use_locking = false ,String opName= "ResourceSparseApplyRMSProp" ) 
      {
         OperationDescription desc = NewOperation("ResourceSparseApplyRMSProp", opName);
         desc.AddInput(var);
         desc.AddInput(ms);
         desc.AddInput(mom);
         desc.AddInput(lr);
         desc.AddInput(rho);
         desc.AddInput(momentum);
         desc.AddInput(epsilon);
         desc.AddInput(grad);
         desc.AddInput(indices);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="segment_ids">Input to the operation. </param>
      ///<param name="output_dim0">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SparseSegmentSqrtNGrad (  Output grad , Output indices , Output segment_ids , Output output_dim0 ,String opName= "SparseSegmentSqrtNGrad" ) 
      {
         OperationDescription desc = NewOperation("SparseSegmentSqrtNGrad", opName);
         desc.AddInput(grad);
         desc.AddInput(indices);
         desc.AddInput(segment_ids);
         desc.AddInput(output_dim0);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="t">Input to the operation. </param>
      ///<param name="t_min">Input to the operation. </param>
      ///<param name="t_max">Input to the operation. </param>
      ///<param name="m">Input to the operation. </param>
      ///<param name="m_min">Input to the operation. </param>
      ///<param name="m_max">Input to the operation. </param>
      ///<param name="v">Input to the operation. </param>
      ///<param name="v_min">Input to the operation. </param>
      ///<param name="v_max">Input to the operation. </param>
      ///<param name="beta">Input to the operation. </param>
      ///<param name="beta_min">Input to the operation. </param>
      ///<param name="beta_max">Input to the operation. </param>
      ///<param name="gamma">Input to the operation. </param>
      ///<param name="gamma_min">Input to the operation. </param>
      ///<param name="gamma_max">Input to the operation. </param>
      ///<param name="out_type"></param>
      ///<param name="variance_epsilon"></param>
      ///<param name="scale_after_normalization"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] result(type: DtInvalid).
      ///[1] result_min(type: DtFloat).
      ///[2] result_max(type: DtFloat).
      ///</return>
      public Operation QuantizedBatchNormWithGlobalNormalization (  Output t , Output t_min , Output t_max , Output m , Output m_min , Output m_max , Output v , Output v_min , Output v_max , Output beta , Output beta_min , Output beta_max , Output gamma , Output gamma_min , Output gamma_max , DataType out_type, float variance_epsilon, bool scale_after_normalization,String opName= "QuantizedBatchNormWithGlobalNormalization" ) 
      {
         OperationDescription desc = NewOperation("QuantizedBatchNormWithGlobalNormalization", opName);
         desc.AddInput(t);
         desc.AddInput(t_min);
         desc.AddInput(t_max);
         desc.AddInput(m);
         desc.AddInput(m_min);
         desc.AddInput(m_max);
         desc.AddInput(v);
         desc.AddInput(v_min);
         desc.AddInput(v_max);
         desc.AddInput(beta);
         desc.AddInput(beta_min);
         desc.AddInput(beta_max);
         desc.AddInput(gamma);
         desc.AddInput(gamma_min);
         desc.AddInput(gamma_max);
         desc.SetAttr("out_type", out_type);
         desc.SetAttr("variance_epsilon", variance_epsilon);
         desc.SetAttr("scale_after_normalization", scale_after_normalization);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="reduction_indices">Input to the operation. </param>
      ///<param name="keep_dims"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtBool).
      ///</return>
      public Operation All (  Output input , Output reduction_indices , bool keep_dims = false ,String opName= "All" ) 
      {
         OperationDescription desc = NewOperation("All", opName);
         desc.AddInput(input);
         desc.AddInput(reduction_indices);

         if (keep_dims != false) desc.SetAttr("keep_dims", keep_dims);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="reduction_indices">Input to the operation. </param>
      ///<param name="keep_dims"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtBool).
      ///</return>
      public Operation Any (  Output input , Output reduction_indices , bool keep_dims = false ,String opName= "Any" ) 
      {
         OperationDescription desc = NewOperation("Any", opName);
         desc.AddInput(input);
         desc.AddInput(reduction_indices);

         if (keep_dims != false) desc.SetAttr("keep_dims", keep_dims);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="start">Input to the operation. </param>
      ///<param name="limit">Input to the operation. </param>
      ///<param name="delta">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Range (  Output start , Output limit , Output delta ,String opName= "Range" ) 
      {
         OperationDescription desc = NewOperation("Range", opName);
         desc.AddInput(start);
         desc.AddInput(limit);
         desc.AddInput(delta);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reference">Input to the operation. </param>
      ///<param name="value">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_ref(type: DtInvalid).
      ///</return>
      public Operation AssignAdd (  Output reference , Output value , bool use_locking = false ,String opName= "AssignAdd" ) 
      {
         OperationDescription desc = NewOperation("AssignAdd", opName);
         desc.AddInput(reference);
         desc.AddInput(value);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="real">Input to the operation. </param>
      ///<param name="imag">Input to the operation. </param>
      ///<param name="Tout"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation Complex (  Output real , Output imag , DataType? Tout = null ,String opName= "Complex" ) 
      {
         OperationDescription desc = NewOperation("Complex", opName);
         desc.AddInput(real);
         desc.AddInput(imag);

         if (Tout.HasValue) desc.SetAttr("Tout", Tout.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="resource">Input to the operation. </param>
      ///<param name="limit"></param>
      ///<param name="T"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation ResourceCountUpTo (  Output resource , long limit, DataType T,String opName= "ResourceCountUpTo" ) 
      {
         OperationDescription desc = NewOperation("ResourceCountUpTo", opName);
         desc.AddInput(resource);
         desc.SetAttr("limit", limit);
         desc.SetAttr("T", T);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="Tout"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Angle (  Output input , DataType? Tout = null ,String opName= "Angle" ) 
      {
         OperationDescription desc = NewOperation("Angle", opName);
         desc.AddInput(input);

         if (Tout.HasValue) desc.SetAttr("Tout", Tout.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="resource">Input to the operation. </param>
      ///<param name="value">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation AssignVariableOp (  Output resource , Output value ,String opName= "AssignVariableOp" ) 
      {
         OperationDescription desc = NewOperation("AssignVariableOp", opName);
         desc.AddInput(resource);
         desc.AddInput(value);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Conj (  Output input ,String opName= "Conj" ) 
      {
         OperationDescription desc = NewOperation("Conj", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="a">Input to the operation. </param>
      ///<param name="b">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] product(type: DtInvalid).
      ///</return>
      public Operation Cross (  Output a , Output b ,String opName= "Cross" ) 
      {
         OperationDescription desc = NewOperation("Cross", opName);
         desc.AddInput(a);
         desc.AddInput(b);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="values">Input to the operation. </param>
      ///<param name="value_range">Input to the operation. </param>
      ///<param name="nbins">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation HistogramFixedWidth (  Output values , Output value_range , Output nbins , DataType? dtype = null ,String opName= "HistogramFixedWidth" ) 
      {
         OperationDescription desc = NewOperation("HistogramFixedWidth", opName);
         desc.AddInput(values);
         desc.AddInput(value_range);
         desc.AddInput(nbins);

         if (dtype.HasValue) desc.SetAttr("dtype", dtype.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="arr">Input to the operation. </param>
      ///<param name="size">Input to the operation. </param>
      ///<param name="weights">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] bins(type: DtInvalid).
      ///</return>
      public Operation Bincount (  Output arr , Output size , Output weights ,String opName= "Bincount" ) 
      {
         OperationDescription desc = NewOperation("Bincount", opName);
         desc.AddInput(arr);
         desc.AddInput(size);
         desc.AddInput(weights);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="linear">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="l1">Input to the operation. </param>
      ///<param name="l2">Input to the operation. </param>
      ///<param name="l2_shrinkage">Input to the operation. </param>
      ///<param name="lr_power">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation SparseApplyFtrlV2 (  Output var , Output accum , Output linear , Output grad , Output indices , Output lr , Output l1 , Output l2 , Output l2_shrinkage , Output lr_power , bool use_locking = false ,String opName= "SparseApplyFtrlV2" ) 
      {
         OperationDescription desc = NewOperation("SparseApplyFtrlV2", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(linear);
         desc.AddInput(grad);
         desc.AddInput(indices);
         desc.AddInput(lr);
         desc.AddInput(l1);
         desc.AddInput(l2);
         desc.AddInput(l2_shrinkage);
         desc.AddInput(lr_power);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="t">Input to the operation. </param>
      ///<param name="m">Input to the operation. </param>
      ///<param name="v">Input to the operation. </param>
      ///<param name="beta">Input to the operation. </param>
      ///<param name="gamma">Input to the operation. </param>
      ///<param name="variance_epsilon"></param>
      ///<param name="scale_after_normalization"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] result(type: DtInvalid).
      ///</return>
      public Operation BatchNormWithGlobalNormalization (  Output t , Output m , Output v , Output beta , Output gamma , float variance_epsilon, bool scale_after_normalization,String opName= "BatchNormWithGlobalNormalization" ) 
      {
         OperationDescription desc = NewOperation("BatchNormWithGlobalNormalization", opName);
         desc.AddInput(t);
         desc.AddInput(m);
         desc.AddInput(v);
         desc.AddInput(beta);
         desc.AddInput(gamma);
         desc.SetAttr("variance_epsilon", variance_epsilon);
         desc.SetAttr("scale_after_normalization", scale_after_normalization);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="axis">Input to the operation. </param>
      ///<param name="exclusive"></param>
      ///<param name="reverse"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation Cumsum (  Output x , Output axis , bool exclusive = false , bool reverse = false ,String opName= "Cumsum" ) 
      {
         OperationDescription desc = NewOperation("Cumsum", opName);
         desc.AddInput(x);
         desc.AddInput(axis);

         if (exclusive != false) desc.SetAttr("exclusive", exclusive);
         if (reverse != false) desc.SetAttr("reverse", reverse);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="axis">Input to the operation. </param>
      ///<param name="exclusive"></param>
      ///<param name="reverse"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation Cumprod (  Output x , Output axis , bool exclusive = false , bool reverse = false ,String opName= "Cumprod" ) 
      {
         OperationDescription desc = NewOperation("Cumprod", opName);
         desc.AddInput(x);
         desc.AddInput(axis);

         if (exclusive != false) desc.SetAttr("exclusive", exclusive);
         if (reverse != false) desc.SetAttr("reverse", reverse);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="a">Input to the operation. </param>
      ///<param name="b">Input to the operation. </param>
      ///<param name="min_a">Input to the operation. </param>
      ///<param name="max_a">Input to the operation. </param>
      ///<param name="min_b">Input to the operation. </param>
      ///<param name="max_b">Input to the operation. </param>
      ///<param name="Toutput"></param>
      ///<param name="transpose_a"></param>
      ///<param name="transpose_b"></param>
      ///<param name="Tactivation"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///[1] min_out(type: DtFloat).
      ///[2] max_out(type: DtFloat).
      ///</return>
      public Operation QuantizedMatMul (  Output a , Output b , Output min_a , Output max_a , Output min_b , Output max_b , DataType? Toutput = null , bool transpose_a = false , bool transpose_b = false , DataType? Tactivation = null ,String opName= "QuantizedMatMul" ) 
      {
         OperationDescription desc = NewOperation("QuantizedMatMul", opName);
         desc.AddInput(a);
         desc.AddInput(b);
         desc.AddInput(min_a);
         desc.AddInput(max_a);
         desc.AddInput(min_b);
         desc.AddInput(max_b);

         if (Toutput.HasValue) desc.SetAttr("Toutput", Toutput.Value);
         if (transpose_a != false) desc.SetAttr("transpose_a", transpose_a);
         if (transpose_b != false) desc.SetAttr("transpose_b", transpose_b);
         if (Tactivation.HasValue) desc.SetAttr("Tactivation", Tactivation.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="features">Input to the operation. </param>
      ///<param name="labels">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] loss(type: DtInvalid).
      ///[1] backprop(type: DtInvalid).
      ///</return>
      public Operation SoftmaxCrossEntropyWithLogits (  Output features , Output labels ,String opName= "SoftmaxCrossEntropyWithLogits" ) 
      {
         OperationDescription desc = NewOperation("SoftmaxCrossEntropyWithLogits", opName);
         desc.AddInput(features);
         desc.AddInput(labels);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="min_x">Input to the operation. </param>
      ///<param name="max_x">Input to the operation. </param>
      ///<param name="min_y">Input to the operation. </param>
      ///<param name="max_y">Input to the operation. </param>
      ///<param name="Toutput"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///[1] min_z(type: DtFloat).
      ///[2] max_z(type: DtFloat).
      ///</return>
      public Operation QuantizedMul (  Output x , Output y , Output min_x , Output max_x , Output min_y , Output max_y , DataType? Toutput = null ,String opName= "QuantizedMul" ) 
      {
         OperationDescription desc = NewOperation("QuantizedMul", opName);
         desc.AddInput(x);
         desc.AddInput(y);
         desc.AddInput(min_x);
         desc.AddInput(max_x);
         desc.AddInput(min_y);
         desc.AddInput(max_y);

         if (Toutput.HasValue) desc.SetAttr("Toutput", Toutput.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="min_x">Input to the operation. </param>
      ///<param name="max_x">Input to the operation. </param>
      ///<param name="min_y">Input to the operation. </param>
      ///<param name="max_y">Input to the operation. </param>
      ///<param name="Toutput"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///[1] min_z(type: DtFloat).
      ///[2] max_z(type: DtFloat).
      ///</return>
      public Operation QuantizedAdd (  Output x , Output y , Output min_x , Output max_x , Output min_y , Output max_y , DataType? Toutput = null ,String opName= "QuantizedAdd" ) 
      {
         OperationDescription desc = NewOperation("QuantizedAdd", opName);
         desc.AddInput(x);
         desc.AddInput(y);
         desc.AddInput(min_x);
         desc.AddInput(max_x);
         desc.AddInput(min_y);
         desc.AddInput(max_y);

         if (Toutput.HasValue) desc.SetAttr("Toutput", Toutput.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="threshold">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtUint8).
      ///</return>
      public Operation CompareAndBitpack (  Output input , Output threshold ,String opName= "CompareAndBitpack" ) 
      {
         OperationDescription desc = NewOperation("CompareAndBitpack", opName);
         desc.AddInput(input);
         desc.AddInput(threshold);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="value">Input to the operation. </param>
      ///<param name="ksize"></param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="data_format"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation AvgPool (  Output value , long[] ksize, long[] strides, string padding, string data_format = null ,String opName= "AvgPool" ) 
      {
         OperationDescription desc = NewOperation("AvgPool", opName);
         desc.AddInput(value);
         desc.SetAttr("ksize", ksize);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="t">Input to the operation. </param>
      ///<param name="m">Input to the operation. </param>
      ///<param name="v">Input to the operation. </param>
      ///<param name="gamma">Input to the operation. </param>
      ///<param name="backprop">Input to the operation. </param>
      ///<param name="variance_epsilon"></param>
      ///<param name="scale_after_normalization"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] dx(type: DtInvalid).
      ///[1] dm(type: DtInvalid).
      ///[2] dv(type: DtInvalid).
      ///[3] db(type: DtInvalid).
      ///[4] dg(type: DtInvalid).
      ///</return>
      public Operation BatchNormWithGlobalNormalizationGrad (  Output t , Output m , Output v , Output gamma , Output backprop , float variance_epsilon, bool scale_after_normalization,String opName= "BatchNormWithGlobalNormalizationGrad" ) 
      {
         OperationDescription desc = NewOperation("BatchNormWithGlobalNormalizationGrad", opName);
         desc.AddInput(t);
         desc.AddInput(m);
         desc.AddInput(v);
         desc.AddInput(gamma);
         desc.AddInput(backprop);
         desc.SetAttr("variance_epsilon", variance_epsilon);
         desc.SetAttr("scale_after_normalization", scale_after_normalization);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="y_backprop">Input to the operation. </param>
      ///<param name="x">Input to the operation. </param>
      ///<param name="scale">Input to the operation. </param>
      ///<param name="reserve_space_1">Input to the operation. </param>
      ///<param name="reserve_space_2">Input to the operation. </param>
      ///<param name="epsilon"></param>
      ///<param name="data_format"></param>
      ///<param name="is_training"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] x_backprop(type: DtInvalid).
      ///[1] scale_backprop(type: DtInvalid).
      ///[2] offset_backprop(type: DtInvalid).
      ///[3] reserve_space_3(type: DtInvalid).
      ///[4] reserve_space_4(type: DtInvalid).
      ///</return>
      public Operation FusedBatchNormGradV2 (  Output y_backprop , Output x , Output scale , Output reserve_space_1 , Output reserve_space_2 , float epsilon = 0.0001f , string data_format = null , bool is_training = true ,String opName= "FusedBatchNormGradV2" ) 
      {
         OperationDescription desc = NewOperation("FusedBatchNormGradV2", opName);
         desc.AddInput(y_backprop);
         desc.AddInput(x);
         desc.AddInput(scale);
         desc.AddInput(reserve_space_1);
         desc.AddInput(reserve_space_2);

         if (epsilon != 0.0001f) desc.SetAttr("epsilon", epsilon);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         if (is_training != true) desc.SetAttr("is_training", is_training);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="out_backprop">Input to the operation. </param>
      ///<param name="data_format"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation BiasAddGrad (  Output out_backprop , string data_format = null ,String opName= "BiasAddGrad" ) 
      {
         OperationDescription desc = NewOperation("BiasAddGrad", opName);
         desc.AddInput(out_backprop);

         if (data_format != null) desc.SetAttr("data_format", data_format);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="value">Input to the operation. </param>
      ///<param name="bias">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation BiasAddV1 (  Output value , Output bias ,String opName= "BiasAddV1" ) 
      {
         OperationDescription desc = NewOperation("BiasAddV1", opName);
         desc.AddInput(value);
         desc.AddInput(bias);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="filter">Input to the operation. </param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="use_cudnn_on_gpu"></param>
      ///<param name="data_format"></param>
      ///<param name="dilations"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Conv2D (  Output input , Output filter , long[] strides, string padding, bool use_cudnn_on_gpu = true , string data_format = null , long[] dilations = null ,String opName= "Conv2D" ) 
      {
         OperationDescription desc = NewOperation("Conv2D", opName);
         desc.AddInput(input);
         desc.AddInput(filter);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);
         if (use_cudnn_on_gpu != true) desc.SetAttr("use_cudnn_on_gpu", use_cudnn_on_gpu);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         if (dilations != null) desc.SetAttr("dilations", dilations);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="sp_indices">Input to the operation. </param>
      ///<param name="sp_values">Input to the operation. </param>
      ///<param name="sp_shape">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SparseSoftmax (  Output sp_indices , Output sp_values , Output sp_shape ,String opName= "SparseSoftmax" ) 
      {
         OperationDescription desc = NewOperation("SparseSoftmax", opName);
         desc.AddInput(sp_indices);
         desc.AddInput(sp_values);
         desc.AddInput(sp_shape);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="filter_sizes">Input to the operation. </param>
      ///<param name="out_backprop">Input to the operation. </param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="use_cudnn_on_gpu"></param>
      ///<param name="data_format"></param>
      ///<param name="dilations"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Conv2DBackpropFilter (  Output input , Output filter_sizes , Output out_backprop , long[] strides, string padding, bool use_cudnn_on_gpu = true , string data_format = null , long[] dilations = null ,String opName= "Conv2DBackpropFilter" ) 
      {
         OperationDescription desc = NewOperation("Conv2DBackpropFilter", opName);
         desc.AddInput(input);
         desc.AddInput(filter_sizes);
         desc.AddInput(out_backprop);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);
         if (use_cudnn_on_gpu != true) desc.SetAttr("use_cudnn_on_gpu", use_cudnn_on_gpu);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         if (dilations != null) desc.SetAttr("dilations", dilations);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="size">Input to the operation. </param>
      ///<param name="paddings">Input to the operation. </param>
      ///<param name="filter">Input to the operation. </param>
      ///<param name="mode"></param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="resize_align_corners"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation FusedResizeAndPadConv2D (  Output input , Output size , Output paddings , Output filter , string mode, long[] strides, string padding, bool resize_align_corners = false ,String opName= "FusedResizeAndPadConv2D" ) 
      {
         OperationDescription desc = NewOperation("FusedResizeAndPadConv2D", opName);
         desc.AddInput(input);
         desc.AddInput(size);
         desc.AddInput(paddings);
         desc.AddInput(filter);
         desc.SetAttr("mode", mode);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);
         if (resize_align_corners != false) desc.SetAttr("resize_align_corners", resize_align_corners);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="sp_indices">Input to the operation. </param>
      ///<param name="sp_values">Input to the operation. </param>
      ///<param name="sp_shape">Input to the operation. </param>
      ///<param name="dense">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SparseDenseCwiseMul (  Output sp_indices , Output sp_values , Output sp_shape , Output dense ,String opName= "SparseDenseCwiseMul" ) 
      {
         OperationDescription desc = NewOperation("SparseDenseCwiseMul", opName);
         desc.AddInput(sp_indices);
         desc.AddInput(sp_values);
         desc.AddInput(sp_shape);
         desc.AddInput(dense);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="logits">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] logsoftmax(type: DtInvalid).
      ///</return>
      public Operation LogSoftmax (  Output logits ,String opName= "LogSoftmax" ) 
      {
         OperationDescription desc = NewOperation("LogSoftmax", opName);
         desc.AddInput(logits);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="paddings">Input to the operation. </param>
      ///<param name="filter">Input to the operation. </param>
      ///<param name="mode"></param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation FusedPadConv2D (  Output input , Output paddings , Output filter , string mode, long[] strides, string padding,String opName= "FusedPadConv2D" ) 
      {
         OperationDescription desc = NewOperation("FusedPadConv2D", opName);
         desc.AddInput(input);
         desc.AddInput(paddings);
         desc.AddInput(filter);
         desc.SetAttr("mode", mode);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="filter">Input to the operation. </param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="data_format"></param>
      ///<param name="dilations"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation DepthwiseConv2dNative (  Output input , Output filter , long[] strides, string padding, string data_format = null , long[] dilations = null ,String opName= "DepthwiseConv2dNative" ) 
      {
         OperationDescription desc = NewOperation("DepthwiseConv2dNative", opName);
         desc.AddInput(input);
         desc.AddInput(filter);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         if (dilations != null) desc.SetAttr("dilations", dilations);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="accum_update">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="rho">Input to the operation. </param>
      ///<param name="epsilon">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation SparseApplyAdadelta (  Output var , Output accum , Output accum_update , Output lr , Output rho , Output epsilon , Output grad , Output indices , bool use_locking = false ,String opName= "SparseApplyAdadelta" ) 
      {
         OperationDescription desc = NewOperation("SparseApplyAdadelta", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(accum_update);
         desc.AddInput(lr);
         desc.AddInput(rho);
         desc.AddInput(epsilon);
         desc.AddInput(grad);
         desc.AddInput(indices);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="filter_sizes">Input to the operation. </param>
      ///<param name="out_backprop">Input to the operation. </param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="data_format"></param>
      ///<param name="dilations"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation DepthwiseConv2dNativeBackpropFilter (  Output input , Output filter_sizes , Output out_backprop , long[] strides, string padding, string data_format = null , long[] dilations = null ,String opName= "DepthwiseConv2dNativeBackpropFilter" ) 
      {
         OperationDescription desc = NewOperation("DepthwiseConv2dNativeBackpropFilter", opName);
         desc.AddInput(input);
         desc.AddInput(filter_sizes);
         desc.AddInput(out_backprop);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         if (dilations != null) desc.SetAttr("dilations", dilations);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="ksize"></param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="data_format"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation AvgPool3D (  Output input , long[] ksize, long[] strides, string padding, string data_format = null ,String opName= "AvgPool3D" ) 
      {
         OperationDescription desc = NewOperation("AvgPool3D", opName);
         desc.AddInput(input);
         desc.SetAttr("ksize", ksize);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="orig_input">Input to the operation. </param>
      ///<param name="orig_output">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="ksize"></param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="data_format"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation MaxPool3DGrad (  Output orig_input , Output orig_output , Output grad , long[] ksize, long[] strides, string padding, string data_format = null ,String opName= "MaxPool3DGrad" ) 
      {
         OperationDescription desc = NewOperation("MaxPool3DGrad", opName);
         desc.AddInput(orig_input);
         desc.AddInput(orig_output);
         desc.AddInput(grad);
         desc.SetAttr("ksize", ksize);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="orig_input">Input to the operation. </param>
      ///<param name="orig_output">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="ksize"></param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="data_format"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation MaxPool3DGradGrad (  Output orig_input , Output orig_output , Output grad , long[] ksize, long[] strides, string padding, string data_format = null ,String opName= "MaxPool3DGradGrad" ) 
      {
         OperationDescription desc = NewOperation("MaxPool3DGradGrad", opName);
         desc.AddInput(orig_input);
         desc.AddInput(orig_output);
         desc.AddInput(grad);
         desc.SetAttr("ksize", ksize);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reference">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="updates">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_ref(type: DtInvalid).
      ///</return>
      public Operation ScatterDiv (  Output reference , Output indices , Output updates , bool use_locking = false ,String opName= "ScatterDiv" ) 
      {
         OperationDescription desc = NewOperation("ScatterDiv", opName);
         desc.AddInput(reference);
         desc.AddInput(indices);
         desc.AddInput(updates);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="t">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation L2Loss (  Output t ,String opName= "L2Loss" ) 
      {
         OperationDescription desc = NewOperation("L2Loss", opName);
         desc.AddInput(t);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="depth_radius"></param>
      ///<param name="bias"></param>
      ///<param name="alpha"></param>
      ///<param name="beta"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation LRN (  Output input , long depth_radius = 5 , float bias = 1f , float alpha = 1f , float beta = 0.5f ,String opName= "LRN" ) 
      {
         OperationDescription desc = NewOperation("LRN", opName);
         desc.AddInput(input);

         if (depth_radius != 5) desc.SetAttr("depth_radius", depth_radius);
         if (bias != 1f) desc.SetAttr("bias", bias);
         if (alpha != 1f) desc.SetAttr("alpha", alpha);
         if (beta != 0.5f) desc.SetAttr("beta", beta);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="orig_input">Input to the operation. </param>
      ///<param name="orig_output">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="ksize"></param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="data_format"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation MaxPoolGrad (  Output orig_input , Output orig_output , Output grad , long[] ksize, long[] strides, string padding, string data_format = null ,String opName= "MaxPoolGrad" ) 
      {
         OperationDescription desc = NewOperation("MaxPoolGrad", opName);
         desc.AddInput(orig_input);
         desc.AddInput(orig_output);
         desc.AddInput(grad);
         desc.SetAttr("ksize", ksize);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="orig_input">Input to the operation. </param>
      ///<param name="orig_output">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="ksize">Input to the operation. </param>
      ///<param name="strides">Input to the operation. </param>
      ///<param name="padding"></param>
      ///<param name="data_format"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation MaxPoolGradV2 (  Output orig_input , Output orig_output , Output grad , Output ksize , Output strides , string padding, string data_format = null ,String opName= "MaxPoolGradV2" ) 
      {
         OperationDescription desc = NewOperation("MaxPoolGradV2", opName);
         desc.AddInput(orig_input);
         desc.AddInput(orig_output);
         desc.AddInput(grad);
         desc.AddInput(ksize);
         desc.AddInput(strides);
         desc.SetAttr("padding", padding);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="features">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] activations(type: DtInvalid).
      ///</return>
      public Operation Elu (  Output features ,String opName= "Elu" ) 
      {
         OperationDescription desc = NewOperation("Elu", opName);
         desc.AddInput(features);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="orig_input">Input to the operation. </param>
      ///<param name="orig_output">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="ksize">Input to the operation. </param>
      ///<param name="strides">Input to the operation. </param>
      ///<param name="padding"></param>
      ///<param name="data_format"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation MaxPoolGradGradV2 (  Output orig_input , Output orig_output , Output grad , Output ksize , Output strides , string padding, string data_format = null ,String opName= "MaxPoolGradGradV2" ) 
      {
         OperationDescription desc = NewOperation("MaxPoolGradGradV2", opName);
         desc.AddInput(orig_input);
         desc.AddInput(orig_output);
         desc.AddInput(grad);
         desc.AddInput(ksize);
         desc.AddInput(strides);
         desc.SetAttr("padding", padding);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="fft_length">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtFloat).
      ///</return>
      public Operation IRFFT3D (  Output input , Output fft_length ,String opName= "IRFFT3D" ) 
      {
         OperationDescription desc = NewOperation("IRFFT3D", opName);
         desc.AddInput(input);
         desc.AddInput(fft_length);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="ksize"></param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="Targmax"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///[1] argmax(type: DtInvalid).
      ///</return>
      public Operation MaxPoolWithArgmax (  Output input , long[] ksize, long[] strides, string padding, DataType? Targmax = null ,String opName= "MaxPoolWithArgmax" ) 
      {
         OperationDescription desc = NewOperation("MaxPoolWithArgmax", opName);
         desc.AddInput(input);
         desc.SetAttr("ksize", ksize);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);
         if (Targmax.HasValue) desc.SetAttr("Targmax", Targmax.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="argmax">Input to the operation. </param>
      ///<param name="ksize"></param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation MaxPoolGradGradWithArgmax (  Output input , Output grad , Output argmax , long[] ksize, long[] strides, string padding,String opName= "MaxPoolGradGradWithArgmax" ) 
      {
         OperationDescription desc = NewOperation("MaxPoolGradGradWithArgmax", opName);
         desc.AddInput(input);
         desc.AddInput(grad);
         desc.AddInput(argmax);
         desc.SetAttr("ksize", ksize);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="filter">Input to the operation. </param>
      ///<param name="out_backprop">Input to the operation. </param>
      ///<param name="strides"></param>
      ///<param name="rates"></param>
      ///<param name="padding"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] in_backprop(type: DtInvalid).
      ///</return>
      public Operation Dilation2DBackpropInput (  Output input , Output filter , Output out_backprop , long[] strides, long[] rates, string padding,String opName= "Dilation2DBackpropInput" ) 
      {
         OperationDescription desc = NewOperation("Dilation2DBackpropInput", opName);
         desc.AddInput(input);
         desc.AddInput(filter);
         desc.AddInput(out_backprop);
         desc.SetAttr("strides", strides);
         desc.SetAttr("rates", rates);
         desc.SetAttr("padding", padding);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="filter">Input to the operation. </param>
      ///<param name="out_backprop">Input to the operation. </param>
      ///<param name="strides"></param>
      ///<param name="rates"></param>
      ///<param name="padding"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] filter_backprop(type: DtInvalid).
      ///</return>
      public Operation Dilation2DBackpropFilter (  Output input , Output filter , Output out_backprop , long[] strides, long[] rates, string padding,String opName= "Dilation2DBackpropFilter" ) 
      {
         OperationDescription desc = NewOperation("Dilation2DBackpropFilter", opName);
         desc.AddInput(input);
         desc.AddInput(filter);
         desc.AddInput(out_backprop);
         desc.SetAttr("strides", strides);
         desc.SetAttr("rates", rates);
         desc.SetAttr("padding", padding);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="features">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] activations(type: DtInvalid).
      ///</return>
      public Operation Relu (  Output features ,String opName= "Relu" ) 
      {
         OperationDescription desc = NewOperation("Relu", opName);
         desc.AddInput(features);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="gradients">Input to the operation. </param>
      ///<param name="features">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] backprops(type: DtInvalid).
      ///</return>
      public Operation ReluGrad (  Output gradients , Output features ,String opName= "ReluGrad" ) 
      {
         OperationDescription desc = NewOperation("ReluGrad", opName);
         desc.AddInput(gradients);
         desc.AddInput(features);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="features">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] activations(type: DtInvalid).
      ///</return>
      public Operation Selu (  Output features ,String opName= "Selu" ) 
      {
         OperationDescription desc = NewOperation("Selu", opName);
         desc.AddInput(features);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="gradients">Input to the operation. </param>
      ///<param name="features">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] backprops(type: DtInvalid).
      ///</return>
      public Operation SoftplusGrad (  Output gradients , Output features ,String opName= "SoftplusGrad" ) 
      {
         OperationDescription desc = NewOperation("SoftplusGrad", opName);
         desc.AddInput(gradients);
         desc.AddInput(features);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="features">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] activations(type: DtInvalid).
      ///</return>
      public Operation Softsign (  Output features ,String opName= "Softsign" ) 
      {
         OperationDescription desc = NewOperation("Softsign", opName);
         desc.AddInput(features);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="gradients">Input to the operation. </param>
      ///<param name="features">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] backprops(type: DtInvalid).
      ///</return>
      public Operation SoftsignGrad (  Output gradients , Output features ,String opName= "SoftsignGrad" ) 
      {
         OperationDescription desc = NewOperation("SoftsignGrad", opName);
         desc.AddInput(gradients);
         desc.AddInput(features);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="features">Input to the operation. </param>
      ///<param name="labels">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] loss(type: DtInvalid).
      ///[1] backprop(type: DtInvalid).
      ///</return>
      public Operation SparseSoftmaxCrossEntropyWithLogits (  Output features , Output labels ,String opName= "SparseSoftmaxCrossEntropyWithLogits" ) 
      {
         OperationDescription desc = NewOperation("SparseSoftmaxCrossEntropyWithLogits", opName);
         desc.AddInput(features);
         desc.AddInput(labels);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="shape">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation RandomUniform (  Output shape , DataType dtype, long seed = 0 , long seed2 = 0 ,String opName= "RandomUniform" ) 
      {
         OperationDescription desc = NewOperation("RandomUniform", opName);
         desc.AddInput(shape);
         desc.SetAttr("dtype", dtype);
         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="value">Input to the operation. </param>
      ///<param name="pooling_ratio"></param>
      ///<param name="pseudo_random"></param>
      ///<param name="overlapping"></param>
      ///<param name="deterministic"></param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///[1] row_pooling_sequence(type: DtInt64).
      ///[2] col_pooling_sequence(type: DtInt64).
      ///</return>
      public Operation FractionalMaxPool (  Output value , float[] pooling_ratio, bool pseudo_random = false , bool overlapping = false , bool deterministic = false , long seed = 0 , long seed2 = 0 ,String opName= "FractionalMaxPool" ) 
      {
         OperationDescription desc = NewOperation("FractionalMaxPool", opName);
         desc.AddInput(value);
         desc.SetAttr("pooling_ratio", pooling_ratio);
         if (pseudo_random != false) desc.SetAttr("pseudo_random", pseudo_random);
         if (overlapping != false) desc.SetAttr("overlapping", overlapping);
         if (deterministic != false) desc.SetAttr("deterministic", deterministic);
         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="min_input">Input to the operation. </param>
      ///<param name="max_input">Input to the operation. </param>
      ///<param name="ksize"></param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///[1] min_output(type: DtFloat).
      ///[2] max_output(type: DtFloat).
      ///</return>
      public Operation QuantizedAvgPool (  Output input , Output min_input , Output max_input , long[] ksize, long[] strides, string padding,String opName= "QuantizedAvgPool" ) 
      {
         OperationDescription desc = NewOperation("QuantizedAvgPool", opName);
         desc.AddInput(input);
         desc.AddInput(min_input);
         desc.AddInput(max_input);
         desc.SetAttr("ksize", ksize);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="bias">Input to the operation. </param>
      ///<param name="min_input">Input to the operation. </param>
      ///<param name="max_input">Input to the operation. </param>
      ///<param name="min_bias">Input to the operation. </param>
      ///<param name="max_bias">Input to the operation. </param>
      ///<param name="out_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///[1] min_out(type: DtFloat).
      ///[2] max_out(type: DtFloat).
      ///</return>
      public Operation QuantizedBiasAdd (  Output input , Output bias , Output min_input , Output max_input , Output min_bias , Output max_bias , DataType out_type,String opName= "QuantizedBiasAdd" ) 
      {
         OperationDescription desc = NewOperation("QuantizedBiasAdd", opName);
         desc.AddInput(input);
         desc.AddInput(bias);
         desc.AddInput(min_input);
         desc.AddInput(max_input);
         desc.AddInput(min_bias);
         desc.AddInput(max_bias);
         desc.SetAttr("out_type", out_type);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="filter">Input to the operation. </param>
      ///<param name="min_input">Input to the operation. </param>
      ///<param name="max_input">Input to the operation. </param>
      ///<param name="min_filter">Input to the operation. </param>
      ///<param name="max_filter">Input to the operation. </param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="out_type"></param>
      ///<param name="dilations"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///[1] min_output(type: DtFloat).
      ///[2] max_output(type: DtFloat).
      ///</return>
      public Operation QuantizedConv2D (  Output input , Output filter , Output min_input , Output max_input , Output min_filter , Output max_filter , long[] strides, string padding, DataType? out_type = null , long[] dilations = null ,String opName= "QuantizedConv2D" ) 
      {
         OperationDescription desc = NewOperation("QuantizedConv2D", opName);
         desc.AddInput(input);
         desc.AddInput(filter);
         desc.AddInput(min_input);
         desc.AddInput(max_input);
         desc.AddInput(min_filter);
         desc.AddInput(max_filter);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);
         if (out_type.HasValue) desc.SetAttr("out_type", out_type.Value);
         if (dilations != null) desc.SetAttr("dilations", dilations);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="features">Input to the operation. </param>
      ///<param name="min_features">Input to the operation. </param>
      ///<param name="max_features">Input to the operation. </param>
      ///<param name="out_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] activations(type: DtInvalid).
      ///[1] min_activations(type: DtFloat).
      ///[2] max_activations(type: DtFloat).
      ///</return>
      public Operation QuantizedRelu (  Output features , Output min_features , Output max_features , DataType? out_type = null ,String opName= "QuantizedRelu" ) 
      {
         OperationDescription desc = NewOperation("QuantizedRelu", opName);
         desc.AddInput(features);
         desc.AddInput(min_features);
         desc.AddInput(max_features);

         if (out_type.HasValue) desc.SetAttr("out_type", out_type.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="features">Input to the operation. </param>
      ///<param name="min_features">Input to the operation. </param>
      ///<param name="max_features">Input to the operation. </param>
      ///<param name="out_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] activations(type: DtInvalid).
      ///[1] min_activations(type: DtFloat).
      ///[2] max_activations(type: DtFloat).
      ///</return>
      public Operation QuantizedRelu6 (  Output features , Output min_features , Output max_features , DataType? out_type = null ,String opName= "QuantizedRelu6" ) 
      {
         OperationDescription desc = NewOperation("QuantizedRelu6", opName);
         desc.AddInput(features);
         desc.AddInput(min_features);
         desc.AddInput(max_features);

         if (out_type.HasValue) desc.SetAttr("out_type", out_type.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="features">Input to the operation. </param>
      ///<param name="max_value">Input to the operation. </param>
      ///<param name="min_features">Input to the operation. </param>
      ///<param name="max_features">Input to the operation. </param>
      ///<param name="out_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] activations(type: DtInvalid).
      ///[1] min_activations(type: DtFloat).
      ///[2] max_activations(type: DtFloat).
      ///</return>
      public Operation QuantizedReluX (  Output features , Output max_value , Output min_features , Output max_features , DataType? out_type = null ,String opName= "QuantizedReluX" ) 
      {
         OperationDescription desc = NewOperation("QuantizedReluX", opName);
         desc.AddInput(features);
         desc.AddInput(max_value);
         desc.AddInput(min_features);
         desc.AddInput(max_features);

         if (out_type.HasValue) desc.SetAttr("out_type", out_type.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="opName">The name of the operation</param>
      public Operation NoOp ( String opName= "NoOp" ) 
      {
         OperationDescription desc = NewOperation("NoOp", opName);



         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="bytes">Input to the operation. </param>
      ///<param name="out_type"></param>
      ///<param name="little_endian"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation DecodeRaw (  Output bytes , DataType out_type, bool little_endian = true ,String opName= "DecodeRaw" ) 
      {
         OperationDescription desc = NewOperation("DecodeRaw", opName);
         desc.AddInput(bytes);
         desc.SetAttr("out_type", out_type);
         if (little_endian != true) desc.SetAttr("little_endian", little_endian);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="bytes">Input to the operation. </param>
      ///<param name="compression_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtString).
      ///</return>
      public Operation DecodeCompressed (  Output bytes , string compression_type = null ,String opName= "DecodeCompressed" ) 
      {
         OperationDescription desc = NewOperation("DecodeCompressed", opName);
         desc.AddInput(bytes);

         if (compression_type != null) desc.SetAttr("compression_type", compression_type);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="serialized">Input to the operation. </param>
      ///<param name="names">Input to the operation. </param>
      ///<param name="sparse_keys">Input to the operation. </param>
      ///<param name="dense_keys">Input to the operation. </param>
      ///<param name="dense_defaults">Input to the operation. </param>
      ///<param name="sparse_types"></param>
      ///<param name="dense_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] sparse_indices(type: DtInt64).
      ///[1] sparse_values(type: DtInvalid).
      ///[2] sparse_shapes(type: DtInt64).
      ///[3] dense_values(type: DtInvalid).
      ///</return>
      public Operation ParseExample (  Output serialized , Output names , Output sparse_keys , Output dense_keys , Output dense_defaults , DataType[] sparse_types, long[][] dense_shapes,String opName= "ParseExample" ) 
      {
         OperationDescription desc = NewOperation("ParseExample", opName);
         desc.AddInput(serialized);
         desc.AddInput(names);
         desc.AddInput(sparse_keys);
         desc.AddInput(dense_keys);
         desc.AddInput(dense_defaults);
         desc.SetAttr("sparse_types", sparse_types);
         desc.SetAttrShapeList("dense_shapes", dense_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="string_tensor">Input to the operation. </param>
      ///<param name="out_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation StringToNumber (  Output string_tensor , DataType? out_type = null ,String opName= "StringToNumber" ) 
      {
         OperationDescription desc = NewOperation("StringToNumber", opName);
         desc.AddInput(string_tensor);

         if (out_type.HasValue) desc.SetAttr("out_type", out_type.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="mutex_lock">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation ConsumeMutexLock (  Output mutex_lock ,String opName= "ConsumeMutexLock" ) 
      {
         OperationDescription desc = NewOperation("ConsumeMutexLock", opName);
         desc.AddInput(mutex_lock);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="shape">Input to the operation. </param>
      ///<param name="minval">Input to the operation. </param>
      ///<param name="maxval">Input to the operation. </param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation RandomUniformInt (  Output shape , Output minval , Output maxval , long seed = 0 , long seed2 = 0 ,String opName= "RandomUniformInt" ) 
      {
         OperationDescription desc = NewOperation("RandomUniformInt", opName);
         desc.AddInput(shape);
         desc.AddInput(minval);
         desc.AddInput(maxval);

         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="shape">Input to the operation. </param>
      ///<param name="means">Input to the operation. </param>
      ///<param name="stdevs">Input to the operation. </param>
      ///<param name="minvals">Input to the operation. </param>
      ///<param name="maxvals">Input to the operation. </param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation ParameterizedTruncatedNormal (  Output shape , Output means , Output stdevs , Output minvals , Output maxvals , long seed = 0 , long seed2 = 0 ,String opName= "ParameterizedTruncatedNormal" ) 
      {
         OperationDescription desc = NewOperation("ParameterizedTruncatedNormal", opName);
         desc.AddInput(shape);
         desc.AddInput(means);
         desc.AddInput(stdevs);
         desc.AddInput(minvals);
         desc.AddInput(maxvals);

         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="shape">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation TruncatedNormal (  Output shape , DataType dtype, long seed = 0 , long seed2 = 0 ,String opName= "TruncatedNormal" ) 
      {
         OperationDescription desc = NewOperation("TruncatedNormal", opName);
         desc.AddInput(shape);
         desc.SetAttr("dtype", dtype);
         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="shape">Input to the operation. </param>
      ///<param name="alpha">Input to the operation. </param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation RandomGamma (  Output shape , Output alpha , long seed = 0 , long seed2 = 0 ,String opName= "RandomGamma" ) 
      {
         OperationDescription desc = NewOperation("RandomGamma", opName);
         desc.AddInput(shape);
         desc.AddInput(alpha);

         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="m">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="logbase">Input to the operation. </param>
      ///<param name="sign_decay">Input to the operation. </param>
      ///<param name="beta">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceApplyPowerSign (  Output var , Output m , Output lr , Output logbase , Output sign_decay , Output beta , Output grad , bool use_locking = false ,String opName= "ResourceApplyPowerSign" ) 
      {
         OperationDescription desc = NewOperation("ResourceApplyPowerSign", opName);
         desc.AddInput(var);
         desc.AddInput(m);
         desc.AddInput(lr);
         desc.AddInput(logbase);
         desc.AddInput(sign_decay);
         desc.AddInput(beta);
         desc.AddInput(grad);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="inputs">Input to the operation. </param>
      ///<param name="Toutputs"></param>
      ///<param name="serialized_remote_fused_graph_execute_info"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] outputs(type: DtInvalid).
      ///</return>
      public Operation RemoteFusedGraphExecute (  Output inputs , DataType[] Toutputs, string serialized_remote_fused_graph_execute_info,String opName= "RemoteFusedGraphExecute" ) 
      {
         OperationDescription desc = NewOperation("RemoteFusedGraphExecute", opName);
         desc.AddInput(inputs);
         desc.SetAttr("Toutputs", Toutputs);
         desc.SetAttr("serialized_remote_fused_graph_execute_info", serialized_remote_fused_graph_execute_info);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="dtype"></param>
      ///<param name="shape"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] resource(type: DtResource).
      ///</return>
      public Operation VarHandleOp (  DataType dtype, long[] shape, string container = null , string shared_name = null ,String opName= "VarHandleOp" ) 
      {
         OperationDescription desc = NewOperation("VarHandleOp", opName);

         desc.SetAttr("dtype", dtype);
         desc.SetAttrShape("shape", shape);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="resource">Input to the operation. </param>
      ///<param name="ignore_lookup_error"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation DestroyResourceOp (  Output resource , bool ignore_lookup_error = true ,String opName= "DestroyResourceOp" ) 
      {
         OperationDescription desc = NewOperation("DestroyResourceOp", opName);
         desc.AddInput(resource);

         if (ignore_lookup_error != true) desc.SetAttr("ignore_lookup_error", ignore_lookup_error);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="resource">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="updates">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceScatterUpdate (  Output resource , Output indices , Output updates ,String opName= "ResourceScatterUpdate" ) 
      {
         OperationDescription desc = NewOperation("ResourceScatterUpdate", opName);
         desc.AddInput(resource);
         desc.AddInput(indices);
         desc.AddInput(updates);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] resource(type: DtResource).
      ///</return>
      public Operation MutexV2 (  string container = null , string shared_name = null ,String opName= "MutexV2" ) 
      {
         OperationDescription desc = NewOperation("MutexV2", opName);


         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="mutex">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] mutex_lock(type: DtVariant).
      ///</return>
      public Operation MutexLock (  Output mutex ,String opName= "MutexLock" ) 
      {
         OperationDescription desc = NewOperation("MutexLock", opName);
         desc.AddInput(mutex);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="token"></param>
      ///<param name="Tout"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation PyFuncStateless (  Output input , string token, DataType[] Tout,String opName= "PyFuncStateless" ) 
      {
         OperationDescription desc = NewOperation("PyFuncStateless", opName);
         desc.AddInput(input);
         desc.SetAttr("token", token);
         desc.SetAttr("Tout", Tout);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="token"></param>
      ///<param name="Tout"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation EagerPyFunc (  Output input , string token, DataType[] Tout,String opName= "EagerPyFunc" ) 
      {
         OperationDescription desc = NewOperation("EagerPyFunc", opName);
         desc.AddInput(input);
         desc.SetAttr("token", token);
         desc.SetAttr("Tout", Tout);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="sparse_example_indices">Input to the operation. </param>
      ///<param name="sparse_feature_indices">Input to the operation. </param>
      ///<param name="sparse_feature_values">Input to the operation. </param>
      ///<param name="dense_features">Input to the operation. </param>
      ///<param name="example_weights">Input to the operation. </param>
      ///<param name="example_labels">Input to the operation. </param>
      ///<param name="sparse_indices">Input to the operation. </param>
      ///<param name="sparse_weights">Input to the operation. </param>
      ///<param name="dense_weights">Input to the operation. </param>
      ///<param name="example_state_data">Input to the operation. </param>
      ///<param name="loss_type"></param>
      ///<param name="l1"></param>
      ///<param name="l2"></param>
      ///<param name="num_loss_partitions"></param>
      ///<param name="num_inner_iterations"></param>
      ///<param name="adaptative"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out_example_state_data(type: DtFloat).
      ///[1] out_delta_sparse_weights(type: DtFloat).
      ///[2] out_delta_dense_weights(type: DtFloat).
      ///</return>
      public Operation SdcaOptimizer (  Output sparse_example_indices , Output sparse_feature_indices , Output sparse_feature_values , Output dense_features , Output example_weights , Output example_labels , Output sparse_indices , Output sparse_weights , Output dense_weights , Output example_state_data , string loss_type, float l1, float l2, long num_loss_partitions, long num_inner_iterations, bool adaptative = false ,String opName= "SdcaOptimizer" ) 
      {
         OperationDescription desc = NewOperation("SdcaOptimizer", opName);
         desc.AddInput(sparse_example_indices);
         desc.AddInput(sparse_feature_indices);
         desc.AddInput(sparse_feature_values);
         desc.AddInput(dense_features);
         desc.AddInput(example_weights);
         desc.AddInput(example_labels);
         desc.AddInput(sparse_indices);
         desc.AddInput(sparse_weights);
         desc.AddInput(dense_weights);
         desc.AddInput(example_state_data);
         desc.SetAttr("loss_type", loss_type);
         desc.SetAttr("l1", l1);
         desc.SetAttr("l2", l2);
         desc.SetAttr("num_loss_partitions", num_loss_partitions);
         desc.SetAttr("num_inner_iterations", num_inner_iterations);
         if (adaptative != false) desc.SetAttr("adaptative", adaptative);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="inputs">Input to the operation. </param>
      ///<param name="reduction_indices">Input to the operation. </param>
      ///<param name="keep_dims"></param>
      ///<param name="separator"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtString).
      ///</return>
      public Operation ReduceJoin (  Output inputs , Output reduction_indices , bool keep_dims = false , string separator = null ,String opName= "ReduceJoin" ) 
      {
         OperationDescription desc = NewOperation("ReduceJoin", opName);
         desc.AddInput(inputs);
         desc.AddInput(reduction_indices);

         if (keep_dims != false) desc.SetAttr("keep_dims", keep_dims);
         if (separator != null) desc.SetAttr("separator", separator);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInt64).
      ///</return>
      public Operation SdcaFprint (  Output input ,String opName= "SdcaFprint" ) 
      {
         OperationDescription desc = NewOperation("SdcaFprint", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 
      // Skipped function _HostSend
      // Skipped function _HostRecv

      ///<summary>
      ///
      ///</summary>
      ///<param name="set1">Input to the operation. </param>
      ///<param name="set2_indices">Input to the operation. </param>
      ///<param name="set2_values">Input to the operation. </param>
      ///<param name="set2_shape">Input to the operation. </param>
      ///<param name="set_operation"></param>
      ///<param name="validate_indices"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] result_indices(type: DtInt64).
      ///[1] result_values(type: DtInvalid).
      ///[2] result_shape(type: DtInt64).
      ///</return>
      public Operation DenseToSparseSetOperation (  Output set1 , Output set2_indices , Output set2_values , Output set2_shape , string set_operation, bool validate_indices = true ,String opName= "DenseToSparseSetOperation" ) 
      {
         OperationDescription desc = NewOperation("DenseToSparseSetOperation", opName);
         desc.AddInput(set1);
         desc.AddInput(set2_indices);
         desc.AddInput(set2_values);
         desc.AddInput(set2_shape);
         desc.SetAttr("set_operation", set_operation);
         if (validate_indices != true) desc.SetAttr("validate_indices", validate_indices);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="set1_indices">Input to the operation. </param>
      ///<param name="set1_values">Input to the operation. </param>
      ///<param name="set1_shape">Input to the operation. </param>
      ///<param name="set2_indices">Input to the operation. </param>
      ///<param name="set2_values">Input to the operation. </param>
      ///<param name="set2_shape">Input to the operation. </param>
      ///<param name="set_operation"></param>
      ///<param name="validate_indices"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] result_indices(type: DtInt64).
      ///[1] result_values(type: DtInvalid).
      ///[2] result_shape(type: DtInt64).
      ///</return>
      public Operation SparseToSparseSetOperation (  Output set1_indices , Output set1_values , Output set1_shape , Output set2_indices , Output set2_values , Output set2_shape , string set_operation, bool validate_indices = true ,String opName= "SparseToSparseSetOperation" ) 
      {
         OperationDescription desc = NewOperation("SparseToSparseSetOperation", opName);
         desc.AddInput(set1_indices);
         desc.AddInput(set1_values);
         desc.AddInput(set1_shape);
         desc.AddInput(set2_indices);
         desc.AddInput(set2_values);
         desc.AddInput(set2_shape);
         desc.SetAttr("set_operation", set_operation);
         if (validate_indices != true) desc.SetAttr("validate_indices", validate_indices);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="backprop_val_grad">Input to the operation. </param>
      ///<param name="a_indices">Input to the operation. </param>
      ///<param name="b_indices">Input to the operation. </param>
      ///<param name="sum_indices">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] a_val_grad(type: DtInvalid).
      ///[1] b_val_grad(type: DtInvalid).
      ///</return>
      public Operation SparseAddGrad (  Output backprop_val_grad , Output a_indices , Output b_indices , Output sum_indices ,String opName= "SparseAddGrad" ) 
      {
         OperationDescription desc = NewOperation("SparseAddGrad", opName);
         desc.AddInput(backprop_val_grad);
         desc.AddInput(a_indices);
         desc.AddInput(b_indices);
         desc.AddInput(sum_indices);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="a_indices">Input to the operation. </param>
      ///<param name="a_values">Input to the operation. </param>
      ///<param name="a_shape">Input to the operation. </param>
      ///<param name="b_indices">Input to the operation. </param>
      ///<param name="b_values">Input to the operation. </param>
      ///<param name="b_shape">Input to the operation. </param>
      ///<param name="thresh">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] sum_indices(type: DtInt64).
      ///[1] sum_values(type: DtInvalid).
      ///[2] sum_shape(type: DtInt64).
      ///</return>
      public Operation SparseAdd (  Output a_indices , Output a_values , Output a_shape , Output b_indices , Output b_values , Output b_shape , Output thresh ,String opName= "SparseAdd" ) 
      {
         OperationDescription desc = NewOperation("SparseAdd", opName);
         desc.AddInput(a_indices);
         desc.AddInput(a_values);
         desc.AddInput(a_shape);
         desc.AddInput(b_indices);
         desc.AddInput(b_values);
         desc.AddInput(b_shape);
         desc.AddInput(thresh);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="a_indices">Input to the operation. </param>
      ///<param name="a_values">Input to the operation. </param>
      ///<param name="a_shape">Input to the operation. </param>
      ///<param name="b">Input to the operation. </param>
      ///<param name="adjoint_a"></param>
      ///<param name="adjoint_b"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] product(type: DtInvalid).
      ///</return>
      public Operation SparseTensorDenseMatMul (  Output a_indices , Output a_values , Output a_shape , Output b , bool adjoint_a = false , bool adjoint_b = false ,String opName= "SparseTensorDenseMatMul" ) 
      {
         OperationDescription desc = NewOperation("SparseTensorDenseMatMul", opName);
         desc.AddInput(a_indices);
         desc.AddInput(a_values);
         desc.AddInput(a_shape);
         desc.AddInput(b);

         if (adjoint_a != false) desc.SetAttr("adjoint_a", adjoint_a);
         if (adjoint_b != false) desc.SetAttr("adjoint_b", adjoint_b);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="sparse_indices">Input to the operation. </param>
      ///<param name="sparse_values">Input to the operation. </param>
      ///<param name="sparse_shape">Input to the operation. </param>
      ///<param name="out_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] serialized_sparse(type: DtInvalid).
      ///</return>
      public Operation SerializeManySparse (  Output sparse_indices , Output sparse_values , Output sparse_shape , DataType? out_type = null ,String opName= "SerializeManySparse" ) 
      {
         OperationDescription desc = NewOperation("SerializeManySparse", opName);
         desc.AddInput(sparse_indices);
         desc.AddInput(sparse_values);
         desc.AddInput(sparse_shape);

         if (out_type.HasValue) desc.SetAttr("out_type", out_type.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="serialized_sparse">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] sparse_indices(type: DtInt64).
      ///[1] sparse_values(type: DtInvalid).
      ///[2] sparse_shape(type: DtInt64).
      ///</return>
      public Operation DeserializeManySparse (  Output serialized_sparse , DataType dtype,String opName= "DeserializeManySparse" ) 
      {
         OperationDescription desc = NewOperation("DeserializeManySparse", opName);
         desc.AddInput(serialized_sparse);
         desc.SetAttr("dtype", dtype);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="values">Input to the operation. </param>
      ///<param name="shapes">Input to the operation. </param>
      ///<param name="concat_dim"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_indices(type: DtInt64).
      ///[1] output_values(type: DtInvalid).
      ///[2] output_shape(type: DtInt64).
      ///</return>
      public Operation SparseConcat (  Output indices , Output values , Output shapes , long concat_dim,String opName= "SparseConcat" ) 
      {
         OperationDescription desc = NewOperation("SparseConcat", opName);
         desc.AddInput(indices);
         desc.AddInput(values);
         desc.AddInput(shapes);
         desc.SetAttr("concat_dim", concat_dim);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="values">Input to the operation. </param>
      ///<param name="shape">Input to the operation. </param>
      ///<param name="start">Input to the operation. </param>
      ///<param name="size">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_indices(type: DtInt64).
      ///[1] output_values(type: DtInvalid).
      ///[2] output_shape(type: DtInt64).
      ///</return>
      public Operation SparseSlice (  Output indices , Output values , Output shape , Output start , Output size ,String opName= "SparseSlice" ) 
      {
         OperationDescription desc = NewOperation("SparseSlice", opName);
         desc.AddInput(indices);
         desc.AddInput(values);
         desc.AddInput(shape);
         desc.AddInput(start);
         desc.AddInput(size);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_indices">Input to the operation. </param>
      ///<param name="input_values">Input to the operation. </param>
      ///<param name="input_shape">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_indices(type: DtInt64).
      ///[1] output_values(type: DtInvalid).
      ///</return>
      public Operation SparseReorder (  Output input_indices , Output input_values , Output input_shape ,String opName= "SparseReorder" ) 
      {
         OperationDescription desc = NewOperation("SparseReorder", opName);
         desc.AddInput(input_indices);
         desc.AddInput(input_values);
         desc.AddInput(input_shape);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="a_indices">Input to the operation. </param>
      ///<param name="a_values">Input to the operation. </param>
      ///<param name="a_shape">Input to the operation. </param>
      ///<param name="b">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SparseTensorDenseAdd (  Output a_indices , Output a_values , Output a_shape , Output b ,String opName= "SparseTensorDenseAdd" ) 
      {
         OperationDescription desc = NewOperation("SparseTensorDenseAdd", opName);
         desc.AddInput(a_indices);
         desc.AddInput(a_values);
         desc.AddInput(a_shape);
         desc.AddInput(b);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_indices">Input to the operation. </param>
      ///<param name="input_values">Input to the operation. </param>
      ///<param name="input_shape">Input to the operation. </param>
      ///<param name="reduction_axes">Input to the operation. </param>
      ///<param name="keep_dims"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SparseReduceSum (  Output input_indices , Output input_values , Output input_shape , Output reduction_axes , bool keep_dims = false ,String opName= "SparseReduceSum" ) 
      {
         OperationDescription desc = NewOperation("SparseReduceSum", opName);
         desc.AddInput(input_indices);
         desc.AddInput(input_values);
         desc.AddInput(input_shape);
         desc.AddInput(reduction_axes);

         if (keep_dims != false) desc.SetAttr("keep_dims", keep_dims);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="sp_indices">Input to the operation. </param>
      ///<param name="sp_values">Input to the operation. </param>
      ///<param name="sp_shape">Input to the operation. </param>
      ///<param name="dense">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SparseDenseCwiseDiv (  Output sp_indices , Output sp_values , Output sp_shape , Output dense ,String opName= "SparseDenseCwiseDiv" ) 
      {
         OperationDescription desc = NewOperation("SparseDenseCwiseDiv", opName);
         desc.AddInput(sp_indices);
         desc.AddInput(sp_values);
         desc.AddInput(sp_shape);
         desc.AddInput(dense);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="a_indices">Input to the operation. </param>
      ///<param name="a_values">Input to the operation. </param>
      ///<param name="a_shape">Input to the operation. </param>
      ///<param name="b_indices">Input to the operation. </param>
      ///<param name="b_values">Input to the operation. </param>
      ///<param name="b_shape">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_indices(type: DtInt64).
      ///[1] output_values(type: DtInvalid).
      ///</return>
      public Operation SparseSparseMinimum (  Output a_indices , Output a_values , Output a_shape , Output b_indices , Output b_values , Output b_shape ,String opName= "SparseSparseMinimum" ) 
      {
         OperationDescription desc = NewOperation("SparseSparseMinimum", opName);
         desc.AddInput(a_indices);
         desc.AddInput(a_values);
         desc.AddInput(a_shape);
         desc.AddInput(b_indices);
         desc.AddInput(b_values);
         desc.AddInput(b_shape);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="sparse_indices">Input to the operation. </param>
      ///<param name="sparse_values">Input to the operation. </param>
      ///<param name="sparse_shape">Input to the operation. </param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] sparse_handle(type: DtInt64).
      ///</return>
      public Operation AddSparseToTensorsMap (  Output sparse_indices , Output sparse_values , Output sparse_shape , string container = null , string shared_name = null ,String opName= "AddSparseToTensorsMap" ) 
      {
         OperationDescription desc = NewOperation("AddSparseToTensorsMap", opName);
         desc.AddInput(sparse_indices);
         desc.AddInput(sparse_values);
         desc.AddInput(sparse_shape);

         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="sparse_indices">Input to the operation. </param>
      ///<param name="sparse_values">Input to the operation. </param>
      ///<param name="sparse_shape">Input to the operation. </param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] sparse_handles(type: DtInt64).
      ///</return>
      public Operation AddManySparseToTensorsMap (  Output sparse_indices , Output sparse_values , Output sparse_shape , string container = null , string shared_name = null ,String opName= "AddManySparseToTensorsMap" ) 
      {
         OperationDescription desc = NewOperation("AddManySparseToTensorsMap", opName);
         desc.AddInput(sparse_indices);
         desc.AddInput(sparse_values);
         desc.AddInput(sparse_shape);

         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="values">Input to the operation. </param>
      ///<param name="dense_shape">Input to the operation. </param>
      ///<param name="default_value">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_indices(type: DtInt64).
      ///[1] output_values(type: DtInvalid).
      ///[2] empty_row_indicator(type: DtBool).
      ///[3] reverse_index_map(type: DtInt64).
      ///</return>
      public Operation SparseFillEmptyRows (  Output indices , Output values , Output dense_shape , Output default_value ,String opName= "SparseFillEmptyRows" ) 
      {
         OperationDescription desc = NewOperation("SparseFillEmptyRows", opName);
         desc.AddInput(indices);
         desc.AddInput(values);
         desc.AddInput(dense_shape);
         desc.AddInput(default_value);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtComplex64).
      ///</return>
      public Operation FFT (  Output input ,String opName= "FFT" ) 
      {
         OperationDescription desc = NewOperation("FFT", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtComplex64).
      ///</return>
      public Operation IFFT (  Output input ,String opName= "IFFT" ) 
      {
         OperationDescription desc = NewOperation("IFFT", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtComplex64).
      ///</return>
      public Operation FFT2D (  Output input ,String opName= "FFT2D" ) 
      {
         OperationDescription desc = NewOperation("FFT2D", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtComplex64).
      ///</return>
      public Operation FFT3D (  Output input ,String opName= "FFT3D" ) 
      {
         OperationDescription desc = NewOperation("FFT3D", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="fft_length">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtComplex64).
      ///</return>
      public Operation RFFT (  Output input , Output fft_length ,String opName= "RFFT" ) 
      {
         OperationDescription desc = NewOperation("RFFT", opName);
         desc.AddInput(input);
         desc.AddInput(fft_length);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="fft_length">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtFloat).
      ///</return>
      public Operation IRFFT (  Output input , Output fft_length ,String opName= "IRFFT" ) 
      {
         OperationDescription desc = NewOperation("IRFFT", opName);
         desc.AddInput(input);
         desc.AddInput(fft_length);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="fft_length">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtComplex64).
      ///</return>
      public Operation RFFT2D (  Output input , Output fft_length ,String opName= "RFFT2D" ) 
      {
         OperationDescription desc = NewOperation("RFFT2D", opName);
         desc.AddInput(input);
         desc.AddInput(fft_length);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtComplex64).
      ///</return>
      public Operation BatchFFT (  Output input ,String opName= "BatchFFT" ) 
      {
         OperationDescription desc = NewOperation("BatchFFT", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtComplex64).
      ///</return>
      public Operation BatchFFT2D (  Output input ,String opName= "BatchFFT2D" ) 
      {
         OperationDescription desc = NewOperation("BatchFFT2D", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtComplex64).
      ///</return>
      public Operation BatchIFFT2D (  Output input ,String opName= "BatchIFFT2D" ) 
      {
         OperationDescription desc = NewOperation("BatchIFFT2D", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtComplex64).
      ///</return>
      public Operation BatchFFT3D (  Output input ,String opName= "BatchFFT3D" ) 
      {
         OperationDescription desc = NewOperation("BatchFFT3D", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="shape"></param>
      ///<param name="dtype"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] ref(type: DtInvalid).
      ///</return>
      public Operation VariableV2 (  long[] shape, DataType dtype, string container = null , string shared_name = null ,String opName= "VariableV2" ) 
      {
         OperationDescription desc = NewOperation("VariableV2", opName);

         desc.SetAttrShape("shape", shape);
         desc.SetAttr("dtype", dtype);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reference">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] is_initialized(type: DtBool).
      ///</return>
      public Operation IsVariableInitialized (  Output reference ,String opName= "IsVariableInitialized" ) 
      {
         OperationDescription desc = NewOperation("IsVariableInitialized", opName);
         desc.AddInput(reference);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="shape"></param>
      ///<param name="dtype"></param>
      ///<param name="var_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] ref(type: DtInvalid).
      ///</return>
      public Operation TemporaryVariable (  long[] shape, DataType dtype, string var_name = null ,String opName= "TemporaryVariable" ) 
      {
         OperationDescription desc = NewOperation("TemporaryVariable", opName);

         desc.SetAttrShape("shape", shape);
         desc.SetAttr("dtype", dtype);
         if (var_name != null) desc.SetAttr("var_name", var_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reference">Input to the operation. </param>
      ///<param name="var_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] value(type: DtInvalid).
      ///</return>
      public Operation DestroyTemporaryVariable (  Output reference , string var_name,String opName= "DestroyTemporaryVariable" ) 
      {
         OperationDescription desc = NewOperation("DestroyTemporaryVariable", opName);
         desc.AddInput(reference);
         desc.SetAttr("var_name", var_name);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reference">Input to the operation. </param>
      ///<param name="value">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_ref(type: DtInvalid).
      ///</return>
      public Operation AssignSub (  Output reference , Output value , bool use_locking = false ,String opName= "AssignSub" ) 
      {
         OperationDescription desc = NewOperation("AssignSub", opName);
         desc.AddInput(reference);
         desc.AddInput(value);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reference">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="updates">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_ref(type: DtInvalid).
      ///</return>
      public Operation ScatterUpdate (  Output reference , Output indices , Output updates , bool use_locking = true ,String opName= "ScatterUpdate" ) 
      {
         OperationDescription desc = NewOperation("ScatterUpdate", opName);
         desc.AddInput(reference);
         desc.AddInput(indices);
         desc.AddInput(updates);

         if (use_locking != true) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reference">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="updates">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceScatterNdUpdate (  Output reference , Output indices , Output updates , bool use_locking = true ,String opName= "ResourceScatterNdUpdate" ) 
      {
         OperationDescription desc = NewOperation("ResourceScatterNdUpdate", opName);
         desc.AddInput(reference);
         desc.AddInput(indices);
         desc.AddInput(updates);

         if (use_locking != true) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reference">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="updates">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_ref(type: DtInvalid).
      ///</return>
      public Operation ScatterNdAdd (  Output reference , Output indices , Output updates , bool use_locking = false ,String opName= "ScatterNdAdd" ) 
      {
         OperationDescription desc = NewOperation("ScatterNdAdd", opName);
         desc.AddInput(reference);
         desc.AddInput(indices);
         desc.AddInput(updates);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="shape">Input to the operation. </param>
      ///<param name="seed">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation StatelessRandomNormal (  Output shape , Output seed , DataType? dtype = null ,String opName= "StatelessRandomNormal" ) 
      {
         OperationDescription desc = NewOperation("StatelessRandomNormal", opName);
         desc.AddInput(shape);
         desc.AddInput(seed);

         if (dtype.HasValue) desc.SetAttr("dtype", dtype.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="shape">Input to the operation. </param>
      ///<param name="seed">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation StatelessTruncatedNormal (  Output shape , Output seed , DataType? dtype = null ,String opName= "StatelessTruncatedNormal" ) 
      {
         OperationDescription desc = NewOperation("StatelessTruncatedNormal", opName);
         desc.AddInput(shape);
         desc.AddInput(seed);

         if (dtype.HasValue) desc.SetAttr("dtype", dtype.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="pattern">Input to the operation. </param>
      ///<param name="rewrite">Input to the operation. </param>
      ///<param name="replace_global"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtString).
      ///</return>
      public Operation RegexReplace (  Output input , Output pattern , Output rewrite , bool replace_global = true ,String opName= "RegexReplace" ) 
      {
         OperationDescription desc = NewOperation("RegexReplace", opName);
         desc.AddInput(input);
         desc.AddInput(pattern);
         desc.AddInput(rewrite);

         if (replace_global != true) desc.SetAttr("replace_global", replace_global);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="num_buckets"></param>
      ///<param name="key"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInt64).
      ///</return>
      public Operation StringToHashBucketStrong (  Output input , long num_buckets, long[] key,String opName= "StringToHashBucketStrong" ) 
      {
         OperationDescription desc = NewOperation("StringToHashBucketStrong", opName);
         desc.AddInput(input);
         desc.SetAttr("num_buckets", num_buckets);
         desc.SetAttr("key", key);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="precision"></param>
      ///<param name="scientific"></param>
      ///<param name="shortest"></param>
      ///<param name="width"></param>
      ///<param name="fill"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtString).
      ///</return>
      public Operation AsString (  Output input , long precision = -1 , bool scientific = false , bool shortest = false , long width = -1 , string fill = null ,String opName= "AsString" ) 
      {
         OperationDescription desc = NewOperation("AsString", opName);
         desc.AddInput(input);

         if (precision != -1) desc.SetAttr("precision", precision);
         if (scientific != false) desc.SetAttr("scientific", scientific);
         if (shortest != false) desc.SetAttr("shortest", shortest);
         if (width != -1) desc.SetAttr("width", width);
         if (fill != null) desc.SetAttr("fill", fill);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="inputs">Input to the operation. </param>
      ///<param name="separator"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtString).
      ///</return>
      public Operation StringJoin (  Output inputs , string separator = null ,String opName= "StringJoin" ) 
      {
         OperationDescription desc = NewOperation("StringJoin", opName);
         desc.AddInput(inputs);

         if (separator != null) desc.SetAttr("separator", separator);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="delimiter">Input to the operation. </param>
      ///<param name="skip_empty"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] indices(type: DtInt64).
      ///[1] values(type: DtString).
      ///[2] shape(type: DtInt64).
      ///</return>
      public Operation StringSplit (  Output input , Output delimiter , bool skip_empty = true ,String opName= "StringSplit" ) 
      {
         OperationDescription desc = NewOperation("StringSplit", opName);
         desc.AddInput(input);
         desc.AddInput(delimiter);

         if (skip_empty != true) desc.SetAttr("skip_empty", skip_empty);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="pos">Input to the operation. </param>
      ///<param name="len">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtString).
      ///</return>
      public Operation Substr (  Output input , Output pos , Output len ,String opName= "Substr" ) 
      {
         OperationDescription desc = NewOperation("Substr", opName);
         desc.AddInput(input);
         desc.AddInput(pos);
         desc.AddInput(len);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="pad"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtString).
      ///</return>
      public Operation EncodeBase64 (  Output input , bool pad = false ,String opName= "EncodeBase64" ) 
      {
         OperationDescription desc = NewOperation("EncodeBase64", opName);
         desc.AddInput(input);

         if (pad != false) desc.SetAttr("pad", pad);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtString).
      ///</return>
      public Operation DecodeBase64 (  Output input ,String opName= "DecodeBase64" ) 
      {
         OperationDescription desc = NewOperation("DecodeBase64", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///Returns a handle to be used to access a summary writer.
      ///</summary>
      ///<param name="shared_name"></param>
      ///<param name="container"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] writer(type: DtResource): the summary writer resource. Scalar handle.
      ///</return>
      public Operation SummaryWriter (  string shared_name = null , string container = null ,String opName= "SummaryWriter" ) 
      {
         OperationDescription desc = NewOperation("SummaryWriter", opName);


         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         if (container != null) desc.SetAttr("container", container);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///Flushes the writer's unwritten events.
      ///</summary>
      ///<param name="writer">Input to the operation: A handle to the summary writer resource.</param>
      ///<param name="opName">The name of the operation</param>
      public Operation FlushSummaryWriter (  Output writer ,String opName= "FlushSummaryWriter" ) 
      {
         OperationDescription desc = NewOperation("FlushSummaryWriter", opName);
         desc.AddInput(writer);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///Outputs a `Summary` protocol buffer with a tensor.
      ///</summary>
      ///<param name="writer">Input to the operation: A handle to a summary writer.</param>
      ///<param name="step">Input to the operation: The step to write the summary for.</param>
      ///<param name="tensor">Input to the operation: A tensor to serialize.</param>
      ///<param name="tag">Input to the operation: The summary's tag.</param>
      ///<param name="summary_metadata">Input to the operation: Serialized SummaryMetadata protocol buffer containing plugin-related metadata for this summary.</param>
      ///<param name="opName">The name of the operation</param>
      public Operation WriteSummary (  Output writer , Output step , Output tensor , Output tag , Output summary_metadata ,String opName= "WriteSummary" ) 
      {
         OperationDescription desc = NewOperation("WriteSummary", opName);
         desc.AddInput(writer);
         desc.AddInput(step);
         desc.AddInput(tensor);
         desc.AddInput(tag);
         desc.AddInput(summary_metadata);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///Outputs a `tf.Event` protocol buffer.
      ///</summary>
      ///<param name="writer">Input to the operation: A handle to a summary writer.</param>
      ///<param name="tfEvent">Input to the operation: A string containing a binary-encoded tf.Event proto.</param>
      ///<param name="opName">The name of the operation</param>
      public Operation ImportEvent (  Output writer , Output tfEvent ,String opName= "ImportEvent" ) 
      {
         OperationDescription desc = NewOperation("ImportEvent", opName);
         desc.AddInput(writer);
         desc.AddInput(tfEvent);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///Writes a `Summary` protocol buffer with images.
      ///</summary>
      ///<param name="writer">Input to the operation: A handle to a summary writer.</param>
      ///<param name="step">Input to the operation: The step to write the summary for.</param>
      ///<param name="tag">Input to the operation: Scalar. Used to build the `tag` attribute of the summary values.</param>
      ///<param name="tensor">Input to the operation: 4-D of shape `[batch_size, height, width, channels]` where `channels` is 1, 3, or 4.</param>
      ///<param name="bad_color">Input to the operation: Color to use for pixels with non-finite values.</param>
      ///<param name="max_images">Max number of batch elements to generate images for.</param>
      ///<param name="opName">The name of the operation</param>
      public Operation WriteImageSummary (  Output writer , Output step , Output tag , Output tensor , Output bad_color , long max_images = 3 ,String opName= "WriteImageSummary" ) 
      {
         OperationDescription desc = NewOperation("WriteImageSummary", opName);
         desc.AddInput(writer);
         desc.AddInput(step);
         desc.AddInput(tag);
         desc.AddInput(tensor);
         desc.AddInput(bad_color);

         if (max_images != 3) desc.SetAttr("max_images", max_images);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///Writes a `GraphDef` protocol buffer to a `SummaryWriter`.
      ///</summary>
      ///<param name="writer">Input to the operation: Handle of `SummaryWriter`.</param>
      ///<param name="step">Input to the operation: The step to write the summary for.</param>
      ///<param name="tensor">Input to the operation: A scalar string of the serialized tf.GraphDef proto.</param>
      ///<param name="opName">The name of the operation</param>
      public Operation WriteGraphSummary (  Output writer , Output step , Output tensor ,String opName= "WriteGraphSummary" ) 
      {
         OperationDescription desc = NewOperation("WriteGraphSummary", opName);
         desc.AddInput(writer);
         desc.AddInput(step);
         desc.AddInput(tensor);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="alpha">Input to the operation. </param>
      ///<param name="l1">Input to the operation. </param>
      ///<param name="l2">Input to the operation. </param>
      ///<param name="delta">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceApplyProximalGradientDescent (  Output var , Output alpha , Output l1 , Output l2 , Output delta , bool use_locking = false ,String opName= "ResourceApplyProximalGradientDescent" ) 
      {
         OperationDescription desc = NewOperation("ResourceApplyProximalGradientDescent", opName);
         desc.AddInput(var);
         desc.AddInput(alpha);
         desc.AddInput(l1);
         desc.AddInput(l2);
         desc.AddInput(delta);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="accum_update">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="rho">Input to the operation. </param>
      ///<param name="epsilon">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation ApplyAdadelta (  Output var , Output accum , Output accum_update , Output lr , Output rho , Output epsilon , Output grad , bool use_locking = false ,String opName= "ApplyAdadelta" ) 
      {
         OperationDescription desc = NewOperation("ApplyAdadelta", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(accum_update);
         desc.AddInput(lr);
         desc.AddInput(rho);
         desc.AddInput(epsilon);
         desc.AddInput(grad);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="accum_update">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="rho">Input to the operation. </param>
      ///<param name="epsilon">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceSparseApplyAdadelta (  Output var , Output accum , Output accum_update , Output lr , Output rho , Output epsilon , Output grad , Output indices , bool use_locking = false ,String opName= "ResourceSparseApplyAdadelta" ) 
      {
         OperationDescription desc = NewOperation("ResourceSparseApplyAdadelta", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(accum_update);
         desc.AddInput(lr);
         desc.AddInput(rho);
         desc.AddInput(epsilon);
         desc.AddInput(grad);
         desc.AddInput(indices);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceApplyAdagrad (  Output var , Output accum , Output lr , Output grad , bool use_locking = false ,String opName= "ResourceApplyAdagrad" ) 
      {
         OperationDescription desc = NewOperation("ResourceApplyAdagrad", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(lr);
         desc.AddInput(grad);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="l1">Input to the operation. </param>
      ///<param name="l2">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation ApplyProximalAdagrad (  Output var , Output accum , Output lr , Output l1 , Output l2 , Output grad , bool use_locking = false ,String opName= "ApplyProximalAdagrad" ) 
      {
         OperationDescription desc = NewOperation("ApplyProximalAdagrad", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(lr);
         desc.AddInput(l1);
         desc.AddInput(l2);
         desc.AddInput(grad);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="l1">Input to the operation. </param>
      ///<param name="l2">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceApplyProximalAdagrad (  Output var , Output accum , Output lr , Output l1 , Output l2 , Output grad , bool use_locking = false ,String opName= "ResourceApplyProximalAdagrad" ) 
      {
         OperationDescription desc = NewOperation("ResourceApplyProximalAdagrad", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(lr);
         desc.AddInput(l1);
         desc.AddInput(l2);
         desc.AddInput(grad);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="mg">Input to the operation. </param>
      ///<param name="ms">Input to the operation. </param>
      ///<param name="mom">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="rho">Input to the operation. </param>
      ///<param name="momentum">Input to the operation. </param>
      ///<param name="epsilon">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation SparseApplyCenteredRMSProp (  Output var , Output mg , Output ms , Output mom , Output lr , Output rho , Output momentum , Output epsilon , Output grad , Output indices , bool use_locking = false ,String opName= "SparseApplyCenteredRMSProp" ) 
      {
         OperationDescription desc = NewOperation("SparseApplyCenteredRMSProp", opName);
         desc.AddInput(var);
         desc.AddInput(mg);
         desc.AddInput(ms);
         desc.AddInput(mom);
         desc.AddInput(lr);
         desc.AddInput(rho);
         desc.AddInput(momentum);
         desc.AddInput(epsilon);
         desc.AddInput(grad);
         desc.AddInput(indices);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="gradient_accumulator">Input to the operation. </param>
      ///<param name="gradient_squared_accumulator">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="l1">Input to the operation. </param>
      ///<param name="l2">Input to the operation. </param>
      ///<param name="global_step">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation SparseApplyAdagradDA (  Output var , Output gradient_accumulator , Output gradient_squared_accumulator , Output grad , Output indices , Output lr , Output l1 , Output l2 , Output global_step , bool use_locking = false ,String opName= "SparseApplyAdagradDA" ) 
      {
         OperationDescription desc = NewOperation("SparseApplyAdagradDA", opName);
         desc.AddInput(var);
         desc.AddInput(gradient_accumulator);
         desc.AddInput(gradient_squared_accumulator);
         desc.AddInput(grad);
         desc.AddInput(indices);
         desc.AddInput(lr);
         desc.AddInput(l1);
         desc.AddInput(l2);
         desc.AddInput(global_step);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="l1">Input to the operation. </param>
      ///<param name="l2">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceSparseApplyProximalAdagrad (  Output var , Output accum , Output lr , Output l1 , Output l2 , Output grad , Output indices , bool use_locking = false ,String opName= "ResourceSparseApplyProximalAdagrad" ) 
      {
         OperationDescription desc = NewOperation("ResourceSparseApplyProximalAdagrad", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(lr);
         desc.AddInput(l1);
         desc.AddInput(l2);
         desc.AddInput(grad);
         desc.AddInput(indices);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="linear">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="l1">Input to the operation. </param>
      ///<param name="l2">Input to the operation. </param>
      ///<param name="lr_power">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation SparseApplyFtrl (  Output var , Output accum , Output linear , Output grad , Output indices , Output lr , Output l1 , Output l2 , Output lr_power , bool use_locking = false ,String opName= "SparseApplyFtrl" ) 
      {
         OperationDescription desc = NewOperation("SparseApplyFtrl", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(linear);
         desc.AddInput(grad);
         desc.AddInput(indices);
         desc.AddInput(lr);
         desc.AddInput(l1);
         desc.AddInput(l2);
         desc.AddInput(lr_power);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="linear">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="l1">Input to the operation. </param>
      ///<param name="l2">Input to the operation. </param>
      ///<param name="lr_power">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceApplyFtrl (  Output var , Output accum , Output linear , Output grad , Output lr , Output l1 , Output l2 , Output lr_power , bool use_locking = false ,String opName= "ResourceApplyFtrl" ) 
      {
         OperationDescription desc = NewOperation("ResourceApplyFtrl", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(linear);
         desc.AddInput(grad);
         desc.AddInput(lr);
         desc.AddInput(l1);
         desc.AddInput(l2);
         desc.AddInput(lr_power);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="linear">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="l1">Input to the operation. </param>
      ///<param name="l2">Input to the operation. </param>
      ///<param name="l2_shrinkage">Input to the operation. </param>
      ///<param name="lr_power">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceApplyFtrlV2 (  Output var , Output accum , Output linear , Output grad , Output lr , Output l1 , Output l2 , Output l2_shrinkage , Output lr_power , bool use_locking = false ,String opName= "ResourceApplyFtrlV2" ) 
      {
         OperationDescription desc = NewOperation("ResourceApplyFtrlV2", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(linear);
         desc.AddInput(grad);
         desc.AddInput(lr);
         desc.AddInput(l1);
         desc.AddInput(l2);
         desc.AddInput(l2_shrinkage);
         desc.AddInput(lr_power);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="momentum">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="use_nesterov"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation SparseApplyMomentum (  Output var , Output accum , Output lr , Output grad , Output indices , Output momentum , bool use_locking = false , bool use_nesterov = false ,String opName= "SparseApplyMomentum" ) 
      {
         OperationDescription desc = NewOperation("SparseApplyMomentum", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(lr);
         desc.AddInput(grad);
         desc.AddInput(indices);
         desc.AddInput(momentum);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         if (use_nesterov != false) desc.SetAttr("use_nesterov", use_nesterov);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="momentum">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="use_nesterov"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceApplyMomentum (  Output var , Output accum , Output lr , Output grad , Output momentum , bool use_locking = false , bool use_nesterov = false ,String opName= "ResourceApplyMomentum" ) 
      {
         OperationDescription desc = NewOperation("ResourceApplyMomentum", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(lr);
         desc.AddInput(grad);
         desc.AddInput(momentum);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         if (use_nesterov != false) desc.SetAttr("use_nesterov", use_nesterov);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="momentum">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="use_nesterov"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceSparseApplyMomentum (  Output var , Output accum , Output lr , Output grad , Output indices , Output momentum , bool use_locking = false , bool use_nesterov = false ,String opName= "ResourceSparseApplyMomentum" ) 
      {
         OperationDescription desc = NewOperation("ResourceSparseApplyMomentum", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(lr);
         desc.AddInput(grad);
         desc.AddInput(indices);
         desc.AddInput(momentum);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         if (use_nesterov != false) desc.SetAttr("use_nesterov", use_nesterov);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="mg">Input to the operation. </param>
      ///<param name="ms">Input to the operation. </param>
      ///<param name="mom">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="rho">Input to the operation. </param>
      ///<param name="momentum">Input to the operation. </param>
      ///<param name="epsilon">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation ApplyCenteredRMSProp (  Output var , Output mg , Output ms , Output mom , Output lr , Output rho , Output momentum , Output epsilon , Output grad , bool use_locking = false ,String opName= "ApplyCenteredRMSProp" ) 
      {
         OperationDescription desc = NewOperation("ApplyCenteredRMSProp", opName);
         desc.AddInput(var);
         desc.AddInput(mg);
         desc.AddInput(ms);
         desc.AddInput(mom);
         desc.AddInput(lr);
         desc.AddInput(rho);
         desc.AddInput(momentum);
         desc.AddInput(epsilon);
         desc.AddInput(grad);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="ms">Input to the operation. </param>
      ///<param name="mom">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="rho">Input to the operation. </param>
      ///<param name="momentum">Input to the operation. </param>
      ///<param name="epsilon">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceApplyRMSProp (  Output var , Output ms , Output mom , Output lr , Output rho , Output momentum , Output epsilon , Output grad , bool use_locking = false ,String opName= "ResourceApplyRMSProp" ) 
      {
         OperationDescription desc = NewOperation("ResourceApplyRMSProp", opName);
         desc.AddInput(var);
         desc.AddInput(ms);
         desc.AddInput(mom);
         desc.AddInput(lr);
         desc.AddInput(rho);
         desc.AddInput(momentum);
         desc.AddInput(epsilon);
         desc.AddInput(grad);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="mg">Input to the operation. </param>
      ///<param name="ms">Input to the operation. </param>
      ///<param name="mom">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="rho">Input to the operation. </param>
      ///<param name="momentum">Input to the operation. </param>
      ///<param name="epsilon">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceApplyCenteredRMSProp (  Output var , Output mg , Output ms , Output mom , Output lr , Output rho , Output momentum , Output epsilon , Output grad , bool use_locking = false ,String opName= "ResourceApplyCenteredRMSProp" ) 
      {
         OperationDescription desc = NewOperation("ResourceApplyCenteredRMSProp", opName);
         desc.AddInput(var);
         desc.AddInput(mg);
         desc.AddInput(ms);
         desc.AddInput(mom);
         desc.AddInput(lr);
         desc.AddInput(rho);
         desc.AddInput(momentum);
         desc.AddInput(epsilon);
         desc.AddInput(grad);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="filename"></param>
      ///<param name="batch_size"></param>
      ///<param name="window_size"></param>
      ///<param name="min_count"></param>
      ///<param name="subsample"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] vocab_word(type: DtString).
      ///[1] vocab_freq(type: DtInt32).
      ///[2] words_per_epoch(type: DtInt64).
      ///[3] current_epoch(type: DtInt32).
      ///[4] total_words_processed(type: DtInt64).
      ///[5] examples(type: DtInt32).
      ///[6] labels(type: DtInt32).
      ///</return>
      public Operation Skipgram (  string filename, long batch_size, long window_size = 5 , long min_count = 5 , float subsample = 0.001f ,String opName= "Skipgram" ) 
      {
         OperationDescription desc = NewOperation("Skipgram", opName);

         desc.SetAttr("filename", filename);
         desc.SetAttr("batch_size", batch_size);
         if (window_size != 5) desc.SetAttr("window_size", window_size);
         if (min_count != 5) desc.SetAttr("min_count", min_count);
         if (subsample != 0.001f) desc.SetAttr("subsample", subsample);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="w_in">Input to the operation. </param>
      ///<param name="w_out">Input to the operation. </param>
      ///<param name="examples">Input to the operation. </param>
      ///<param name="labels">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="vocab_count"></param>
      ///<param name="num_negative_samples"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation NegTrain (  Output w_in , Output w_out , Output examples , Output labels , Output lr , long[] vocab_count, long num_negative_samples,String opName= "NegTrain" ) 
      {
         OperationDescription desc = NewOperation("NegTrain", opName);
         desc.AddInput(w_in);
         desc.AddInput(w_out);
         desc.AddInput(examples);
         desc.AddInput(labels);
         desc.AddInput(lr);
         desc.SetAttr("vocab_count", vocab_count);
         desc.SetAttr("num_negative_samples", num_negative_samples);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] fact(type: DtString).
      ///</return>
      public Operation Fact ( String opName= "Fact" ) 
      {
         OperationDescription desc = NewOperation("Fact", opName);



         return desc.FinishOperation();
      } 
   }
}