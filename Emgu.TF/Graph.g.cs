 
//----------------------------------------------------------------------------
//  Copyright (C) 2004-2018 by EMGU Corporation. All rights reserved.       
//  This code is automatically generated by a program from Tensorflow 1.11.0.  
//  Please do not modify manually.
//----------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Text;
using Emgu.TF.Util;
using System.Runtime.InteropServices;

namespace Emgu.TF
{
   public partial class Graph : UnmanagedObject
   {
      
      ///<summary>
      ///
      ///</summary>
      ///<param name="true_classes">Input to the operation. </param>
      ///<param name="num_true"></param>
      ///<param name="num_sampled"></param>
      ///<param name="unique"></param>
      ///<param name="range_max"></param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] sampled_candidates(type: DtInt64).
      ///[1] true_expected_count(type: DtFloat).
      ///[2] sampled_expected_count(type: DtFloat).
      ///</return>
      public Operation ThreadUnsafeUnigramCandidateSampler (  Output true_classes , long num_true, long num_sampled, bool unique, long range_max, long seed = 0 , long seed2 = 0 ,String opName= "ThreadUnsafeUnigramCandidateSampler" ) 
      {
         OperationDescription desc = NewOperation("ThreadUnsafeUnigramCandidateSampler", opName);
         desc.AddInput(true_classes);
         desc.SetAttr("num_true", num_true);
         desc.SetAttr("num_sampled", num_sampled);
         desc.SetAttr("unique", unique);
         desc.SetAttr("range_max", range_max);
         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="key_dtype"></param>
      ///<param name="value_dtype"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="use_node_name_sharing"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] table_handle(type: DtString).
      ///</return>
      public Operation MutableHashTable (  DataType key_dtype, DataType value_dtype, string container = null , string shared_name = null , bool use_node_name_sharing = false ,String opName= "MutableHashTable" ) 
      {
         OperationDescription desc = NewOperation("MutableHashTable", opName);

         desc.SetAttr("key_dtype", key_dtype);
         desc.SetAttr("value_dtype", value_dtype);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         if (use_node_name_sharing != false) desc.SetAttr("use_node_name_sharing", use_node_name_sharing);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="sparse_indices">Input to the operation. </param>
      ///<param name="output_shape">Input to the operation. </param>
      ///<param name="sparse_values">Input to the operation. </param>
      ///<param name="default_value">Input to the operation. </param>
      ///<param name="validate_indices"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] dense(type: DtInvalid).
      ///</return>
      public Operation SparseToDense (  Output sparse_indices , Output output_shape , Output sparse_values , Output default_value , bool validate_indices = true ,String opName= "SparseToDense" ) 
      {
         OperationDescription desc = NewOperation("SparseToDense", opName);
         desc.AddInput(sparse_indices);
         desc.AddInput(output_shape);
         desc.AddInput(sparse_values);
         desc.AddInput(default_value);

         if (validate_indices != true) desc.SetAttr("validate_indices", validate_indices);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="audio">Input to the operation. </param>
      ///<param name="sample_rate">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] contents(type: DtString).
      ///</return>
      public Operation EncodeWav (  Output audio , Output sample_rate ,String opName= "EncodeWav" ) 
      {
         OperationDescription desc = NewOperation("EncodeWav", opName);
         desc.AddInput(audio);
         desc.AddInput(sample_rate);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation DeleteSessionTensor (  Output handle ,String opName= "DeleteSessionTensor" ) 
      {
         OperationDescription desc = NewOperation("DeleteSessionTensor", opName);
         desc.AddInput(handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation NextIteration (  Output data ,String opName= "NextIteration" ) 
      {
         OperationDescription desc = NewOperation("NextIteration", opName);
         desc.AddInput(data);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="y">Input to the operation. </param>
      ///<param name="dy">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation SigmoidGrad (  Output y , Output dy ,String opName= "SigmoidGrad" ) 
      {
         OperationDescription desc = NewOperation("SigmoidGrad", opName);
         desc.AddInput(y);
         desc.AddInput(dy);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="tree_ensemble_handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] stamp_token(type: DtInt64).
      ///[1] tree_ensemble_serialized(type: DtString).
      ///</return>
      public Operation BoostedTreesSerializeEnsemble (  Output tree_ensemble_handle ,String opName= "BoostedTreesSerializeEnsemble" ) 
      {
         OperationDescription desc = NewOperation("BoostedTreesSerializeEnsemble", opName);
         desc.AddInput(tree_ensemble_handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="l1">Input to the operation. </param>
      ///<param name="l2">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation ApplyProximalAdagrad (  Output var , Output accum , Output lr , Output l1 , Output l2 , Output grad , bool use_locking = false ,String opName= "ApplyProximalAdagrad" ) 
      {
         OperationDescription desc = NewOperation("ApplyProximalAdagrad", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(lr);
         desc.AddInput(l1);
         desc.AddInput(l2);
         desc.AddInput(grad);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="t">Input to the operation. </param>
      ///<param name="clip_value_min">Input to the operation. </param>
      ///<param name="clip_value_max">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation ClipByValue (  Output t , Output clip_value_min , Output clip_value_max ,String opName= "ClipByValue" ) 
      {
         OperationDescription desc = NewOperation("ClipByValue", opName);
         desc.AddInput(t);
         desc.AddInput(clip_value_min);
         desc.AddInput(clip_value_max);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="tree_ensemble_handle">Input to the operation. </param>
      ///<param name="bucketized_features">Input to the operation. </param>
      ///<param name="logits_dimension"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] examples_debug_outputs_serialized(type: DtString).
      ///</return>
      public Operation BoostedTreesExampleDebugOutputs (  Output tree_ensemble_handle , Output bucketized_features , long logits_dimension,String opName= "BoostedTreesExampleDebugOutputs" ) 
      {
         OperationDescription desc = NewOperation("BoostedTreesExampleDebugOutputs", opName);
         desc.AddInput(tree_ensemble_handle);
         desc.AddInput(bucketized_features);
         desc.SetAttr("logits_dimension", logits_dimension);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="contents">Input to the operation. </param>
      ///<param name="desired_channels"></param>
      ///<param name="desired_samples"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] audio(type: DtFloat).
      ///[1] sample_rate(type: DtInt32).
      ///</return>
      public Operation DecodeWav (  Output contents , long desired_channels = -1 , long desired_samples = -1 ,String opName= "DecodeWav" ) 
      {
         OperationDescription desc = NewOperation("DecodeWav", opName);
         desc.AddInput(contents);

         if (desired_channels != -1) desc.SetAttr("desired_channels", desired_channels);
         if (desired_samples != -1) desc.SetAttr("desired_samples", desired_samples);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="tree_ensemble_handle">Input to the operation. </param>
      ///<param name="mean_gradients">Input to the operation. </param>
      ///<param name="mean_hessians">Input to the operation. </param>
      ///<param name="l1">Input to the operation. </param>
      ///<param name="l2">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] continue_centering(type: DtBool).
      ///</return>
      public Operation BoostedTreesCenterBias (  Output tree_ensemble_handle , Output mean_gradients , Output mean_hessians , Output l1 , Output l2 ,String opName= "BoostedTreesCenterBias" ) 
      {
         OperationDescription desc = NewOperation("BoostedTreesCenterBias", opName);
         desc.AddInput(tree_ensemble_handle);
         desc.AddInput(mean_gradients);
         desc.AddInput(mean_hessians);
         desc.AddInput(l1);
         desc.AddInput(l2);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="original_input">Input to the operation. </param>
      ///<param name="batch_index">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="id">Input to the operation. </param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] batched_grad(type: DtInvalid).
      ///</return>
      public Operation UnbatchGrad (  Output original_input , Output batch_index , Output grad , Output id , string container = null , string shared_name = null ,String opName= "UnbatchGrad" ) 
      {
         OperationDescription desc = NewOperation("UnbatchGrad", opName);
         desc.AddInput(original_input);
         desc.AddInput(batch_index);
         desc.AddInput(grad);
         desc.AddInput(id);

         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="out_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Shape (  Output input , DataType? out_type = null ,String opName= "Shape" ) 
      {
         OperationDescription desc = NewOperation("Shape", opName);
         desc.AddInput(input);

         if (out_type.HasValue) desc.SetAttr("out_type", out_type.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="out_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation VariableShape (  Output input , DataType? out_type = null ,String opName= "VariableShape" ) 
      {
         OperationDescription desc = NewOperation("VariableShape", opName);
         desc.AddInput(input);

         if (out_type.HasValue) desc.SetAttr("out_type", out_type.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="data">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] merged(type: DtInvalid).
      ///</return>
      public Operation ParallelDynamicStitch (  Output indices , Output data ,String opName= "ParallelDynamicStitch" ) 
      {
         OperationDescription desc = NewOperation("ParallelDynamicStitch", opName);
         desc.AddInput(indices);
         desc.AddInput(data);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="new_vocab_file">Input to the operation. </param>
      ///<param name="old_vocab_file">Input to the operation. </param>
      ///<param name="new_vocab_offset"></param>
      ///<param name="num_new_vocab"></param>
      ///<param name="old_vocab_size"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] remapping(type: DtInt64).
      ///[1] num_present(type: DtInt32).
      ///</return>
      public Operation GenerateVocabRemapping (  Output new_vocab_file , Output old_vocab_file , long new_vocab_offset, long num_new_vocab, long old_vocab_size = -1 ,String opName= "GenerateVocabRemapping" ) 
      {
         OperationDescription desc = NewOperation("GenerateVocabRemapping", opName);
         desc.AddInput(new_vocab_file);
         desc.AddInput(old_vocab_file);
         desc.SetAttr("new_vocab_offset", new_vocab_offset);
         desc.SetAttr("num_new_vocab", num_new_vocab);
         if (old_vocab_size != -1) desc.SetAttr("old_vocab_size", old_vocab_size);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_indices">Input to the operation. </param>
      ///<param name="input_values">Input to the operation. </param>
      ///<param name="input_shape">Input to the operation. </param>
      ///<param name="reduction_axes">Input to the operation. </param>
      ///<param name="keep_dims"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_indices(type: DtInt64).
      ///[1] output_values(type: DtInvalid).
      ///[2] output_shape(type: DtInt64).
      ///</return>
      public Operation SparseReduceSumSparse (  Output input_indices , Output input_values , Output input_shape , Output reduction_axes , bool keep_dims = false ,String opName= "SparseReduceSumSparse" ) 
      {
         OperationDescription desc = NewOperation("SparseReduceSumSparse", opName);
         desc.AddInput(input_indices);
         desc.AddInput(input_values);
         desc.AddInput(input_shape);
         desc.AddInput(reduction_axes);

         if (keep_dims != false) desc.SetAttr("keep_dims", keep_dims);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="opName">The name of the operation</param>
      public Operation ControlTrigger ( String opName= "ControlTrigger" ) 
      {
         OperationDescription desc = NewOperation("ControlTrigger", opName);



         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="predictions">Input to the operation. </param>
      ///<param name="targets">Input to the operation. </param>
      ///<param name="k"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] precision(type: DtBool).
      ///</return>
      public Operation InTopK (  Output predictions , Output targets , long k,String opName= "InTopK" ) 
      {
         OperationDescription desc = NewOperation("InTopK", opName);
         desc.AddInput(predictions);
         desc.AddInput(targets);
         desc.SetAttr("k", k);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="batched_tensor">Input to the operation. </param>
      ///<param name="batch_index">Input to the operation. </param>
      ///<param name="id">Input to the operation. </param>
      ///<param name="timeout_micros"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] unbatched_tensor(type: DtInvalid).
      ///</return>
      public Operation Unbatch (  Output batched_tensor , Output batch_index , Output id , long timeout_micros, string container = null , string shared_name = null ,String opName= "Unbatch" ) 
      {
         OperationDescription desc = NewOperation("Unbatch", opName);
         desc.AddInput(batched_tensor);
         desc.AddInput(batch_index);
         desc.AddInput(id);
         desc.SetAttr("timeout_micros", timeout_micros);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="values">Input to the operation. </param>
      ///<param name="dense_shape">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation SparseTensorSliceDataset (  Output indices , Output values , Output dense_shape ,String opName= "SparseTensorSliceDataset" ) 
      {
         OperationDescription desc = NewOperation("SparseTensorSliceDataset", opName);
         desc.AddInput(indices);
         desc.AddInput(values);
         desc.AddInput(dense_shape);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="window_size"></param>
      ///<param name="stride"></param>
      ///<param name="magnitude_squared"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] spectrogram(type: DtFloat).
      ///</return>
      public Operation AudioSpectrogram (  Output input , long window_size, long stride, bool magnitude_squared = false ,String opName= "AudioSpectrogram" ) 
      {
         OperationDescription desc = NewOperation("AudioSpectrogram", opName);
         desc.AddInput(input);
         desc.SetAttr("window_size", window_size);
         desc.SetAttr("stride", stride);
         if (magnitude_squared != false) desc.SetAttr("magnitude_squared", magnitude_squared);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="window_size">Input to the operation. </param>
      ///<param name="window_shift">Input to the operation. </param>
      ///<param name="window_stride">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation SlideDataset (  Output input_dataset , Output window_size , Output window_shift , Output window_stride , DataType[] output_types, long[][] output_shapes,String opName= "SlideDataset" ) 
      {
         OperationDescription desc = NewOperation("SlideDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(window_size);
         desc.AddInput(window_shift);
         desc.AddInput(window_stride);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="filenames">Input to the operation. </param>
      ///<param name="header_bytes">Input to the operation. </param>
      ///<param name="record_bytes">Input to the operation. </param>
      ///<param name="footer_bytes">Input to the operation. </param>
      ///<param name="buffer_size">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation FixedLengthRecordDataset (  Output filenames , Output header_bytes , Output record_bytes , Output footer_bytes , Output buffer_size ,String opName= "FixedLengthRecordDataset" ) 
      {
         OperationDescription desc = NewOperation("FixedLengthRecordDataset", opName);
         desc.AddInput(filenames);
         desc.AddInput(header_bytes);
         desc.AddInput(record_bytes);
         desc.AddInput(footer_bytes);
         desc.AddInput(buffer_size);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="num_layers">Input to the operation. </param>
      ///<param name="num_units">Input to the operation. </param>
      ///<param name="input_size">Input to the operation. </param>
      ///<param name="T"></param>
      ///<param name="S"></param>
      ///<param name="rnn_mode"></param>
      ///<param name="input_mode"></param>
      ///<param name="direction"></param>
      ///<param name="dropout"></param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] params_size(type: DtInvalid).
      ///</return>
      public Operation CudnnRNNParamsSize (  Output num_layers , Output num_units , Output input_size , DataType T, DataType S, string rnn_mode = null , string input_mode = null , string direction = null , float dropout = 0f , long seed = 0 , long seed2 = 0 ,String opName= "CudnnRNNParamsSize" ) 
      {
         OperationDescription desc = NewOperation("CudnnRNNParamsSize", opName);
         desc.AddInput(num_layers);
         desc.AddInput(num_units);
         desc.AddInput(input_size);
         desc.SetAttr("T", T);
         desc.SetAttr("S", S);
         if (rnn_mode != null) desc.SetAttr("rnn_mode", rnn_mode);
         if (input_mode != null) desc.SetAttr("input_mode", input_mode);
         if (direction != null) desc.SetAttr("direction", direction);
         if (dropout != 0f) desc.SetAttr("dropout", dropout);
         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="weights">Input to the operation. </param>
      ///<param name="l1"></param>
      ///<param name="l2"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation SdcaShrinkL1 (  Output weights , float l1, float l2,String opName= "SdcaShrinkL1" ) 
      {
         OperationDescription desc = NewOperation("SdcaShrinkL1", opName);
         desc.AddInput(weights);
         desc.SetAttr("l1", l1);
         desc.SetAttr("l2", l2);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="orig_input_tensor_shape">Input to the operation. </param>
      ///<param name="out_backprop">Input to the operation. </param>
      ///<param name="row_pooling_sequence">Input to the operation. </param>
      ///<param name="col_pooling_sequence">Input to the operation. </param>
      ///<param name="overlapping"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation FractionalAvgPoolGrad (  Output orig_input_tensor_shape , Output out_backprop , Output row_pooling_sequence , Output col_pooling_sequence , bool overlapping = false ,String opName= "FractionalAvgPoolGrad" ) 
      {
         OperationDescription desc = NewOperation("FractionalAvgPoolGrad", opName);
         desc.AddInput(orig_input_tensor_shape);
         desc.AddInput(out_backprop);
         desc.AddInput(row_pooling_sequence);
         desc.AddInput(col_pooling_sequence);

         if (overlapping != false) desc.SetAttr("overlapping", overlapping);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="spectrogram">Input to the operation. </param>
      ///<param name="sample_rate">Input to the operation. </param>
      ///<param name="upper_frequency_limit"></param>
      ///<param name="lower_frequency_limit"></param>
      ///<param name="filterbank_channel_count"></param>
      ///<param name="dct_coefficient_count"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtFloat).
      ///</return>
      public Operation Mfcc (  Output spectrogram , Output sample_rate , float upper_frequency_limit = 4000f , float lower_frequency_limit = 20f , long filterbank_channel_count = 40 , long dct_coefficient_count = 13 ,String opName= "Mfcc" ) 
      {
         OperationDescription desc = NewOperation("Mfcc", opName);
         desc.AddInput(spectrogram);
         desc.AddInput(sample_rate);

         if (upper_frequency_limit != 4000f) desc.SetAttr("upper_frequency_limit", upper_frequency_limit);
         if (lower_frequency_limit != 20f) desc.SetAttr("lower_frequency_limit", lower_frequency_limit);
         if (filterbank_channel_count != 40) desc.SetAttr("filterbank_channel_count", filterbank_channel_count);
         if (dct_coefficient_count != 13) desc.SetAttr("dct_coefficient_count", dct_coefficient_count);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="y">Input to the operation. </param>
      ///<param name="dy">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation RsqrtGrad (  Output y , Output dy ,String opName= "RsqrtGrad" ) 
      {
         OperationDescription desc = NewOperation("RsqrtGrad", opName);
         desc.AddInput(y);
         desc.AddInput(dy);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="in_tensors">Input to the operation. </param>
      ///<param name="num_batch_threads"></param>
      ///<param name="max_batch_size"></param>
      ///<param name="batch_timeout_micros"></param>
      ///<param name="grad_timeout_micros"></param>
      ///<param name="max_enqueued_batches"></param>
      ///<param name="allowed_batch_sizes"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="batching_queue"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] batched_tensors(type: DtInvalid).
      ///[1] batch_index(type: DtInt64).
      ///[2] id(type: DtInt64).
      ///</return>
      public Operation Batch (  Output in_tensors , long num_batch_threads, long max_batch_size, long batch_timeout_micros, long grad_timeout_micros, long max_enqueued_batches = 10 , long[] allowed_batch_sizes = null , string container = null , string shared_name = null , string batching_queue = null ,String opName= "Batch" ) 
      {
         OperationDescription desc = NewOperation("Batch", opName);
         desc.AddInput(in_tensors);
         desc.SetAttr("num_batch_threads", num_batch_threads);
         desc.SetAttr("max_batch_size", max_batch_size);
         desc.SetAttr("batch_timeout_micros", batch_timeout_micros);
         desc.SetAttr("grad_timeout_micros", grad_timeout_micros);
         if (max_enqueued_batches != 10) desc.SetAttr("max_enqueued_batches", max_enqueued_batches);
         if (allowed_batch_sizes != null) desc.SetAttr("allowed_batch_sizes", allowed_batch_sizes);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         if (batching_queue != null) desc.SetAttr("batching_queue", batching_queue);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="out_backprop">Input to the operation. </param>
      ///<param name="data_format"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation BiasAddGrad (  Output out_backprop , string data_format = null ,String opName= "BiasAddGrad" ) 
      {
         OperationDescription desc = NewOperation("BiasAddGrad", opName);
         desc.AddInput(out_backprop);

         if (data_format != null) desc.SetAttr("data_format", data_format);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="node_id_range">Input to the operation. </param>
      ///<param name="stats_summary_list">Input to the operation. </param>
      ///<param name="l1">Input to the operation. </param>
      ///<param name="l2">Input to the operation. </param>
      ///<param name="tree_complexity">Input to the operation. </param>
      ///<param name="min_node_weight">Input to the operation. </param>
      ///<param name="max_splits"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] node_ids_list(type: DtInt32).
      ///[1] gains_list(type: DtFloat).
      ///[2] thresholds_list(type: DtInt32).
      ///[3] left_node_contribs_list(type: DtFloat).
      ///[4] right_node_contribs_list(type: DtFloat).
      ///</return>
      public Operation BoostedTreesCalculateBestGainsPerFeature (  Output node_id_range , Output stats_summary_list , Output l1 , Output l2 , Output tree_complexity , Output min_node_weight , long max_splits,String opName= "BoostedTreesCalculateBestGainsPerFeature" ) 
      {
         OperationDescription desc = NewOperation("BoostedTreesCalculateBestGainsPerFeature", opName);
         desc.AddInput(node_id_range);
         desc.AddInput(stats_summary_list);
         desc.AddInput(l1);
         desc.AddInput(l2);
         desc.AddInput(tree_complexity);
         desc.AddInput(min_node_weight);
         desc.SetAttr("max_splits", max_splits);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="in_tensors">Input to the operation. </param>
      ///<param name="captured_tensors">Input to the operation. </param>
      ///<param name="num_batch_threads"></param>
      ///<param name="max_batch_size"></param>
      ///<param name="batch_timeout_micros"></param>
      ///<param name="Tout"></param>
      ///<param name="max_enqueued_batches"></param>
      ///<param name="allowed_batch_sizes"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="batching_queue"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out_tensors(type: DtInvalid).
      ///</return>
      //The following attributes are not known: f: func
      public Operation BatchFunction (  Output in_tensors , Output captured_tensors , long num_batch_threads, long max_batch_size, long batch_timeout_micros, DataType[] Tout, long max_enqueued_batches = 10 , long[] allowed_batch_sizes = null , string container = null , string shared_name = null , string batching_queue = null ,String opName= "BatchFunction" ) 
      {
         OperationDescription desc = NewOperation("BatchFunction", opName);
         desc.AddInput(in_tensors);
         desc.AddInput(captured_tensors);
         desc.SetAttr("num_batch_threads", num_batch_threads);
         desc.SetAttr("max_batch_size", max_batch_size);
         desc.SetAttr("batch_timeout_micros", batch_timeout_micros);
         desc.SetAttr("Tout", Tout);
         if (max_enqueued_batches != 10) desc.SetAttr("max_enqueued_batches", max_enqueued_batches);
         if (allowed_batch_sizes != null) desc.SetAttr("allowed_batch_sizes", allowed_batch_sizes);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         if (batching_queue != null) desc.SetAttr("batching_queue", batching_queue);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="resource_handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] serialized(type: DtVariant).
      ///</return>
      public Operation SerializeIterator (  Output resource_handle ,String opName= "SerializeIterator" ) 
      {
         OperationDescription desc = NewOperation("SerializeIterator", opName);
         desc.AddInput(resource_handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation IFFT3D (  Output input ,String opName= "IFFT3D" ) 
      {
         OperationDescription desc = NewOperation("IFFT3D", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="batch_size">Input to the operation. </param>
      ///<param name="padded_shapes">Input to the operation. </param>
      ///<param name="padding_values">Input to the operation. </param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation PaddedBatchDataset (  Output input_dataset , Output batch_size , Output padded_shapes , Output padding_values , long[][] output_shapes,String opName= "PaddedBatchDataset" ) 
      {
         OperationDescription desc = NewOperation("PaddedBatchDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(batch_size);
         desc.AddInput(padded_shapes);
         desc.AddInput(padding_values);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="frame_name"></param>
      ///<param name="is_constant"></param>
      ///<param name="parallel_iterations"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation RefEnter (  Output data , string frame_name, bool is_constant = false , long parallel_iterations = 10 ,String opName= "RefEnter" ) 
      {
         OperationDescription desc = NewOperation("RefEnter", opName);
         desc.AddInput(data);
         desc.SetAttr("frame_name", frame_name);
         if (is_constant != false) desc.SetAttr("is_constant", is_constant);
         if (parallel_iterations != 10) desc.SetAttr("parallel_iterations", parallel_iterations);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="contents">Input to the operation. </param>
      ///<param name="crop_window">Input to the operation. </param>
      ///<param name="channels"></param>
      ///<param name="ratio"></param>
      ///<param name="fancy_upscaling"></param>
      ///<param name="try_recover_truncated"></param>
      ///<param name="acceptable_fraction"></param>
      ///<param name="dct_method"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] image(type: DtUint8).
      ///</return>
      public Operation DecodeAndCropJpeg (  Output contents , Output crop_window , long channels = 0 , long ratio = 1 , bool fancy_upscaling = true , bool try_recover_truncated = false , float acceptable_fraction = 1f , string dct_method = null ,String opName= "DecodeAndCropJpeg" ) 
      {
         OperationDescription desc = NewOperation("DecodeAndCropJpeg", opName);
         desc.AddInput(contents);
         desc.AddInput(crop_window);

         if (channels != 0) desc.SetAttr("channels", channels);
         if (ratio != 1) desc.SetAttr("ratio", ratio);
         if (fancy_upscaling != true) desc.SetAttr("fancy_upscaling", fancy_upscaling);
         if (try_recover_truncated != false) desc.SetAttr("try_recover_truncated", try_recover_truncated);
         if (acceptable_fraction != 1f) desc.SetAttr("acceptable_fraction", acceptable_fraction);
         if (dct_method != null) desc.SetAttr("dct_method", dct_method);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation Add (  Output x , Output y ,String opName= "Add" ) 
      {
         OperationDescription desc = NewOperation("Add", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] resource(type: DtResource).
      ///</return>
      public Operation BoostedTreesEnsembleResourceHandleOp (  string container = null , string shared_name = null ,String opName= "BoostedTreesEnsembleResourceHandleOp" ) 
      {
         OperationDescription desc = NewOperation("BoostedTreesEnsembleResourceHandleOp", opName);


         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation SquaredDifference (  Output x , Output y ,String opName= "SquaredDifference" ) 
      {
         OperationDescription desc = NewOperation("SquaredDifference", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="prefix">Input to the operation. </param>
      ///<param name="tensor_names">Input to the operation. </param>
      ///<param name="shape_and_slices">Input to the operation. </param>
      ///<param name="dtypes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] tensors(type: DtInvalid).
      ///</return>
      public Operation RestoreV2 (  Output prefix , Output tensor_names , Output shape_and_slices , DataType[] dtypes,String opName= "RestoreV2" ) 
      {
         OperationDescription desc = NewOperation("RestoreV2", opName);
         desc.AddInput(prefix);
         desc.AddInput(tensor_names);
         desc.AddInput(shape_and_slices);
         desc.SetAttr("dtypes", dtypes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="momentum">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="use_nesterov"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceApplyMomentum (  Output var , Output accum , Output lr , Output grad , Output momentum , bool use_locking = false , bool use_nesterov = false ,String opName= "ResourceApplyMomentum" ) 
      {
         OperationDescription desc = NewOperation("ResourceApplyMomentum", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(lr);
         desc.AddInput(grad);
         desc.AddInput(momentum);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         if (use_nesterov != false) desc.SetAttr("use_nesterov", use_nesterov);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="tree_ensemble_handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] is_initialized(type: DtBool).
      ///</return>
      public Operation IsBoostedTreesEnsembleInitialized (  Output tree_ensemble_handle ,String opName= "IsBoostedTreesEnsembleInitialized" ) 
      {
         OperationDescription desc = NewOperation("IsBoostedTreesEnsembleInitialized", opName);
         desc.AddInput(tree_ensemble_handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="i">Input to the operation. </param>
      ///<param name="v">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation InplaceSub (  Output x , Output i , Output v ,String opName= "InplaceSub" ) 
      {
         OperationDescription desc = NewOperation("InplaceSub", opName);
         desc.AddInput(x);
         desc.AddInput(i);
         desc.AddInput(v);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="input_h">Input to the operation. </param>
      ///<param name="input_c">Input to the operation. </param>
      ///<param name="parameters">Input to the operation. </param>
      ///<param name="output">Input to the operation. </param>
      ///<param name="output_h">Input to the operation. </param>
      ///<param name="output_c">Input to the operation. </param>
      ///<param name="output_backprop">Input to the operation. </param>
      ///<param name="output_h_backprop">Input to the operation. </param>
      ///<param name="output_c_backprop">Input to the operation. </param>
      ///<param name="reserve_space">Input to the operation. </param>
      ///<param name="host_reserved">Input to the operation. </param>
      ///<param name="rnn_mode"></param>
      ///<param name="input_mode"></param>
      ///<param name="direction"></param>
      ///<param name="dropout"></param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] input_backprop(type: DtInvalid).
      ///[1] input_h_backprop(type: DtInvalid).
      ///[2] input_c_backprop(type: DtInvalid).
      ///[3] params_backprop(type: DtInvalid).
      ///</return>
      public Operation CudnnRNNBackpropV2 (  Output input , Output input_h , Output input_c , Output parameters , Output output , Output output_h , Output output_c , Output output_backprop , Output output_h_backprop , Output output_c_backprop , Output reserve_space , Output host_reserved , string rnn_mode = null , string input_mode = null , string direction = null , float dropout = 0f , long seed = 0 , long seed2 = 0 ,String opName= "CudnnRNNBackpropV2" ) 
      {
         OperationDescription desc = NewOperation("CudnnRNNBackpropV2", opName);
         desc.AddInput(input);
         desc.AddInput(input_h);
         desc.AddInput(input_c);
         desc.AddInput(parameters);
         desc.AddInput(output);
         desc.AddInput(output_h);
         desc.AddInput(output_c);
         desc.AddInput(output_backprop);
         desc.AddInput(output_h_backprop);
         desc.AddInput(output_c_backprop);
         desc.AddInput(reserve_space);
         desc.AddInput(host_reserved);

         if (rnn_mode != null) desc.SetAttr("rnn_mode", rnn_mode);
         if (input_mode != null) desc.SetAttr("input_mode", input_mode);
         if (direction != null) desc.SetAttr("direction", direction);
         if (dropout != 0f) desc.SetAttr("dropout", dropout);
         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="tree_ensemble_handle">Input to the operation. </param>
      ///<param name="stamp_token">Input to the operation. </param>
      ///<param name="tree_ensemble_serialized">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation BoostedTreesCreateEnsemble (  Output tree_ensemble_handle , Output stamp_token , Output tree_ensemble_serialized ,String opName= "BoostedTreesCreateEnsemble" ) 
      {
         OperationDescription desc = NewOperation("BoostedTreesCreateEnsemble", opName);
         desc.AddInput(tree_ensemble_handle);
         desc.AddInput(stamp_token);
         desc.AddInput(tree_ensemble_serialized);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="value">Input to the operation. </param>
      ///<param name="bias">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation BiasAddV1 (  Output value , Output bias ,String opName= "BiasAddV1" ) 
      {
         OperationDescription desc = NewOperation("BiasAddV1", opName);
         desc.AddInput(value);
         desc.AddInput(bias);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="tree_ensemble_handle">Input to the operation. </param>
      ///<param name="stamp_token">Input to the operation. </param>
      ///<param name="tree_ensemble_serialized">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation BoostedTreesDeserializeEnsemble (  Output tree_ensemble_handle , Output stamp_token , Output tree_ensemble_serialized ,String opName= "BoostedTreesDeserializeEnsemble" ) 
      {
         OperationDescription desc = NewOperation("BoostedTreesDeserializeEnsemble", opName);
         desc.AddInput(tree_ensemble_handle);
         desc.AddInput(stamp_token);
         desc.AddInput(tree_ensemble_serialized);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="shape">Input to the operation. </param>
      ///<param name="alpha">Input to the operation. </param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation RandomGamma (  Output shape , Output alpha , long seed = 0 , long seed2 = 0 ,String opName= "RandomGamma" ) 
      {
         OperationDescription desc = NewOperation("RandomGamma", opName);
         desc.AddInput(shape);
         desc.AddInput(alpha);

         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="tree_ensemble_handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] stamp_token(type: DtInt64).
      ///[1] num_trees(type: DtInt32).
      ///[2] num_finalized_trees(type: DtInt32).
      ///[3] num_attempted_layers(type: DtInt32).
      ///[4] last_layer_nodes_range(type: DtInt32).
      ///</return>
      public Operation BoostedTreesGetEnsembleStates (  Output tree_ensemble_handle ,String opName= "BoostedTreesGetEnsembleStates" ) 
      {
         OperationDescription desc = NewOperation("BoostedTreesGetEnsembleStates", opName);
         desc.AddInput(tree_ensemble_handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reference">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="updates">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_ref(type: DtInvalid).
      ///</return>
      public Operation ScatterMul (  Output reference , Output indices , Output updates , bool use_locking = false ,String opName= "ScatterMul" ) 
      {
         OperationDescription desc = NewOperation("ScatterMul", opName);
         desc.AddInput(reference);
         desc.AddInput(indices);
         desc.AddInput(updates);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] reader_handle(type: DtString).
      ///</return>
      public Operation WholeFileReader (  string container = null , string shared_name = null ,String opName= "WholeFileReader" ) 
      {
         OperationDescription desc = NewOperation("WholeFileReader", opName);


         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="w_in">Input to the operation. </param>
      ///<param name="w_out">Input to the operation. </param>
      ///<param name="examples">Input to the operation. </param>
      ///<param name="labels">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="vocab_count"></param>
      ///<param name="num_negative_samples"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation NegTrain (  Output w_in , Output w_out , Output examples , Output labels , Output lr , long[] vocab_count, long num_negative_samples,String opName= "NegTrain" ) 
      {
         OperationDescription desc = NewOperation("NegTrain", opName);
         desc.AddInput(w_in);
         desc.AddInput(w_out);
         desc.AddInput(examples);
         desc.AddInput(labels);
         desc.AddInput(lr);
         desc.SetAttr("vocab_count", vocab_count);
         desc.SetAttr("num_negative_samples", num_negative_samples);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="node_ids">Input to the operation. </param>
      ///<param name="gradients">Input to the operation. </param>
      ///<param name="hessians">Input to the operation. </param>
      ///<param name="bucketized_features_list">Input to the operation. </param>
      ///<param name="max_splits"></param>
      ///<param name="num_buckets"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] stats_summary(type: DtFloat).
      ///</return>
      public Operation BoostedTreesMakeStatsSummary (  Output node_ids , Output gradients , Output hessians , Output bucketized_features_list , long max_splits, long num_buckets,String opName= "BoostedTreesMakeStatsSummary" ) 
      {
         OperationDescription desc = NewOperation("BoostedTreesMakeStatsSummary", opName);
         desc.AddInput(node_ids);
         desc.AddInput(gradients);
         desc.AddInput(hessians);
         desc.AddInput(bucketized_features_list);
         desc.SetAttr("max_splits", max_splits);
         desc.SetAttr("num_buckets", num_buckets);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="tree_ensemble_handle">Input to the operation. </param>
      ///<param name="bucketized_features">Input to the operation. </param>
      ///<param name="logits_dimension"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] logits(type: DtFloat).
      ///</return>
      public Operation BoostedTreesPredict (  Output tree_ensemble_handle , Output bucketized_features , long logits_dimension,String opName= "BoostedTreesPredict" ) 
      {
         OperationDescription desc = NewOperation("BoostedTreesPredict", opName);
         desc.AddInput(tree_ensemble_handle);
         desc.AddInput(bucketized_features);
         desc.SetAttr("logits_dimension", logits_dimension);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="Tout"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Real (  Output input , DataType? Tout = null ,String opName= "Real" ) 
      {
         OperationDescription desc = NewOperation("Real", opName);
         desc.AddInput(input);

         if (Tout.HasValue) desc.SetAttr("Tout", Tout.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_sizes">Input to the operation. </param>
      ///<param name="filter">Input to the operation. </param>
      ///<param name="out_backprop">Input to the operation. </param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="data_format"></param>
      ///<param name="dilations"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation DepthwiseConv2dNativeBackpropInput (  Output input_sizes , Output filter , Output out_backprop , long[] strides, string padding, string data_format = null , long[] dilations = null ,String opName= "DepthwiseConv2dNativeBackpropInput" ) 
      {
         OperationDescription desc = NewOperation("DepthwiseConv2dNativeBackpropInput", opName);
         desc.AddInput(input_sizes);
         desc.AddInput(filter);
         desc.AddInput(out_backprop);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         if (dilations != null) desc.SetAttr("dilations", dilations);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="contents">Input to the operation. </param>
      ///<param name="channels"></param>
      ///<param name="ratio"></param>
      ///<param name="fancy_upscaling"></param>
      ///<param name="try_recover_truncated"></param>
      ///<param name="acceptable_fraction"></param>
      ///<param name="dct_method"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] image(type: DtUint8).
      ///</return>
      public Operation DecodeJpeg (  Output contents , long channels = 0 , long ratio = 1 , bool fancy_upscaling = true , bool try_recover_truncated = false , float acceptable_fraction = 1f , string dct_method = null ,String opName= "DecodeJpeg" ) 
      {
         OperationDescription desc = NewOperation("DecodeJpeg", opName);
         desc.AddInput(contents);

         if (channels != 0) desc.SetAttr("channels", channels);
         if (ratio != 1) desc.SetAttr("ratio", ratio);
         if (fancy_upscaling != true) desc.SetAttr("fancy_upscaling", fancy_upscaling);
         if (try_recover_truncated != false) desc.SetAttr("try_recover_truncated", try_recover_truncated);
         if (acceptable_fraction != 1f) desc.SetAttr("acceptable_fraction", acceptable_fraction);
         if (dct_method != null) desc.SetAttr("dct_method", dct_method);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="address">Input to the operation. </param>
      ///<param name="method">Input to the operation. </param>
      ///<param name="request">Input to the operation. </param>
      ///<param name="protocol"></param>
      ///<param name="fail_fast"></param>
      ///<param name="timeout_in_ms"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] response(type: DtString).
      ///[1] status_code(type: DtInt32).
      ///[2] status_message(type: DtString).
      ///</return>
      public Operation TryRpc (  Output address , Output method , Output request , string protocol = null , bool fail_fast = true , long timeout_in_ms = 0 ,String opName= "TryRpc" ) 
      {
         OperationDescription desc = NewOperation("TryRpc", opName);
         desc.AddInput(address);
         desc.AddInput(method);
         desc.AddInput(request);

         if (protocol != null) desc.SetAttr("protocol", protocol);
         if (fail_fast != true) desc.SetAttr("fail_fast", fail_fast);
         if (timeout_in_ms != 0) desc.SetAttr("timeout_in_ms", timeout_in_ms);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="tree_ensemble_handle">Input to the operation. </param>
      ///<param name="cached_tree_ids">Input to the operation. </param>
      ///<param name="cached_node_ids">Input to the operation. </param>
      ///<param name="bucketized_features">Input to the operation. </param>
      ///<param name="logits_dimension"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] partial_logits(type: DtFloat).
      ///[1] tree_ids(type: DtInt32).
      ///[2] node_ids(type: DtInt32).
      ///</return>
      public Operation BoostedTreesTrainingPredict (  Output tree_ensemble_handle , Output cached_tree_ids , Output cached_node_ids , Output bucketized_features , long logits_dimension,String opName= "BoostedTreesTrainingPredict" ) 
      {
         OperationDescription desc = NewOperation("BoostedTreesTrainingPredict", opName);
         desc.AddInput(tree_ensemble_handle);
         desc.AddInput(cached_tree_ids);
         desc.AddInput(cached_node_ids);
         desc.AddInput(bucketized_features);
         desc.SetAttr("logits_dimension", logits_dimension);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Sign (  Output x ,String opName= "Sign" ) 
      {
         OperationDescription desc = NewOperation("Sign", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="inputs">Input to the operation. </param>
      ///<param name="labels_indices">Input to the operation. </param>
      ///<param name="labels_values">Input to the operation. </param>
      ///<param name="sequence_length">Input to the operation. </param>
      ///<param name="preprocess_collapse_repeated"></param>
      ///<param name="ctc_merge_repeated"></param>
      ///<param name="ignore_longer_outputs_than_inputs"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] loss(type: DtFloat).
      ///[1] gradient(type: DtFloat).
      ///</return>
      public Operation CTCLoss (  Output inputs , Output labels_indices , Output labels_values , Output sequence_length , bool preprocess_collapse_repeated = false , bool ctc_merge_repeated = true , bool ignore_longer_outputs_than_inputs = false ,String opName= "CTCLoss" ) 
      {
         OperationDescription desc = NewOperation("CTCLoss", opName);
         desc.AddInput(inputs);
         desc.AddInput(labels_indices);
         desc.AddInput(labels_values);
         desc.AddInput(sequence_length);

         if (preprocess_collapse_repeated != false) desc.SetAttr("preprocess_collapse_repeated", preprocess_collapse_repeated);
         if (ctc_merge_repeated != true) desc.SetAttr("ctc_merge_repeated", ctc_merge_repeated);
         if (ignore_longer_outputs_than_inputs != false) desc.SetAttr("ignore_longer_outputs_than_inputs", ignore_longer_outputs_than_inputs);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="fft_length">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtComplex64).
      ///</return>
      public Operation RFFT3D (  Output input , Output fft_length ,String opName= "RFFT3D" ) 
      {
         OperationDescription desc = NewOperation("RFFT3D", opName);
         desc.AddInput(input);
         desc.AddInput(fft_length);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="true_classes">Input to the operation. </param>
      ///<param name="num_true"></param>
      ///<param name="num_sampled"></param>
      ///<param name="unique"></param>
      ///<param name="range_max"></param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] sampled_candidates(type: DtInt64).
      ///[1] true_expected_count(type: DtFloat).
      ///[2] sampled_expected_count(type: DtFloat).
      ///</return>
      public Operation UniformCandidateSampler (  Output true_classes , long num_true, long num_sampled, bool unique, long range_max, long seed = 0 , long seed2 = 0 ,String opName= "UniformCandidateSampler" ) 
      {
         OperationDescription desc = NewOperation("UniformCandidateSampler", opName);
         desc.AddInput(true_classes);
         desc.SetAttr("num_true", num_true);
         desc.SetAttr("num_sampled", num_sampled);
         desc.SetAttr("unique", unique);
         desc.SetAttr("range_max", range_max);
         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="tree_ensemble_handle">Input to the operation. </param>
      ///<param name="feature_ids">Input to the operation. </param>
      ///<param name="node_ids">Input to the operation. </param>
      ///<param name="gains">Input to the operation. </param>
      ///<param name="thresholds">Input to the operation. </param>
      ///<param name="left_node_contribs">Input to the operation. </param>
      ///<param name="right_node_contribs">Input to the operation. </param>
      ///<param name="max_depth">Input to the operation. </param>
      ///<param name="learning_rate">Input to the operation. </param>
      ///<param name="pruning_mode"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation BoostedTreesUpdateEnsemble (  Output tree_ensemble_handle , Output feature_ids , Output node_ids , Output gains , Output thresholds , Output left_node_contribs , Output right_node_contribs , Output max_depth , Output learning_rate , long pruning_mode,String opName= "BoostedTreesUpdateEnsemble" ) 
      {
         OperationDescription desc = NewOperation("BoostedTreesUpdateEnsemble", opName);
         desc.AddInput(tree_ensemble_handle);
         desc.AddInput(feature_ids);
         desc.AddInput(node_ids);
         desc.AddInput(gains);
         desc.AddInput(thresholds);
         desc.AddInput(left_node_contribs);
         desc.AddInput(right_node_contribs);
         desc.AddInput(max_depth);
         desc.AddInput(learning_rate);
         desc.SetAttr("pruning_mode", pruning_mode);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="values">Input to the operation. </param>
      ///<param name="axis"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Pack (  Output values , long axis = 0 ,String opName= "Pack" ) 
      {
         OperationDescription desc = NewOperation("Pack", opName);
         desc.AddInput(values);

         if (axis != 0) desc.SetAttr("axis", axis);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="fft_length">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtFloat).
      ///</return>
      public Operation IRFFT2D (  Output input , Output fft_length ,String opName= "IRFFT2D" ) 
      {
         OperationDescription desc = NewOperation("IRFFT2D", opName);
         desc.AddInput(input);
         desc.AddInput(fft_length);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Lgamma (  Output x ,String opName= "Lgamma" ) 
      {
         OperationDescription desc = NewOperation("Lgamma", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="inputs">Input to the operation. </param>
      ///<param name="sequence_length">Input to the operation. </param>
      ///<param name="beam_width"></param>
      ///<param name="top_paths"></param>
      ///<param name="merge_repeated"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] decoded_indices(type: DtInt64).
      ///[1] decoded_values(type: DtInt64).
      ///[2] decoded_shape(type: DtInt64).
      ///[3] log_probability(type: DtFloat).
      ///</return>
      public Operation CTCBeamSearchDecoder (  Output inputs , Output sequence_length , long beam_width, long top_paths, bool merge_repeated = true ,String opName= "CTCBeamSearchDecoder" ) 
      {
         OperationDescription desc = NewOperation("CTCBeamSearchDecoder", opName);
         desc.AddInput(inputs);
         desc.AddInput(sequence_length);
         desc.SetAttr("beam_width", beam_width);
         desc.SetAttr("top_paths", top_paths);
         if (merge_repeated != true) desc.SetAttr("merge_repeated", merge_repeated);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="true_classes">Input to the operation. </param>
      ///<param name="num_true"></param>
      ///<param name="num_sampled"></param>
      ///<param name="unique"></param>
      ///<param name="range_max"></param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] sampled_candidates(type: DtInt64).
      ///[1] true_expected_count(type: DtFloat).
      ///[2] sampled_expected_count(type: DtFloat).
      ///</return>
      public Operation LogUniformCandidateSampler (  Output true_classes , long num_true, long num_sampled, bool unique, long range_max, long seed = 0 , long seed2 = 0 ,String opName= "LogUniformCandidateSampler" ) 
      {
         OperationDescription desc = NewOperation("LogUniformCandidateSampler", opName);
         desc.AddInput(true_classes);
         desc.SetAttr("num_true", num_true);
         desc.SetAttr("num_sampled", num_sampled);
         desc.SetAttr("unique", unique);
         desc.SetAttr("range_max", range_max);
         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reader_handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] records_produced(type: DtInt64).
      ///</return>
      public Operation ReaderNumRecordsProducedV2 (  Output reader_handle ,String opName= "ReaderNumRecordsProducedV2" ) 
      {
         OperationDescription desc = NewOperation("ReaderNumRecordsProducedV2", opName);
         desc.AddInput(reader_handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="num_required">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] average(type: DtInvalid).
      ///</return>
      public Operation AccumulatorTakeGradient (  Output handle , Output num_required , DataType dtype,String opName= "AccumulatorTakeGradient" ) 
      {
         OperationDescription desc = NewOperation("AccumulatorTakeGradient", opName);
         desc.AddInput(handle);
         desc.AddInput(num_required);
         desc.SetAttr("dtype", dtype);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="other_arguments">Input to the operation. </param>
      ///<param name="batch_size">Input to the operation. </param>
      ///<param name="num_parallel_calls">Input to the operation. </param>
      ///<param name="drop_remainder">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      //The following attributes are not known: f: func
      public Operation MapAndBatchDatasetV2 (  Output input_dataset , Output other_arguments , Output batch_size , Output num_parallel_calls , Output drop_remainder , DataType[] output_types, long[][] output_shapes,String opName= "MapAndBatchDatasetV2" ) 
      {
         OperationDescription desc = NewOperation("MapAndBatchDatasetV2", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(other_arguments);
         desc.AddInput(batch_size);
         desc.AddInput(num_parallel_calls);
         desc.AddInput(drop_remainder);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="component_types"></param>
      ///<param name="shapes"></param>
      ///<param name="capacity"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtResource).
      ///</return>
      public Operation FIFOQueueV2 (  DataType[] component_types, long[][] shapes = null , long capacity = -1 , string container = null , string shared_name = null ,String opName= "FIFOQueueV2" ) 
      {
         OperationDescription desc = NewOperation("FIFOQueueV2", opName);

         desc.SetAttr("component_types", component_types);
         if (shapes != null) desc.SetAttrShapeList("shapes", shapes);
         if (capacity != -1) desc.SetAttr("capacity", capacity);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="component_types"></param>
      ///<param name="shapes"></param>
      ///<param name="capacity"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtString).
      ///</return>
      public Operation FIFOQueue (  DataType[] component_types, long[][] shapes = null , long capacity = -1 , string container = null , string shared_name = null ,String opName= "FIFOQueue" ) 
      {
         OperationDescription desc = NewOperation("FIFOQueue", opName);

         desc.SetAttr("component_types", component_types);
         if (shapes != null) desc.SetAttrShapeList("shapes", shapes);
         if (capacity != -1) desc.SetAttr("capacity", capacity);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="out_idx"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///[1] idx(type: DtInvalid).
      ///</return>
      public Operation ListDiff (  Output x , Output y , DataType? out_idx = null ,String opName= "ListDiff" ) 
      {
         OperationDescription desc = NewOperation("ListDiff", opName);
         desc.AddInput(x);
         desc.AddInput(y);

         if (out_idx.HasValue) desc.SetAttr("out_idx", out_idx.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtString).
      ///</return>
      public Operation StringStrip (  Output input ,String opName= "StringStrip" ) 
      {
         OperationDescription desc = NewOperation("StringStrip", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="other_arguments">Input to the operation. </param>
      ///<param name="batch_size">Input to the operation. </param>
      ///<param name="num_parallel_batches">Input to the operation. </param>
      ///<param name="drop_remainder">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      //The following attributes are not known: f: func
      public Operation MapAndBatchDataset (  Output input_dataset , Output other_arguments , Output batch_size , Output num_parallel_batches , Output drop_remainder , DataType[] output_types, long[][] output_shapes,String opName= "MapAndBatchDataset" ) 
      {
         OperationDescription desc = NewOperation("MapAndBatchDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(other_arguments);
         desc.AddInput(batch_size);
         desc.AddInput(num_parallel_batches);
         desc.AddInput(drop_remainder);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="shift">Input to the operation. </param>
      ///<param name="axis">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Roll (  Output input , Output shift , Output axis ,String opName= "Roll" ) 
      {
         OperationDescription desc = NewOperation("Roll", opName);
         desc.AddInput(input);
         desc.AddInput(shift);
         desc.AddInput(axis);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="min_input">Input to the operation. </param>
      ///<param name="max_input">Input to the operation. </param>
      ///<param name="ksize"></param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///[1] min_output(type: DtFloat).
      ///[2] max_output(type: DtFloat).
      ///</return>
      public Operation QuantizedMaxPool (  Output input , Output min_input , Output max_input , long[] ksize, long[] strides, string padding,String opName= "QuantizedMaxPool" ) 
      {
         OperationDescription desc = NewOperation("QuantizedMaxPool", opName);
         desc.AddInput(input);
         desc.AddInput(min_input);
         desc.AddInput(max_input);
         desc.SetAttr("ksize", ksize);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation RefNextIteration (  Output data ,String opName= "RefNextIteration" ) 
      {
         OperationDescription desc = NewOperation("RefNextIteration", opName);
         desc.AddInput(data);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation DeepCopy (  Output x ,String opName= "DeepCopy" ) 
      {
         OperationDescription desc = NewOperation("DeepCopy", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="ms">Input to the operation. </param>
      ///<param name="mom">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="rho">Input to the operation. </param>
      ///<param name="momentum">Input to the operation. </param>
      ///<param name="epsilon">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation SparseApplyRMSProp (  Output var , Output ms , Output mom , Output lr , Output rho , Output momentum , Output epsilon , Output grad , Output indices , bool use_locking = false ,String opName= "SparseApplyRMSProp" ) 
      {
         OperationDescription desc = NewOperation("SparseApplyRMSProp", opName);
         desc.AddInput(var);
         desc.AddInput(ms);
         desc.AddInput(mom);
         desc.AddInput(lr);
         desc.AddInput(rho);
         desc.AddInput(momentum);
         desc.AddInput(epsilon);
         desc.AddInput(grad);
         desc.AddInput(indices);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="true_classes">Input to the operation. </param>
      ///<param name="num_true"></param>
      ///<param name="num_sampled"></param>
      ///<param name="unique"></param>
      ///<param name="range_max"></param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] sampled_candidates(type: DtInt64).
      ///[1] true_expected_count(type: DtFloat).
      ///[2] sampled_expected_count(type: DtFloat).
      ///</return>
      public Operation LearnedUnigramCandidateSampler (  Output true_classes , long num_true, long num_sampled, bool unique, long range_max, long seed = 0 , long seed2 = 0 ,String opName= "LearnedUnigramCandidateSampler" ) 
      {
         OperationDescription desc = NewOperation("LearnedUnigramCandidateSampler", opName);
         desc.AddInput(true_classes);
         desc.SetAttr("num_true", num_true);
         desc.SetAttr("num_sampled", num_sampled);
         desc.SetAttr("unique", unique);
         desc.SetAttr("range_max", range_max);
         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="another_dataset">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation ConcatenateDataset (  Output input_dataset , Output another_dataset , DataType[] output_types, long[][] output_shapes,String opName= "ConcatenateDataset" ) 
      {
         OperationDescription desc = NewOperation("ConcatenateDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(another_dataset);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="sparse_handles">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] sparse_indices(type: DtInt64).
      ///[1] sparse_values(type: DtInvalid).
      ///[2] sparse_shape(type: DtInt64).
      ///</return>
      public Operation TakeManySparseFromTensorsMap (  Output sparse_handles , DataType dtype, string container = null , string shared_name = null ,String opName= "TakeManySparseFromTensorsMap" ) 
      {
         OperationDescription desc = NewOperation("TakeManySparseFromTensorsMap", opName);
         desc.AddInput(sparse_handles);
         desc.SetAttr("dtype", dtype);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="true_classes">Input to the operation. </param>
      ///<param name="num_true"></param>
      ///<param name="num_sampled"></param>
      ///<param name="unique"></param>
      ///<param name="range_max"></param>
      ///<param name="vocab_file"></param>
      ///<param name="distortion"></param>
      ///<param name="num_reserved_ids"></param>
      ///<param name="num_shards"></param>
      ///<param name="shard"></param>
      ///<param name="unigrams"></param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] sampled_candidates(type: DtInt64).
      ///[1] true_expected_count(type: DtFloat).
      ///[2] sampled_expected_count(type: DtFloat).
      ///</return>
      public Operation FixedUnigramCandidateSampler (  Output true_classes , long num_true, long num_sampled, bool unique, long range_max, string vocab_file = null , float distortion = 1f , long num_reserved_ids = 0 , long num_shards = 1 , long shard = 0 , float[] unigrams = null , long seed = 0 , long seed2 = 0 ,String opName= "FixedUnigramCandidateSampler" ) 
      {
         OperationDescription desc = NewOperation("FixedUnigramCandidateSampler", opName);
         desc.AddInput(true_classes);
         desc.SetAttr("num_true", num_true);
         desc.SetAttr("num_sampled", num_sampled);
         desc.SetAttr("unique", unique);
         desc.SetAttr("range_max", range_max);
         if (vocab_file != null) desc.SetAttr("vocab_file", vocab_file);
         if (distortion != 1f) desc.SetAttr("distortion", distortion);
         if (num_reserved_ids != 0) desc.SetAttr("num_reserved_ids", num_reserved_ids);
         if (num_shards != 1) desc.SetAttr("num_shards", num_shards);
         if (shard != 0) desc.SetAttr("shard", shard);
         if (unigrams != null) desc.SetAttr("unigrams", unigrams);
         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="tolerance"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtBool).
      ///</return>
      public Operation ApproximateEqual (  Output x , Output y , float tolerance = 1E-05f ,String opName= "ApproximateEqual" ) 
      {
         OperationDescription desc = NewOperation("ApproximateEqual", opName);
         desc.AddInput(x);
         desc.AddInput(y);

         if (tolerance != 1E-05f) desc.SetAttr("tolerance", tolerance);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="true_classes">Input to the operation. </param>
      ///<param name="num_true"></param>
      ///<param name="num_sampled"></param>
      ///<param name="unique"></param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] sampled_candidates(type: DtInt64).
      ///[1] true_expected_count(type: DtFloat).
      ///[2] sampled_expected_count(type: DtFloat).
      ///</return>
      public Operation AllCandidateSampler (  Output true_classes , long num_true, long num_sampled, bool unique, long seed = 0 , long seed2 = 0 ,String opName= "AllCandidateSampler" ) 
      {
         OperationDescription desc = NewOperation("AllCandidateSampler", opName);
         desc.AddInput(true_classes);
         desc.SetAttr("num_true", num_true);
         desc.SetAttr("num_sampled", num_sampled);
         desc.SetAttr("unique", unique);
         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="shape"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation PlaceholderWithDefault (  Output input , long[] shape,String opName= "PlaceholderWithDefault" ) 
      {
         OperationDescription desc = NewOperation("PlaceholderWithDefault", opName);
         desc.AddInput(input);
         desc.SetAttrShape("shape", shape);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation FloorMod (  Output x , Output y ,String opName= "FloorMod" ) 
      {
         OperationDescription desc = NewOperation("FloorMod", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Sigmoid (  Output x ,String opName= "Sigmoid" ) 
      {
         OperationDescription desc = NewOperation("Sigmoid", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="tags">Input to the operation. </param>
      ///<param name="values">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] summary(type: DtString).
      ///</return>
      public Operation ScalarSummary (  Output tags , Output values ,String opName= "ScalarSummary" ) 
      {
         OperationDescription desc = NewOperation("ScalarSummary", opName);
         desc.AddInput(tags);
         desc.AddInput(values);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="tensor">Input to the operation. </param>
      ///<param name="message"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation CheckNumerics (  Output tensor , string message,String opName= "CheckNumerics" ) 
      {
         OperationDescription desc = NewOperation("CheckNumerics", opName);
         desc.AddInput(tensor);
         desc.SetAttr("message", message);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="true_classes">Input to the operation. </param>
      ///<param name="sampled_candidates">Input to the operation. </param>
      ///<param name="num_true"></param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] indices(type: DtInt32).
      ///[1] ids(type: DtInt64).
      ///[2] weights(type: DtFloat).
      ///</return>
      public Operation ComputeAccidentalHits (  Output true_classes , Output sampled_candidates , long num_true, long seed = 0 , long seed2 = 0 ,String opName= "ComputeAccidentalHits" ) 
      {
         OperationDescription desc = NewOperation("ComputeAccidentalHits", opName);
         desc.AddInput(true_classes);
         desc.AddInput(sampled_candidates);
         desc.SetAttr("num_true", num_true);
         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         return desc.FinishOperation();
      } 
      // Skipped function _Recv

      ///<summary>
      ///
      ///</summary>
      ///<param name="writer">Input to the operation. </param>
      ///<param name="step">Input to the operation. </param>
      ///<param name="tag">Input to the operation. </param>
      ///<param name="tensor">Input to the operation. </param>
      ///<param name="sample_rate">Input to the operation. </param>
      ///<param name="max_outputs"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation WriteAudioSummary (  Output writer , Output step , Output tag , Output tensor , Output sample_rate , long max_outputs = 3 ,String opName= "WriteAudioSummary" ) 
      {
         OperationDescription desc = NewOperation("WriteAudioSummary", opName);
         desc.AddInput(writer);
         desc.AddInput(step);
         desc.AddInput(tag);
         desc.AddInput(tensor);
         desc.AddInput(sample_rate);

         if (max_outputs != 3) desc.SetAttr("max_outputs", max_outputs);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="set_indices">Input to the operation. </param>
      ///<param name="set_values">Input to the operation. </param>
      ///<param name="set_shape">Input to the operation. </param>
      ///<param name="validate_indices"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] size(type: DtInt32).
      ///</return>
      public Operation SetSize (  Output set_indices , Output set_values , Output set_shape , bool validate_indices = true ,String opName= "SetSize" ) 
      {
         OperationDescription desc = NewOperation("SetSize", opName);
         desc.AddInput(set_indices);
         desc.AddInput(set_values);
         desc.AddInput(set_shape);

         if (validate_indices != true) desc.SetAttr("validate_indices", validate_indices);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="component_types"></param>
      ///<param name="shapes"></param>
      ///<param name="capacity"></param>
      ///<param name="min_after_dequeue"></param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtResource).
      ///</return>
      public Operation RandomShuffleQueueV2 (  DataType[] component_types, long[][] shapes = null , long capacity = -1 , long min_after_dequeue = 0 , long seed = 0 , long seed2 = 0 , string container = null , string shared_name = null ,String opName= "RandomShuffleQueueV2" ) 
      {
         OperationDescription desc = NewOperation("RandomShuffleQueueV2", opName);

         desc.SetAttr("component_types", component_types);
         if (shapes != null) desc.SetAttrShapeList("shapes", shapes);
         if (capacity != -1) desc.SetAttr("capacity", capacity);
         if (min_after_dequeue != 0) desc.SetAttr("min_after_dequeue", min_after_dequeue);
         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="ckpt_path">Input to the operation. </param>
      ///<param name="old_tensor_name">Input to the operation. </param>
      ///<param name="row_remapping">Input to the operation. </param>
      ///<param name="col_remapping">Input to the operation. </param>
      ///<param name="initializing_values">Input to the operation. </param>
      ///<param name="num_rows"></param>
      ///<param name="num_cols"></param>
      ///<param name="max_rows_in_memory"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_matrix(type: DtFloat).
      ///</return>
      public Operation LoadAndRemapMatrix (  Output ckpt_path , Output old_tensor_name , Output row_remapping , Output col_remapping , Output initializing_values , long num_rows, long num_cols, long max_rows_in_memory = -1 ,String opName= "LoadAndRemapMatrix" ) 
      {
         OperationDescription desc = NewOperation("LoadAndRemapMatrix", opName);
         desc.AddInput(ckpt_path);
         desc.AddInput(old_tensor_name);
         desc.AddInput(row_remapping);
         desc.AddInput(col_remapping);
         desc.AddInput(initializing_values);
         desc.SetAttr("num_rows", num_rows);
         desc.SetAttr("num_cols", num_cols);
         if (max_rows_in_memory != -1) desc.SetAttr("max_rows_in_memory", max_rows_in_memory);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="shape_to_prepend">Input to the operation. </param>
      ///<param name="source"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] grad_handle(type: DtResource).
      ///[1] flow_out(type: DtFloat).
      ///</return>
      public Operation TensorArrayGradWithShape (  Output handle , Output flow_in , Output shape_to_prepend , string source,String opName= "TensorArrayGradWithShape" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayGradWithShape", opName);
         desc.AddInput(handle);
         desc.AddInput(flow_in);
         desc.AddInput(shape_to_prepend);
         desc.SetAttr("source", source);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="signed_input"></param>
      ///<param name="num_bits"></param>
      ///<param name="range_given"></param>
      ///<param name="input_min"></param>
      ///<param name="input_max"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation QuantizeAndDequantize (  Output input , bool signed_input = true , long num_bits = 8 , bool range_given = false , float input_min = 0f , float input_max = 0f ,String opName= "QuantizeAndDequantize" ) 
      {
         OperationDescription desc = NewOperation("QuantizeAndDequantize", opName);
         desc.AddInput(input);

         if (signed_input != true) desc.SetAttr("signed_input", signed_input);
         if (num_bits != 8) desc.SetAttr("num_bits", num_bits);
         if (range_given != false) desc.SetAttr("range_given", range_given);
         if (input_min != 0f) desc.SetAttr("input_min", input_min);
         if (input_max != 0f) desc.SetAttr("input_max", input_max);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="gradients">Input to the operation. </param>
      ///<param name="features">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] backprops(type: DtInvalid).
      ///</return>
      public Operation ReluGrad (  Output gradients , Output features ,String opName= "ReluGrad" ) 
      {
         OperationDescription desc = NewOperation("ReluGrad", opName);
         desc.AddInput(gradients);
         desc.AddInput(features);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="group_size"></param>
      ///<param name="group_key"></param>
      ///<param name="instance_key"></param>
      ///<param name="merge_op"></param>
      ///<param name="final_op"></param>
      ///<param name="subdiv_offsets"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] data(type: DtInvalid).
      ///</return>
      public Operation CollectiveReduce (  Output input , long group_size, long group_key, long instance_key, string merge_op, string final_op, long[] subdiv_offsets,String opName= "CollectiveReduce" ) 
      {
         OperationDescription desc = NewOperation("CollectiveReduce", opName);
         desc.AddInput(input);
         desc.SetAttr("group_size", group_size);
         desc.SetAttr("group_key", group_key);
         desc.SetAttr("instance_key", instance_key);
         desc.SetAttr("merge_op", merge_op);
         desc.SetAttr("final_op", final_op);
         desc.SetAttr("subdiv_offsets", subdiv_offsets);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="group_size"></param>
      ///<param name="group_key"></param>
      ///<param name="instance_key"></param>
      ///<param name="shape"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] data(type: DtInvalid).
      ///</return>
      public Operation CollectiveBcastSend (  Output input , long group_size, long group_key, long instance_key, long[] shape,String opName= "CollectiveBcastSend" ) 
      {
         OperationDescription desc = NewOperation("CollectiveBcastSend", opName);
         desc.AddInput(input);
         desc.SetAttr("group_size", group_size);
         desc.SetAttr("group_key", group_key);
         desc.SetAttr("instance_key", instance_key);
         desc.SetAttrShape("shape", shape);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtComplex64).
      ///</return>
      public Operation BatchIFFT2D (  Output input ,String opName= "BatchIFFT2D" ) 
      {
         OperationDescription desc = NewOperation("BatchIFFT2D", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="index">Input to the operation. </param>
      ///<param name="inputs">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation RefSelect (  Output index , Output inputs ,String opName= "RefSelect" ) 
      {
         OperationDescription desc = NewOperation("RefSelect", opName);
         desc.AddInput(index);
         desc.AddInput(inputs);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="y_backprop">Input to the operation. </param>
      ///<param name="x">Input to the operation. </param>
      ///<param name="scale">Input to the operation. </param>
      ///<param name="reserve_space_1">Input to the operation. </param>
      ///<param name="reserve_space_2">Input to the operation. </param>
      ///<param name="epsilon"></param>
      ///<param name="data_format"></param>
      ///<param name="is_training"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] x_backprop(type: DtInvalid).
      ///[1] scale_backprop(type: DtInvalid).
      ///[2] offset_backprop(type: DtInvalid).
      ///[3] reserve_space_3(type: DtInvalid).
      ///[4] reserve_space_4(type: DtInvalid).
      ///</return>
      public Operation FusedBatchNormGrad (  Output y_backprop , Output x , Output scale , Output reserve_space_1 , Output reserve_space_2 , float epsilon = 0.0001f , string data_format = null , bool is_training = true ,String opName= "FusedBatchNormGrad" ) 
      {
         OperationDescription desc = NewOperation("FusedBatchNormGrad", opName);
         desc.AddInput(y_backprop);
         desc.AddInput(x);
         desc.AddInput(scale);
         desc.AddInput(reserve_space_1);
         desc.AddInput(reserve_space_2);

         if (epsilon != 0.0001f) desc.SetAttr("epsilon", epsilon);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         if (is_training != true) desc.SetAttr("is_training", is_training);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="n">Input to the operation. </param>
      ///<param name="component_types"></param>
      ///<param name="timeout_ms"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] components(type: DtInvalid).
      ///</return>
      public Operation QueueDequeueUpTo (  Output handle , Output n , DataType[] component_types, long timeout_ms = -1 ,String opName= "QueueDequeueUpTo" ) 
      {
         OperationDescription desc = NewOperation("QueueDequeueUpTo", opName);
         desc.AddInput(handle);
         desc.AddInput(n);
         desc.SetAttr("component_types", component_types);
         if (timeout_ms != -1) desc.SetAttr("timeout_ms", timeout_ms);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="contents">Input to the operation. </param>
      ///<param name="channels"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] image(type: DtUint8).
      ///</return>
      public Operation DecodeBmp (  Output contents , long channels = 0 ,String opName= "DecodeBmp" ) 
      {
         OperationDescription desc = NewOperation("DecodeBmp", opName);
         desc.AddInput(contents);

         if (channels != 0) desc.SetAttr("channels", channels);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="src_format"></param>
      ///<param name="dst_format"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation DataFormatDimMap (  Output x , string src_format = null , string dst_format = null ,String opName= "DataFormatDimMap" ) 
      {
         OperationDescription desc = NewOperation("DataFormatDimMap", opName);
         desc.AddInput(x);

         if (src_format != null) desc.SetAttr("src_format", src_format);
         if (dst_format != null) desc.SetAttr("dst_format", dst_format);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="T"></param>
      ///<param name="group_size"></param>
      ///<param name="group_key"></param>
      ///<param name="instance_key"></param>
      ///<param name="shape"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] data(type: DtInvalid).
      ///</return>
      public Operation CollectiveBcastRecv (  DataType T, long group_size, long group_key, long instance_key, long[] shape,String opName= "CollectiveBcastRecv" ) 
      {
         OperationDescription desc = NewOperation("CollectiveBcastRecv", opName);

         desc.SetAttr("T", T);
         desc.SetAttr("group_size", group_size);
         desc.SetAttr("group_key", group_key);
         desc.SetAttr("instance_key", instance_key);
         desc.SetAttrShape("shape", shape);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="contents">Input to the operation. </param>
      ///<param name="channels"></param>
      ///<param name="dtype"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] image(type: DtInvalid).
      ///</return>
      public Operation DecodePng (  Output contents , long channels = 0 , DataType? dtype = null ,String opName= "DecodePng" ) 
      {
         OperationDescription desc = NewOperation("DecodePng", opName);
         desc.AddInput(contents);

         if (channels != 0) desc.SetAttr("channels", channels);
         if (dtype.HasValue) desc.SetAttr("dtype", dtype.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Log (  Output x ,String opName= "Log" ) 
      {
         OperationDescription desc = NewOperation("Log", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="pred">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_false(type: DtInvalid).
      ///[1] output_true(type: DtInvalid).
      ///</return>
      public Operation Switch (  Output data , Output pred ,String opName= "Switch" ) 
      {
         OperationDescription desc = NewOperation("Switch", opName);
         desc.AddInput(data);
         desc.AddInput(pred);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="num_layers">Input to the operation. </param>
      ///<param name="num_units">Input to the operation. </param>
      ///<param name="input_size">Input to the operation. </param>
      ///<param name="parameters">Input to the operation. </param>
      ///<param name="num_params"></param>
      ///<param name="rnn_mode"></param>
      ///<param name="input_mode"></param>
      ///<param name="direction"></param>
      ///<param name="dropout"></param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] weights(type: DtInvalid).
      ///[1] biases(type: DtInvalid).
      ///</return>
      public Operation CudnnRNNParamsToCanonical (  Output num_layers , Output num_units , Output input_size , Output parameters , long num_params, string rnn_mode = null , string input_mode = null , string direction = null , float dropout = 0f , long seed = 0 , long seed2 = 0 ,String opName= "CudnnRNNParamsToCanonical" ) 
      {
         OperationDescription desc = NewOperation("CudnnRNNParamsToCanonical", opName);
         desc.AddInput(num_layers);
         desc.AddInput(num_units);
         desc.AddInput(input_size);
         desc.AddInput(parameters);
         desc.SetAttr("num_params", num_params);
         if (rnn_mode != null) desc.SetAttr("rnn_mode", rnn_mode);
         if (input_mode != null) desc.SetAttr("input_mode", input_mode);
         if (direction != null) desc.SetAttr("direction", direction);
         if (dropout != 0f) desc.SetAttr("dropout", dropout);
         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="parameters">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="validate_indices"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Gather (  Output parameters , Output indices , bool validate_indices = true ,String opName= "Gather" ) 
      {
         OperationDescription desc = NewOperation("Gather", opName);
         desc.AddInput(parameters);
         desc.AddInput(indices);

         if (validate_indices != true) desc.SetAttr("validate_indices", validate_indices);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="scale">Input to the operation. </param>
      ///<param name="offset">Input to the operation. </param>
      ///<param name="mean">Input to the operation. </param>
      ///<param name="variance">Input to the operation. </param>
      ///<param name="epsilon"></param>
      ///<param name="data_format"></param>
      ///<param name="is_training"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///[1] batch_mean(type: DtInvalid).
      ///[2] batch_variance(type: DtInvalid).
      ///[3] reserve_space_1(type: DtInvalid).
      ///[4] reserve_space_2(type: DtInvalid).
      ///</return>
      public Operation FusedBatchNorm (  Output x , Output scale , Output offset , Output mean , Output variance , float epsilon = 0.0001f , string data_format = null , bool is_training = true ,String opName= "FusedBatchNorm" ) 
      {
         OperationDescription desc = NewOperation("FusedBatchNorm", opName);
         desc.AddInput(x);
         desc.AddInput(scale);
         desc.AddInput(offset);
         desc.AddInput(mean);
         desc.AddInput(variance);

         if (epsilon != 0.0001f) desc.SetAttr("epsilon", epsilon);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         if (is_training != true) desc.SetAttr("is_training", is_training);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="gradients">Input to the operation. </param>
      ///<param name="outputs">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] backprops(type: DtInvalid).
      ///</return>
      public Operation SeluGrad (  Output gradients , Output outputs ,String opName= "SeluGrad" ) 
      {
         OperationDescription desc = NewOperation("SeluGrad", opName);
         desc.AddInput(gradients);
         desc.AddInput(outputs);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="table_handle">Input to the operation. </param>
      ///<param name="keys">Input to the operation. </param>
      ///<param name="default_value">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] values(type: DtInvalid).
      ///</return>
      public Operation LookupTableFindV2 (  Output table_handle , Output keys , Output default_value ,String opName= "LookupTableFindV2" ) 
      {
         OperationDescription desc = NewOperation("LookupTableFindV2", opName);
         desc.AddInput(table_handle);
         desc.AddInput(keys);
         desc.AddInput(default_value);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="resource">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] value(type: DtInvalid).
      ///</return>
      public Operation ReadVariableOp (  Output resource , DataType dtype,String opName= "ReadVariableOp" ) 
      {
         OperationDescription desc = NewOperation("ReadVariableOp", opName);
         desc.AddInput(resource);
         desc.SetAttr("dtype", dtype);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="tensor">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="element_shape">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_handle(type: DtVariant).
      ///</return>
      public Operation TensorListScatter (  Output tensor , Output indices , Output element_shape ,String opName= "TensorListScatter" ) 
      {
         OperationDescription desc = NewOperation("TensorListScatter", opName);
         desc.AddInput(tensor);
         desc.AddInput(indices);
         desc.AddInput(element_shape);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="gradient_accumulator">Input to the operation. </param>
      ///<param name="gradient_squared_accumulator">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="l1">Input to the operation. </param>
      ///<param name="l2">Input to the operation. </param>
      ///<param name="global_step">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceApplyAdagradDA (  Output var , Output gradient_accumulator , Output gradient_squared_accumulator , Output grad , Output lr , Output l1 , Output l2 , Output global_step , bool use_locking = false ,String opName= "ResourceApplyAdagradDA" ) 
      {
         OperationDescription desc = NewOperation("ResourceApplyAdagradDA", opName);
         desc.AddInput(var);
         desc.AddInput(gradient_accumulator);
         desc.AddInput(gradient_squared_accumulator);
         desc.AddInput(grad);
         desc.AddInput(lr);
         desc.AddInput(l1);
         desc.AddInput(l2);
         desc.AddInput(global_step);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="inputs">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///[1] value_index(type: DtInt32).
      ///</return>
      public Operation RefMerge (  Output inputs ,String opName= "RefMerge" ) 
      {
         OperationDescription desc = NewOperation("RefMerge", opName);
         desc.AddInput(inputs);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="element_shape_except0"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] value(type: DtInvalid).
      ///[1] lengths(type: DtInt64).
      ///</return>
      public Operation TensorArrayConcatV3 (  Output handle , Output flow_in , DataType dtype, long[] element_shape_except0 = null ,String opName= "TensorArrayConcatV3" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayConcatV3", opName);
         desc.AddInput(handle);
         desc.AddInput(flow_in);
         desc.SetAttr("dtype", dtype);
         if (element_shape_except0 != null) desc.SetAttrShape("element_shape_except0", element_shape_except0);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="pred">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_false(type: DtInvalid).
      ///[1] output_true(type: DtInvalid).
      ///</return>
      public Operation RefSwitch (  Output data , Output pred ,String opName= "RefSwitch" ) 
      {
         OperationDescription desc = NewOperation("RefSwitch", opName);
         desc.AddInput(data);
         desc.AddInput(pred);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="full_matrices"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] q(type: DtInvalid).
      ///[1] r(type: DtInvalid).
      ///</return>
      public Operation Qr (  Output input , bool full_matrices = false ,String opName= "Qr" ) 
      {
         OperationDescription desc = NewOperation("Qr", opName);
         desc.AddInput(input);

         if (full_matrices != false) desc.SetAttr("full_matrices", full_matrices);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="n">Input to the operation. </param>
      ///<param name="reverse"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] values(type: DtInvalid).
      ///</return>
      public Operation NthElement (  Output input , Output n , bool reverse = false ,String opName= "NthElement" ) 
      {
         OperationDescription desc = NewOperation("NthElement", opName);
         desc.AddInput(input);
         desc.AddInput(n);

         if (reverse != false) desc.SetAttr("reverse", reverse);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="record_bytes"></param>
      ///<param name="header_bytes"></param>
      ///<param name="footer_bytes"></param>
      ///<param name="hop_bytes"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="encoding"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] reader_handle(type: DtResource).
      ///</return>
      public Operation FixedLengthRecordReaderV2 (  long record_bytes, long header_bytes = 0 , long footer_bytes = 0 , long hop_bytes = 0 , string container = null , string shared_name = null , string encoding = null ,String opName= "FixedLengthRecordReaderV2" ) 
      {
         OperationDescription desc = NewOperation("FixedLengthRecordReaderV2", opName);

         desc.SetAttr("record_bytes", record_bytes);
         if (header_bytes != 0) desc.SetAttr("header_bytes", header_bytes);
         if (footer_bytes != 0) desc.SetAttr("footer_bytes", footer_bytes);
         if (hop_bytes != 0) desc.SetAttr("hop_bytes", hop_bytes);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         if (encoding != null) desc.SetAttr("encoding", encoding);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="orig_input">Input to the operation. </param>
      ///<param name="orig_output">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="ksize"></param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="data_format"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation MaxPoolGradGrad (  Output orig_input , Output orig_output , Output grad , long[] ksize, long[] strides, string padding, string data_format = null ,String opName= "MaxPoolGradGrad" ) 
      {
         OperationDescription desc = NewOperation("MaxPoolGradGrad", opName);
         desc.AddInput(orig_input);
         desc.AddInput(orig_output);
         desc.AddInput(grad);
         desc.SetAttr("ksize", ksize);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="inputs">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///[1] value_index(type: DtInt32).
      ///</return>
      public Operation Merge (  Output inputs ,String opName= "Merge" ) 
      {
         OperationDescription desc = NewOperation("Merge", opName);
         desc.AddInput(inputs);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="value">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] flow_out(type: DtFloat).
      ///</return>
      public Operation TensorArrayUnpack (  Output handle , Output value , Output flow_in ,String opName= "TensorArrayUnpack" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayUnpack", opName);
         desc.AddInput(handle);
         desc.AddInput(value);
         desc.AddInput(flow_in);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="other_arguments">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      //The following attributes are not known: f: func
      public Operation MapDataset (  Output input_dataset , Output other_arguments , DataType[] output_types, long[][] output_shapes,String opName= "MapDataset" ) 
      {
         OperationDescription desc = NewOperation("MapDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(other_arguments);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="tensor">Input to the operation. </param>
      ///<param name="element_shape">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_handle(type: DtVariant).
      ///</return>
      public Operation TensorListFromTensor (  Output tensor , Output element_shape ,String opName= "TensorListFromTensor" ) 
      {
         OperationDescription desc = NewOperation("TensorListFromTensor", opName);
         desc.AddInput(tensor);
         desc.AddInput(element_shape);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Sin (  Output x ,String opName= "Sin" ) 
      {
         OperationDescription desc = NewOperation("Sin", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="frame_name"></param>
      ///<param name="is_constant"></param>
      ///<param name="parallel_iterations"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Enter (  Output data , string frame_name, bool is_constant = false , long parallel_iterations = 10 ,String opName= "Enter" ) 
      {
         OperationDescription desc = NewOperation("Enter", opName);
         desc.AddInput(data);
         desc.SetAttr("frame_name", frame_name);
         if (is_constant != false) desc.SetAttr("is_constant", is_constant);
         if (parallel_iterations != 10) desc.SetAttr("parallel_iterations", parallel_iterations);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation StackClose (  Output handle ,String opName= "StackClose" ) 
      {
         OperationDescription desc = NewOperation("StackClose", opName);
         desc.AddInput(handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Exit (  Output data ,String opName= "Exit" ) 
      {
         OperationDescription desc = NewOperation("Exit", opName);
         desc.AddInput(data);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reference">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="updates">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_ref(type: DtInvalid).
      ///</return>
      public Operation ScatterNdUpdate (  Output reference , Output indices , Output updates , bool use_locking = true ,String opName= "ScatterNdUpdate" ) 
      {
         OperationDescription desc = NewOperation("ScatterNdUpdate", opName);
         desc.AddInput(reference);
         desc.AddInput(indices);
         desc.AddInput(updates);

         if (use_locking != true) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="component_types"></param>
      ///<param name="shapes"></param>
      ///<param name="capacity"></param>
      ///<param name="min_after_dequeue"></param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtString).
      ///</return>
      public Operation RandomShuffleQueue (  DataType[] component_types, long[][] shapes = null , long capacity = -1 , long min_after_dequeue = 0 , long seed = 0 , long seed2 = 0 , string container = null , string shared_name = null ,String opName= "RandomShuffleQueue" ) 
      {
         OperationDescription desc = NewOperation("RandomShuffleQueue", opName);

         desc.SetAttr("component_types", component_types);
         if (shapes != null) desc.SetAttrShapeList("shapes", shapes);
         if (capacity != -1) desc.SetAttr("capacity", capacity);
         if (min_after_dequeue != 0) desc.SetAttr("min_after_dequeue", min_after_dequeue);
         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation RefExit (  Output data ,String opName= "RefExit" ) 
      {
         OperationDescription desc = NewOperation("RefExit", opName);
         desc.AddInput(data);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtBool).
      ///</return>
      public Operation LoopCond (  Output input ,String opName= "LoopCond" ) 
      {
         OperationDescription desc = NewOperation("LoopCond", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="inputs">Input to the operation. </param>
      ///<param name="sequence_length">Input to the operation. </param>
      ///<param name="merge_repeated"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] decoded_indices(type: DtInt64).
      ///[1] decoded_values(type: DtInt64).
      ///[2] decoded_shape(type: DtInt64).
      ///[3] log_probability(type: DtFloat).
      ///</return>
      public Operation CTCGreedyDecoder (  Output inputs , Output sequence_length , bool merge_repeated = false ,String opName= "CTCGreedyDecoder" ) 
      {
         OperationDescription desc = NewOperation("CTCGreedyDecoder", opName);
         desc.AddInput(inputs);
         desc.AddInput(sequence_length);

         if (merge_repeated != false) desc.SetAttr("merge_repeated", merge_repeated);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] reader_handle(type: DtResource).
      ///</return>
      public Operation WholeFileReaderV2 (  string container = null , string shared_name = null ,String opName= "WholeFileReaderV2" ) 
      {
         OperationDescription desc = NewOperation("WholeFileReaderV2", opName);


         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="records">Input to the operation. </param>
      ///<param name="record_defaults">Input to the operation. </param>
      ///<param name="field_delim"></param>
      ///<param name="use_quote_delim"></param>
      ///<param name="na_value"></param>
      ///<param name="select_cols"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation DecodeCSV (  Output records , Output record_defaults , string field_delim = null , bool use_quote_delim = true , string na_value = null , long[] select_cols = null ,String opName= "DecodeCSV" ) 
      {
         OperationDescription desc = NewOperation("DecodeCSV", opName);
         desc.AddInput(records);
         desc.AddInput(record_defaults);

         if (field_delim != null) desc.SetAttr("field_delim", field_delim);
         if (use_quote_delim != true) desc.SetAttr("use_quote_delim", use_quote_delim);
         if (na_value != null) desc.SetAttr("na_value", na_value);
         if (select_cols != null) desc.SetAttr("select_cols", select_cols);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="error_msg"></param>
      ///<param name="exit_without_error"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation Abort (  string error_msg = null , bool exit_without_error = false ,String opName= "Abort" ) 
      {
         OperationDescription desc = NewOperation("Abort", opName);


         if (error_msg != null) desc.SetAttr("error_msg", error_msg);
         if (exit_without_error != false) desc.SetAttr("exit_without_error", exit_without_error);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="input_h">Input to the operation. </param>
      ///<param name="input_c">Input to the operation. </param>
      ///<param name="parameters">Input to the operation. </param>
      ///<param name="rnn_mode"></param>
      ///<param name="input_mode"></param>
      ///<param name="direction"></param>
      ///<param name="dropout"></param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="is_training"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///[1] output_h(type: DtInvalid).
      ///[2] output_c(type: DtInvalid).
      ///[3] reserve_space(type: DtInvalid).
      ///</return>
      public Operation CudnnRNN (  Output input , Output input_h , Output input_c , Output parameters , string rnn_mode = null , string input_mode = null , string direction = null , float dropout = 0f , long seed = 0 , long seed2 = 0 , bool is_training = true ,String opName= "CudnnRNN" ) 
      {
         OperationDescription desc = NewOperation("CudnnRNN", opName);
         desc.AddInput(input);
         desc.AddInput(input_h);
         desc.AddInput(input_c);
         desc.AddInput(parameters);

         if (rnn_mode != null) desc.SetAttr("rnn_mode", rnn_mode);
         if (input_mode != null) desc.SetAttr("input_mode", input_mode);
         if (direction != null) desc.SetAttr("direction", direction);
         if (dropout != 0f) desc.SetAttr("dropout", dropout);
         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         if (is_training != true) desc.SetAttr("is_training", is_training);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="adj_x"></param>
      ///<param name="adj_y"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation BatchMatMul (  Output x , Output y , bool adj_x = false , bool adj_y = false ,String opName= "BatchMatMul" ) 
      {
         OperationDescription desc = NewOperation("BatchMatMul", opName);
         desc.AddInput(x);
         desc.AddInput(y);

         if (adj_x != false) desc.SetAttr("adj_x", adj_x);
         if (adj_y != false) desc.SetAttr("adj_y", adj_y);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="input_h">Input to the operation. </param>
      ///<param name="input_c">Input to the operation. </param>
      ///<param name="parameters">Input to the operation. </param>
      ///<param name="rnn_mode"></param>
      ///<param name="input_mode"></param>
      ///<param name="direction"></param>
      ///<param name="dropout"></param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="is_training"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///[1] output_h(type: DtInvalid).
      ///[2] output_c(type: DtInvalid).
      ///[3] reserve_space(type: DtInvalid).
      ///[4] host_reserved(type: DtInt8).
      ///</return>
      public Operation CudnnRNNV2 (  Output input , Output input_h , Output input_c , Output parameters , string rnn_mode = null , string input_mode = null , string direction = null , float dropout = 0f , long seed = 0 , long seed2 = 0 , bool is_training = true ,String opName= "CudnnRNNV2" ) 
      {
         OperationDescription desc = NewOperation("CudnnRNNV2", opName);
         desc.AddInput(input);
         desc.AddInput(input_h);
         desc.AddInput(input_c);
         desc.AddInput(parameters);

         if (rnn_mode != null) desc.SetAttr("rnn_mode", rnn_mode);
         if (input_mode != null) desc.SetAttr("input_mode", input_mode);
         if (direction != null) desc.SetAttr("direction", direction);
         if (dropout != 0f) desc.SetAttr("dropout", dropout);
         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         if (is_training != true) desc.SetAttr("is_training", is_training);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="input_h">Input to the operation. </param>
      ///<param name="input_c">Input to the operation. </param>
      ///<param name="parameters">Input to the operation. </param>
      ///<param name="output">Input to the operation. </param>
      ///<param name="output_h">Input to the operation. </param>
      ///<param name="output_c">Input to the operation. </param>
      ///<param name="output_backprop">Input to the operation. </param>
      ///<param name="output_h_backprop">Input to the operation. </param>
      ///<param name="output_c_backprop">Input to the operation. </param>
      ///<param name="reserve_space">Input to the operation. </param>
      ///<param name="rnn_mode"></param>
      ///<param name="input_mode"></param>
      ///<param name="direction"></param>
      ///<param name="dropout"></param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] input_backprop(type: DtInvalid).
      ///[1] input_h_backprop(type: DtInvalid).
      ///[2] input_c_backprop(type: DtInvalid).
      ///[3] params_backprop(type: DtInvalid).
      ///</return>
      public Operation CudnnRNNBackprop (  Output input , Output input_h , Output input_c , Output parameters , Output output , Output output_h , Output output_c , Output output_backprop , Output output_h_backprop , Output output_c_backprop , Output reserve_space , string rnn_mode = null , string input_mode = null , string direction = null , float dropout = 0f , long seed = 0 , long seed2 = 0 ,String opName= "CudnnRNNBackprop" ) 
      {
         OperationDescription desc = NewOperation("CudnnRNNBackprop", opName);
         desc.AddInput(input);
         desc.AddInput(input_h);
         desc.AddInput(input_c);
         desc.AddInput(parameters);
         desc.AddInput(output);
         desc.AddInput(output_h);
         desc.AddInput(output_c);
         desc.AddInput(output_backprop);
         desc.AddInput(output_h_backprop);
         desc.AddInput(output_c_backprop);
         desc.AddInput(reserve_space);

         if (rnn_mode != null) desc.SetAttr("rnn_mode", rnn_mode);
         if (input_mode != null) desc.SetAttr("input_mode", input_mode);
         if (direction != null) desc.SetAttr("direction", direction);
         if (dropout != 0f) desc.SetAttr("dropout", dropout);
         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="num_layers">Input to the operation. </param>
      ///<param name="num_units">Input to the operation. </param>
      ///<param name="input_size">Input to the operation. </param>
      ///<param name="weights">Input to the operation. </param>
      ///<param name="biases">Input to the operation. </param>
      ///<param name="rnn_mode"></param>
      ///<param name="input_mode"></param>
      ///<param name="direction"></param>
      ///<param name="dropout"></param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] params(type: DtInvalid).
      ///</return>
      public Operation CudnnRNNCanonicalToParams (  Output num_layers , Output num_units , Output input_size , Output weights , Output biases , string rnn_mode = null , string input_mode = null , string direction = null , float dropout = 0f , long seed = 0 , long seed2 = 0 ,String opName= "CudnnRNNCanonicalToParams" ) 
      {
         OperationDescription desc = NewOperation("CudnnRNNCanonicalToParams", opName);
         desc.AddInput(num_layers);
         desc.AddInput(num_units);
         desc.AddInput(input_size);
         desc.AddInput(weights);
         desc.AddInput(biases);

         if (rnn_mode != null) desc.SetAttr("rnn_mode", rnn_mode);
         if (input_mode != null) desc.SetAttr("input_mode", input_mode);
         if (direction != null) desc.SetAttr("direction", direction);
         if (dropout != 0f) desc.SetAttr("dropout", dropout);
         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="partitions">Input to the operation. </param>
      ///<param name="num_partitions"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] outputs(type: DtInvalid).
      ///</return>
      public Operation DynamicPartition (  Output data , Output partitions , long num_partitions,String opName= "DynamicPartition" ) 
      {
         OperationDescription desc = NewOperation("DynamicPartition", opName);
         desc.AddInput(data);
         desc.AddInput(partitions);
         desc.SetAttr("num_partitions", num_partitions);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="features">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] activations(type: DtInvalid).
      ///</return>
      public Operation Relu6 (  Output features ,String opName= "Relu6" ) 
      {
         OperationDescription desc = NewOperation("Relu6", opName);
         desc.AddInput(features);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="skip_header_lines"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] reader_handle(type: DtString).
      ///</return>
      public Operation TextLineReader (  long skip_header_lines = 0 , string container = null , string shared_name = null ,String opName= "TextLineReader" ) 
      {
         OperationDescription desc = NewOperation("TextLineReader", opName);


         if (skip_header_lines != 0) desc.SetAttr("skip_header_lines", skip_header_lines);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="boundaries"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInt32).
      ///</return>
      public Operation Bucketize (  Output input , float[] boundaries,String opName= "Bucketize" ) 
      {
         OperationDescription desc = NewOperation("Bucketize", opName);
         desc.AddInput(input);
         desc.SetAttr("boundaries", boundaries);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="data">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] merged(type: DtInvalid).
      ///</return>
      public Operation DynamicStitch (  Output indices , Output data ,String opName= "DynamicStitch" ) 
      {
         OperationDescription desc = NewOperation("DynamicStitch", opName);
         desc.AddInput(indices);
         desc.AddInput(data);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="linear">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="l1">Input to the operation. </param>
      ///<param name="l2">Input to the operation. </param>
      ///<param name="lr_power">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation ApplyFtrl (  Output var , Output accum , Output linear , Output grad , Output lr , Output l1 , Output l2 , Output lr_power , bool use_locking = false ,String opName= "ApplyFtrl" ) 
      {
         OperationDescription desc = NewOperation("ApplyFtrl", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(linear);
         desc.AddInput(grad);
         desc.AddInput(lr);
         desc.AddInput(l1);
         desc.AddInput(l2);
         desc.AddInput(lr_power);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="component_types"></param>
      ///<param name="shapes"></param>
      ///<param name="capacity"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtString).
      ///</return>
      public Operation PaddingFIFOQueue (  DataType[] component_types, long[][] shapes = null , long capacity = -1 , string container = null , string shared_name = null ,String opName= "PaddingFIFOQueue" ) 
      {
         OperationDescription desc = NewOperation("PaddingFIFOQueue", opName);

         desc.SetAttr("component_types", component_types);
         if (shapes != null) desc.SetAttrShapeList("shapes", shapes);
         if (capacity != -1) desc.SetAttr("capacity", capacity);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="linear">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="l1">Input to the operation. </param>
      ///<param name="l2">Input to the operation. </param>
      ///<param name="l2_shrinkage">Input to the operation. </param>
      ///<param name="lr_power">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation ApplyFtrlV2 (  Output var , Output accum , Output linear , Output grad , Output lr , Output l1 , Output l2 , Output l2_shrinkage , Output lr_power , bool use_locking = false ,String opName= "ApplyFtrlV2" ) 
      {
         OperationDescription desc = NewOperation("ApplyFtrlV2", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(linear);
         desc.AddInput(grad);
         desc.AddInput(lr);
         desc.AddInput(l1);
         desc.AddInput(l2);
         desc.AddInput(l2_shrinkage);
         desc.AddInput(lr_power);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="resource">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] is_initialized(type: DtBool).
      ///</return>
      public Operation VarIsInitializedOp (  Output resource ,String opName= "VarIsInitializedOp" ) 
      {
         OperationDescription desc = NewOperation("VarIsInitializedOp", opName);
         desc.AddInput(resource);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="component_types"></param>
      ///<param name="shapes"></param>
      ///<param name="capacity"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtResource).
      ///</return>
      public Operation PaddingFIFOQueueV2 (  DataType[] component_types, long[][] shapes = null , long capacity = -1 , string container = null , string shared_name = null ,String opName= "PaddingFIFOQueueV2" ) 
      {
         OperationDescription desc = NewOperation("PaddingFIFOQueueV2", opName);

         desc.SetAttr("component_types", component_types);
         if (shapes != null) desc.SetAttrShapeList("shapes", shapes);
         if (capacity != -1) desc.SetAttr("capacity", capacity);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation MatrixExponential (  Output input ,String opName= "MatrixExponential" ) 
      {
         OperationDescription desc = NewOperation("MatrixExponential", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="shapes"></param>
      ///<param name="component_types"></param>
      ///<param name="capacity"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtString).
      ///</return>
      public Operation PriorityQueue (  long[][] shapes, DataType[] component_types = null , long capacity = -1 , string container = null , string shared_name = null ,String opName= "PriorityQueue" ) 
      {
         OperationDescription desc = NewOperation("PriorityQueue", opName);

         desc.SetAttrShapeList("shapes", shapes);
         if (component_types != null) desc.SetAttr("component_types", component_types);
         if (capacity != -1) desc.SetAttr("capacity", capacity);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="shapes"></param>
      ///<param name="component_types"></param>
      ///<param name="capacity"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtResource).
      ///</return>
      public Operation PriorityQueueV2 (  long[][] shapes, DataType[] component_types = null , long capacity = -1 , string container = null , string shared_name = null ,String opName= "PriorityQueueV2" ) 
      {
         OperationDescription desc = NewOperation("PriorityQueueV2", opName);

         desc.SetAttrShapeList("shapes", shapes);
         if (component_types != null) desc.SetAttr("component_types", component_types);
         if (capacity != -1) desc.SetAttr("capacity", capacity);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="other_arguments">Input to the operation. </param>
      ///<param name="cycle_length">Input to the operation. </param>
      ///<param name="block_length">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      //The following attributes are not known: f: func
      public Operation InterleaveDataset (  Output input_dataset , Output other_arguments , Output cycle_length , Output block_length , DataType[] output_types, long[][] output_shapes,String opName= "InterleaveDataset" ) 
      {
         OperationDescription desc = NewOperation("InterleaveDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(other_arguments);
         desc.AddInput(cycle_length);
         desc.AddInput(block_length);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="paddings">Input to the operation. </param>
      ///<param name="block_size"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SpaceToBatch (  Output input , Output paddings , long block_size,String opName= "SpaceToBatch" ) 
      {
         OperationDescription desc = NewOperation("SpaceToBatch", opName);
         desc.AddInput(input);
         desc.AddInput(paddings);
         desc.SetAttr("block_size", block_size);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="Tout"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Imag (  Output input , DataType? Tout = null ,String opName= "Imag" ) 
      {
         OperationDescription desc = NewOperation("Imag", opName);
         desc.AddInput(input);

         if (Tout.HasValue) desc.SetAttr("Tout", Tout.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Round (  Output x ,String opName= "Round" ) 
      {
         OperationDescription desc = NewOperation("Round", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="resource">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtString).
      ///</return>
      public Operation FakeQueue (  Output resource ,String opName= "FakeQueue" ) 
      {
         OperationDescription desc = NewOperation("FakeQueue", opName);
         desc.AddInput(resource);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="max_size">Input to the operation. </param>
      ///<param name="elem_type"></param>
      ///<param name="stack_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtResource).
      ///</return>
      public Operation StackV2 (  Output max_size , DataType elem_type, string stack_name = null ,String opName= "StackV2" ) 
      {
         OperationDescription desc = NewOperation("StackV2", opName);
         desc.AddInput(max_size);
         desc.SetAttr("elem_type", elem_type);
         if (stack_name != null) desc.SetAttr("stack_name", stack_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="components">Input to the operation. </param>
      ///<param name="timeout_ms"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation QueueEnqueue (  Output handle , Output components , long timeout_ms = -1 ,String opName= "QueueEnqueue" ) 
      {
         OperationDescription desc = NewOperation("QueueEnqueue", opName);
         desc.AddInput(handle);
         desc.AddInput(components);

         if (timeout_ms != -1) desc.SetAttr("timeout_ms", timeout_ms);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="components">Input to the operation. </param>
      ///<param name="timeout_ms"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation QueueEnqueueV2 (  Output handle , Output components , long timeout_ms = -1 ,String opName= "QueueEnqueueV2" ) 
      {
         OperationDescription desc = NewOperation("QueueEnqueueV2", opName);
         desc.AddInput(handle);
         desc.AddInput(components);

         if (timeout_ms != -1) desc.SetAttr("timeout_ms", timeout_ms);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="components">Input to the operation. </param>
      ///<param name="timeout_ms"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation QueueEnqueueMany (  Output handle , Output components , long timeout_ms = -1 ,String opName= "QueueEnqueueMany" ) 
      {
         OperationDescription desc = NewOperation("QueueEnqueueMany", opName);
         desc.AddInput(handle);
         desc.AddInput(components);

         if (timeout_ms != -1) desc.SetAttr("timeout_ms", timeout_ms);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reader_handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation ReaderResetV2 (  Output reader_handle ,String opName= "ReaderResetV2" ) 
      {
         OperationDescription desc = NewOperation("ReaderResetV2", opName);
         desc.AddInput(reader_handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="components">Input to the operation. </param>
      ///<param name="timeout_ms"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation QueueEnqueueManyV2 (  Output handle , Output components , long timeout_ms = -1 ,String opName= "QueueEnqueueManyV2" ) 
      {
         OperationDescription desc = NewOperation("QueueEnqueueManyV2", opName);
         desc.AddInput(handle);
         desc.AddInput(components);

         if (timeout_ms != -1) desc.SetAttr("timeout_ms", timeout_ms);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="segment_ids">Input to the operation. </param>
      ///<param name="num_segments">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation UnsortedSegmentMax (  Output data , Output segment_ids , Output num_segments ,String opName= "UnsortedSegmentMax" ) 
      {
         OperationDescription desc = NewOperation("UnsortedSegmentMax", opName);
         desc.AddInput(data);
         desc.AddInput(segment_ids);
         desc.AddInput(num_segments);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="component_types"></param>
      ///<param name="timeout_ms"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] components(type: DtInvalid).
      ///</return>
      public Operation QueueDequeue (  Output handle , DataType[] component_types, long timeout_ms = -1 ,String opName= "QueueDequeue" ) 
      {
         OperationDescription desc = NewOperation("QueueDequeue", opName);
         desc.AddInput(handle);
         desc.SetAttr("component_types", component_types);
         if (timeout_ms != -1) desc.SetAttr("timeout_ms", timeout_ms);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="seed">Input to the operation. </param>
      ///<param name="seed2">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation RandomDataset (  Output seed , Output seed2 , DataType[] output_types, long[][] output_shapes,String opName= "RandomDataset" ) 
      {
         OperationDescription desc = NewOperation("RandomDataset", opName);
         desc.AddInput(seed);
         desc.AddInput(seed2);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="component_types"></param>
      ///<param name="timeout_ms"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] components(type: DtInvalid).
      ///</return>
      public Operation QueueDequeueV2 (  Output handle , DataType[] component_types, long timeout_ms = -1 ,String opName= "QueueDequeueV2" ) 
      {
         OperationDescription desc = NewOperation("QueueDequeueV2", opName);
         desc.AddInput(handle);
         desc.SetAttr("component_types", component_types);
         if (timeout_ms != -1) desc.SetAttr("timeout_ms", timeout_ms);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="segment_ids">Input to the operation. </param>
      ///<param name="num_segments">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SparseSegmentSumWithNumSegments (  Output data , Output indices , Output segment_ids , Output num_segments ,String opName= "SparseSegmentSumWithNumSegments" ) 
      {
         OperationDescription desc = NewOperation("SparseSegmentSumWithNumSegments", opName);
         desc.AddInput(data);
         desc.AddInput(indices);
         desc.AddInput(segment_ids);
         desc.AddInput(num_segments);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation TruncateMod (  Output x , Output y ,String opName= "TruncateMod" ) 
      {
         OperationDescription desc = NewOperation("TruncateMod", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="batch_size">Input to the operation. </param>
      ///<param name="row_shape">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation DenseToSparseBatchDataset (  Output input_dataset , Output batch_size , Output row_shape , DataType[] output_types, long[][] output_shapes,String opName= "DenseToSparseBatchDataset" ) 
      {
         OperationDescription desc = NewOperation("DenseToSparseBatchDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(batch_size);
         desc.AddInput(row_shape);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="n">Input to the operation. </param>
      ///<param name="component_types"></param>
      ///<param name="timeout_ms"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] components(type: DtInvalid).
      ///</return>
      public Operation QueueDequeueMany (  Output handle , Output n , DataType[] component_types, long timeout_ms = -1 ,String opName= "QueueDequeueMany" ) 
      {
         OperationDescription desc = NewOperation("QueueDequeueMany", opName);
         desc.AddInput(handle);
         desc.AddInput(n);
         desc.SetAttr("component_types", component_types);
         if (timeout_ms != -1) desc.SetAttr("timeout_ms", timeout_ms);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="n">Input to the operation. </param>
      ///<param name="component_types"></param>
      ///<param name="timeout_ms"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] components(type: DtInvalid).
      ///</return>
      public Operation QueueDequeueManyV2 (  Output handle , Output n , DataType[] component_types, long timeout_ms = -1 ,String opName= "QueueDequeueManyV2" ) 
      {
         OperationDescription desc = NewOperation("QueueDequeueManyV2", opName);
         desc.AddInput(handle);
         desc.AddInput(n);
         desc.SetAttr("component_types", component_types);
         if (timeout_ms != -1) desc.SetAttr("timeout_ms", timeout_ms);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="updates">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation ScatterNdNonAliasingAdd (  Output input , Output indices , Output updates ,String opName= "ScatterNdNonAliasingAdd" ) 
      {
         OperationDescription desc = NewOperation("ScatterNdNonAliasingAdd", opName);
         desc.AddInput(input);
         desc.AddInput(indices);
         desc.AddInput(updates);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="n">Input to the operation. </param>
      ///<param name="component_types"></param>
      ///<param name="timeout_ms"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] components(type: DtInvalid).
      ///</return>
      public Operation QueueDequeueUpToV2 (  Output handle , Output n , DataType[] component_types, long timeout_ms = -1 ,String opName= "QueueDequeueUpToV2" ) 
      {
         OperationDescription desc = NewOperation("QueueDequeueUpToV2", opName);
         desc.AddInput(handle);
         desc.AddInput(n);
         desc.SetAttr("component_types", component_types);
         if (timeout_ms != -1) desc.SetAttr("timeout_ms", timeout_ms);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="cancel_pending_enqueues"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation QueueClose (  Output handle , bool cancel_pending_enqueues = false ,String opName= "QueueClose" ) 
      {
         OperationDescription desc = NewOperation("QueueClose", opName);
         desc.AddInput(handle);

         if (cancel_pending_enqueues != false) desc.SetAttr("cancel_pending_enqueues", cancel_pending_enqueues);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="other_arguments">Input to the operation. </param>
      ///<param name="num_parallel_calls">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      //The following attributes are not known: f: func
      public Operation ParallelMapDataset (  Output input_dataset , Output other_arguments , Output num_parallel_calls , DataType[] output_types, long[][] output_shapes,String opName= "ParallelMapDataset" ) 
      {
         OperationDescription desc = NewOperation("ParallelMapDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(other_arguments);
         desc.AddInput(num_parallel_calls);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_handle">Input to the operation. </param>
      ///<param name="element_dtype"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_handle(type: DtVariant).
      ///[1] tensor(type: DtInvalid).
      ///</return>
      public Operation TensorListPopBack (  Output input_handle , DataType element_dtype,String opName= "TensorListPopBack" ) 
      {
         OperationDescription desc = NewOperation("TensorListPopBack", opName);
         desc.AddInput(input_handle);
         desc.SetAttr("element_dtype", element_dtype);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="cancel_pending_enqueues"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation QueueCloseV2 (  Output handle , bool cancel_pending_enqueues = false ,String opName= "QueueCloseV2" ) 
      {
         OperationDescription desc = NewOperation("QueueCloseV2", opName);
         desc.AddInput(handle);

         if (cancel_pending_enqueues != false) desc.SetAttr("cancel_pending_enqueues", cancel_pending_enqueues);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="images">Input to the operation. </param>
      ///<param name="contrast_factor">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtFloat).
      ///</return>
      public Operation AdjustContrastv2 (  Output images , Output contrast_factor ,String opName= "AdjustContrastv2" ) 
      {
         OperationDescription desc = NewOperation("AdjustContrastv2", opName);
         desc.AddInput(images);
         desc.AddInput(contrast_factor);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] is_closed(type: DtBool).
      ///</return>
      public Operation QueueIsClosed (  Output handle ,String opName= "QueueIsClosed" ) 
      {
         OperationDescription desc = NewOperation("QueueIsClosed", opName);
         desc.AddInput(handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reference">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="updates">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_ref(type: DtInvalid).
      ///</return>
      public Operation ScatterUpdate (  Output reference , Output indices , Output updates , bool use_locking = true ,String opName= "ScatterUpdate" ) 
      {
         OperationDescription desc = NewOperation("ScatterUpdate", opName);
         desc.AddInput(reference);
         desc.AddInput(indices);
         desc.AddInput(updates);

         if (use_locking != true) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="shape"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation EnsureShape (  Output input , long[] shape,String opName= "EnsureShape" ) 
      {
         OperationDescription desc = NewOperation("EnsureShape", opName);
         desc.AddInput(input);
         desc.SetAttrShape("shape", shape);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] is_closed(type: DtBool).
      ///</return>
      public Operation QueueIsClosedV2 (  Output handle ,String opName= "QueueIsClosedV2" ) 
      {
         OperationDescription desc = NewOperation("QueueIsClosedV2", opName);
         desc.AddInput(handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] size(type: DtInt32).
      ///</return>
      public Operation QueueSize (  Output handle ,String opName= "QueueSize" ) 
      {
         OperationDescription desc = NewOperation("QueueSize", opName);
         desc.AddInput(handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] size(type: DtInt32).
      ///</return>
      public Operation QueueSizeV2 (  Output handle ,String opName= "QueueSizeV2" ) 
      {
         OperationDescription desc = NewOperation("QueueSizeV2", opName);
         desc.AddInput(handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="segment_ids">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SegmentProd (  Output data , Output segment_ids ,String opName= "SegmentProd" ) 
      {
         OperationDescription desc = NewOperation("SegmentProd", opName);
         desc.AddInput(data);
         desc.AddInput(segment_ids);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] num_accumulated(type: DtInt32).
      ///</return>
      public Operation AccumulatorNumAccumulated (  Output handle ,String opName= "AccumulatorNumAccumulated" ) 
      {
         OperationDescription desc = NewOperation("AccumulatorNumAccumulated", opName);
         desc.AddInput(handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="filename">Input to the operation. </param>
      ///<param name="tensor_names">Input to the operation. </param>
      ///<param name="shapes_and_slices">Input to the operation. </param>
      ///<param name="data">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation SaveSlices (  Output filename , Output tensor_names , Output shapes_and_slices , Output data ,String opName= "SaveSlices" ) 
      {
         OperationDescription desc = NewOperation("SaveSlices", opName);
         desc.AddInput(filename);
         desc.AddInput(tensor_names);
         desc.AddInput(shapes_and_slices);
         desc.AddInput(data);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="new_global_step">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation AccumulatorSetGlobalStep (  Output handle , Output new_global_step ,String opName= "AccumulatorSetGlobalStep" ) 
      {
         OperationDescription desc = NewOperation("AccumulatorSetGlobalStep", opName);
         desc.AddInput(handle);
         desc.AddInput(new_global_step);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="checkpoint_prefixes">Input to the operation. </param>
      ///<param name="destination_prefix">Input to the operation. </param>
      ///<param name="delete_old_dirs"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation MergeV2Checkpoints (  Output checkpoint_prefixes , Output destination_prefix , bool delete_old_dirs = true ,String opName= "MergeV2Checkpoints" ) 
      {
         OperationDescription desc = NewOperation("MergeV2Checkpoints", opName);
         desc.AddInput(checkpoint_prefixes);
         desc.AddInput(destination_prefix);

         if (delete_old_dirs != true) desc.SetAttr("delete_old_dirs", delete_old_dirs);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="tag">Input to the operation. </param>
      ///<param name="tensor">Input to the operation. </param>
      ///<param name="max_images"></param>
      ///<param name="bad_color"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] summary(type: DtString).
      ///</return>
      public Operation ImageSummary (  Output tag , Output tensor , long max_images = 3 , Tensor bad_color = null ,String opName= "ImageSummary" ) 
      {
         OperationDescription desc = NewOperation("ImageSummary", opName);
         desc.AddInput(tag);
         desc.AddInput(tensor);

         if (max_images != 3) desc.SetAttr("max_images", max_images);
         if (bad_color != null) desc.SetAttr("bad_color", bad_color);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="block_shape">Input to the operation. </param>
      ///<param name="paddings">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SpaceToBatchND (  Output input , Output block_shape , Output paddings ,String opName= "SpaceToBatchND" ) 
      {
         OperationDescription desc = NewOperation("SpaceToBatchND", opName);
         desc.AddInput(input);
         desc.AddInput(block_shape);
         desc.AddInput(paddings);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="cond">Input to the operation. </param>
      ///<param name="input">Input to the operation. </param>
      ///<param name="Tout"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      //The following attributes are not known: then_branch: func; else_branch: func
      public Operation If (  Output cond , Output input , DataType[] Tout,String opName= "If" ) 
      {
         OperationDescription desc = NewOperation("If", opName);
         desc.AddInput(cond);
         desc.AddInput(input);
         desc.SetAttr("Tout", Tout);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="matrix">Input to the operation. </param>
      ///<param name="rhs">Input to the operation. </param>
      ///<param name="l2_regularizer">Input to the operation. </param>
      ///<param name="fast"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation MatrixSolveLs (  Output matrix , Output rhs , Output l2_regularizer , bool fast = true ,String opName= "MatrixSolveLs" ) 
      {
         OperationDescription desc = NewOperation("MatrixSolveLs", opName);
         desc.AddInput(matrix);
         desc.AddInput(rhs);
         desc.AddInput(l2_regularizer);

         if (fast != true) desc.SetAttr("fast", fast);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="dtype"></param>
      ///<param name="shape"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtString).
      ///</return>
      public Operation ConditionalAccumulator (  DataType dtype, long[] shape, string container = null , string shared_name = null ,String opName= "ConditionalAccumulator" ) 
      {
         OperationDescription desc = NewOperation("ConditionalAccumulator", opName);

         desc.SetAttr("dtype", dtype);
         desc.SetAttrShape("shape", shape);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="local_step">Input to the operation. </param>
      ///<param name="gradient">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation AccumulatorApplyGradient (  Output handle , Output local_step , Output gradient ,String opName= "AccumulatorApplyGradient" ) 
      {
         OperationDescription desc = NewOperation("AccumulatorApplyGradient", opName);
         desc.AddInput(handle);
         desc.AddInput(local_step);
         desc.AddInput(gradient);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation FFT (  Output input ,String opName= "FFT" ) 
      {
         OperationDescription desc = NewOperation("FFT", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="m">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="alpha">Input to the operation. </param>
      ///<param name="sign_decay">Input to the operation. </param>
      ///<param name="beta">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation ApplyAddSign (  Output var , Output m , Output lr , Output alpha , Output sign_decay , Output beta , Output grad , bool use_locking = false ,String opName= "ApplyAddSign" ) 
      {
         OperationDescription desc = NewOperation("ApplyAddSign", opName);
         desc.AddInput(var);
         desc.AddInput(m);
         desc.AddInput(lr);
         desc.AddInput(alpha);
         desc.AddInput(sign_decay);
         desc.AddInput(beta);
         desc.AddInput(grad);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="dtype"></param>
      ///<param name="shape"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtString).
      ///</return>
      public Operation SparseConditionalAccumulator (  DataType dtype, long[] shape, string container = null , string shared_name = null ,String opName= "SparseConditionalAccumulator" ) 
      {
         OperationDescription desc = NewOperation("SparseConditionalAccumulator", opName);

         desc.SetAttr("dtype", dtype);
         desc.SetAttrShape("shape", shape);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtBool).
      ///</return>
      public Operation GreaterEqual (  Output x , Output y ,String opName= "GreaterEqual" ) 
      {
         OperationDescription desc = NewOperation("GreaterEqual", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="local_step">Input to the operation. </param>
      ///<param name="gradient_indices">Input to the operation. </param>
      ///<param name="gradient_values">Input to the operation. </param>
      ///<param name="gradient_shape">Input to the operation. </param>
      ///<param name="has_known_shape"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation SparseAccumulatorApplyGradient (  Output handle , Output local_step , Output gradient_indices , Output gradient_values , Output gradient_shape , bool has_known_shape,String opName= "SparseAccumulatorApplyGradient" ) 
      {
         OperationDescription desc = NewOperation("SparseAccumulatorApplyGradient", opName);
         desc.AddInput(handle);
         desc.AddInput(local_step);
         desc.AddInput(gradient_indices);
         desc.AddInput(gradient_values);
         desc.AddInput(gradient_shape);
         desc.SetAttr("has_known_shape", has_known_shape);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reference">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="updates">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceScatterNdAdd (  Output reference , Output indices , Output updates , bool use_locking = true ,String opName= "ResourceScatterNdAdd" ) 
      {
         OperationDescription desc = NewOperation("ResourceScatterNdAdd", opName);
         desc.AddInput(reference);
         desc.AddInput(indices);
         desc.AddInput(updates);

         if (use_locking != true) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="num_required">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] indices(type: DtInt64).
      ///[1] values(type: DtInvalid).
      ///[2] shape(type: DtInt64).
      ///</return>
      public Operation SparseAccumulatorTakeGradient (  Output handle , Output num_required , DataType dtype,String opName= "SparseAccumulatorTakeGradient" ) 
      {
         OperationDescription desc = NewOperation("SparseAccumulatorTakeGradient", opName);
         desc.AddInput(handle);
         desc.AddInput(num_required);
         desc.SetAttr("dtype", dtype);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="gradients">Input to the operation. </param>
      ///<param name="outputs">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] backprops(type: DtInvalid).
      ///</return>
      public Operation EluGrad (  Output gradients , Output outputs ,String opName= "EluGrad" ) 
      {
         OperationDescription desc = NewOperation("EluGrad", opName);
         desc.AddInput(gradients);
         desc.AddInput(outputs);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="elem">Input to the operation. </param>
      ///<param name="swap_memory"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation StackPushV2 (  Output handle , Output elem , bool swap_memory = false ,String opName= "StackPushV2" ) 
      {
         OperationDescription desc = NewOperation("StackPushV2", opName);
         desc.AddInput(handle);
         desc.AddInput(elem);

         if (swap_memory != false) desc.SetAttr("swap_memory", swap_memory);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="elem_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] elem(type: DtInvalid).
      ///</return>
      public Operation StackPopV2 (  Output handle , DataType elem_type,String opName= "StackPopV2" ) 
      {
         OperationDescription desc = NewOperation("StackPopV2", opName);
         desc.AddInput(handle);
         desc.SetAttr("elem_type", elem_type);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="count">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation RepeatDataset (  Output input_dataset , Output count , DataType[] output_types, long[][] output_shapes,String opName= "RepeatDataset" ) 
      {
         OperationDescription desc = NewOperation("RepeatDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(count);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation StackCloseV2 (  Output handle ,String opName= "StackCloseV2" ) 
      {
         OperationDescription desc = NewOperation("StackCloseV2", opName);
         desc.AddInput(handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="elem_type"></param>
      ///<param name="stack_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtString).
      ///</return>
      public Operation Stack (  DataType elem_type, string stack_name = null ,String opName= "Stack" ) 
      {
         OperationDescription desc = NewOperation("Stack", opName);

         desc.SetAttr("elem_type", elem_type);
         if (stack_name != null) desc.SetAttr("stack_name", stack_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="key_func_other_arguments">Input to the operation. </param>
      ///<param name="reduce_func_other_arguments">Input to the operation. </param>
      ///<param name="window_size_func_other_arguments">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      //The following attributes are not known: key_func: func; reduce_func: func; window_size_func: func
      public Operation GroupByWindowDataset (  Output input_dataset , Output key_func_other_arguments , Output reduce_func_other_arguments , Output window_size_func_other_arguments , DataType[] output_types, long[][] output_shapes,String opName= "GroupByWindowDataset" ) 
      {
         OperationDescription desc = NewOperation("GroupByWindowDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(key_func_other_arguments);
         desc.AddInput(reduce_func_other_arguments);
         desc.AddInput(window_size_func_other_arguments);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="diagonal">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation MatrixSetDiag (  Output input , Output diagonal ,String opName= "MatrixSetDiag" ) 
      {
         OperationDescription desc = NewOperation("MatrixSetDiag", opName);
         desc.AddInput(input);
         desc.AddInput(diagonal);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="values">Input to the operation. </param>
      ///<param name="shapes">Input to the operation. </param>
      ///<param name="dense_inputs">Input to the operation. </param>
      ///<param name="hashed_output"></param>
      ///<param name="num_buckets"></param>
      ///<param name="hash_key"></param>
      ///<param name="out_type"></param>
      ///<param name="internal_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_indices(type: DtInt64).
      ///[1] output_values(type: DtInvalid).
      ///[2] output_shape(type: DtInt64).
      ///</return>
      public Operation SparseCross (  Output indices , Output values , Output shapes , Output dense_inputs , bool hashed_output, long num_buckets, long hash_key, DataType out_type, DataType internal_type,String opName= "SparseCross" ) 
      {
         OperationDescription desc = NewOperation("SparseCross", opName);
         desc.AddInput(indices);
         desc.AddInput(values);
         desc.AddInput(shapes);
         desc.AddInput(dense_inputs);
         desc.SetAttr("hashed_output", hashed_output);
         desc.SetAttr("num_buckets", num_buckets);
         desc.SetAttr("hash_key", hash_key);
         desc.SetAttr("out_type", out_type);
         desc.SetAttr("internal_type", internal_type);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="elem">Input to the operation. </param>
      ///<param name="swap_memory"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation StackPush (  Output handle , Output elem , bool swap_memory = false ,String opName= "StackPush" ) 
      {
         OperationDescription desc = NewOperation("StackPush", opName);
         desc.AddInput(handle);
         desc.AddInput(elem);

         if (swap_memory != false) desc.SetAttr("swap_memory", swap_memory);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="values">Input to the operation. </param>
      ///<param name="shape"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation ParallelConcat (  Output values , long[] shape,String opName= "ParallelConcat" ) 
      {
         OperationDescription desc = NewOperation("ParallelConcat", opName);
         desc.AddInput(values);
         desc.SetAttrShape("shape", shape);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="parameters">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="axis">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation GatherV2 (  Output parameters , Output indices , Output axis ,String opName= "GatherV2" ) 
      {
         OperationDescription desc = NewOperation("GatherV2", opName);
         desc.AddInput(parameters);
         desc.AddInput(indices);
         desc.AddInput(axis);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="scale">Input to the operation. </param>
      ///<param name="offset">Input to the operation. </param>
      ///<param name="mean">Input to the operation. </param>
      ///<param name="variance">Input to the operation. </param>
      ///<param name="epsilon"></param>
      ///<param name="data_format"></param>
      ///<param name="is_training"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///[1] batch_mean(type: DtInvalid).
      ///[2] batch_variance(type: DtInvalid).
      ///[3] reserve_space_1(type: DtInvalid).
      ///[4] reserve_space_2(type: DtInvalid).
      ///</return>
      public Operation FusedBatchNormV2 (  Output x , Output scale , Output offset , Output mean , Output variance , float epsilon = 0.0001f , string data_format = null , bool is_training = true ,String opName= "FusedBatchNormV2" ) 
      {
         OperationDescription desc = NewOperation("FusedBatchNormV2", opName);
         desc.AddInput(x);
         desc.AddInput(scale);
         desc.AddInput(offset);
         desc.AddInput(mean);
         desc.AddInput(variance);

         if (epsilon != 0.0001f) desc.SetAttr("epsilon", epsilon);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         if (is_training != true) desc.SetAttr("is_training", is_training);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="elem_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] elem(type: DtInvalid).
      ///</return>
      public Operation StackPop (  Output handle , DataType elem_type,String opName= "StackPop" ) 
      {
         OperationDescription desc = NewOperation("StackPop", opName);
         desc.AddInput(handle);
         desc.SetAttr("elem_type", elem_type);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="mg">Input to the operation. </param>
      ///<param name="ms">Input to the operation. </param>
      ///<param name="mom">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="rho">Input to the operation. </param>
      ///<param name="momentum">Input to the operation. </param>
      ///<param name="epsilon">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceSparseApplyCenteredRMSProp (  Output var , Output mg , Output ms , Output mom , Output lr , Output rho , Output momentum , Output epsilon , Output grad , Output indices , bool use_locking = false ,String opName= "ResourceSparseApplyCenteredRMSProp" ) 
      {
         OperationDescription desc = NewOperation("ResourceSparseApplyCenteredRMSProp", opName);
         desc.AddInput(var);
         desc.AddInput(mg);
         desc.AddInput(ms);
         desc.AddInput(mom);
         desc.AddInput(lr);
         desc.AddInput(rho);
         desc.AddInput(momentum);
         desc.AddInput(epsilon);
         desc.AddInput(grad);
         desc.AddInput(indices);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="size">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="element_shape"></param>
      ///<param name="dynamic_size"></param>
      ///<param name="clear_after_read"></param>
      ///<param name="identical_element_shapes"></param>
      ///<param name="tensor_array_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtResource).
      ///[1] flow(type: DtFloat).
      ///</return>
      public Operation TensorArrayV3 (  Output size , DataType dtype, long[] element_shape = null , bool dynamic_size = false , bool clear_after_read = true , bool identical_element_shapes = false , string tensor_array_name = null ,String opName= "TensorArrayV3" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayV3", opName);
         desc.AddInput(size);
         desc.SetAttr("dtype", dtype);
         if (element_shape != null) desc.SetAttrShape("element_shape", element_shape);
         if (dynamic_size != false) desc.SetAttr("dynamic_size", dynamic_size);
         if (clear_after_read != true) desc.SetAttr("clear_after_read", clear_after_read);
         if (identical_element_shapes != false) desc.SetAttr("identical_element_shapes", identical_element_shapes);
         if (tensor_array_name != null) desc.SetAttr("tensor_array_name", tensor_array_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="source"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] grad_handle(type: DtResource).
      ///[1] flow_out(type: DtFloat).
      ///</return>
      public Operation TensorArrayGradV3 (  Output handle , Output flow_in , string source,String opName= "TensorArrayGradV3" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayGradV3", opName);
         desc.AddInput(handle);
         desc.AddInput(flow_in);
         desc.SetAttr("source", source);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="index">Input to the operation. </param>
      ///<param name="value">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] flow_out(type: DtFloat).
      ///</return>
      public Operation TensorArrayWriteV3 (  Output handle , Output index , Output value , Output flow_in ,String opName= "TensorArrayWriteV3" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayWriteV3", opName);
         desc.AddInput(handle);
         desc.AddInput(index);
         desc.AddInput(value);
         desc.AddInput(flow_in);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="index">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] value(type: DtInvalid).
      ///</return>
      public Operation TensorArrayReadV3 (  Output handle , Output index , Output flow_in , DataType dtype,String opName= "TensorArrayReadV3" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayReadV3", opName);
         desc.AddInput(handle);
         desc.AddInput(index);
         desc.AddInput(flow_in);
         desc.SetAttr("dtype", dtype);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="element_shape"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] value(type: DtInvalid).
      ///</return>
      public Operation TensorArrayGatherV3 (  Output handle , Output indices , Output flow_in , DataType dtype, long[] element_shape = null ,String opName= "TensorArrayGatherV3" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayGatherV3", opName);
         desc.AddInput(handle);
         desc.AddInput(indices);
         desc.AddInput(flow_in);
         desc.SetAttr("dtype", dtype);
         if (element_shape != null) desc.SetAttrShape("element_shape", element_shape);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] size(type: DtInt32).
      ///</return>
      public Operation BarrierReadySize (  Output handle ,String opName= "BarrierReadySize" ) 
      {
         OperationDescription desc = NewOperation("BarrierReadySize", opName);
         desc.AddInput(handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="orig_input">Input to the operation. </param>
      ///<param name="orig_output">Input to the operation. </param>
      ///<param name="out_backprop">Input to the operation. </param>
      ///<param name="row_pooling_sequence">Input to the operation. </param>
      ///<param name="col_pooling_sequence">Input to the operation. </param>
      ///<param name="overlapping"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation FractionalMaxPoolGrad (  Output orig_input , Output orig_output , Output out_backprop , Output row_pooling_sequence , Output col_pooling_sequence , bool overlapping = false ,String opName= "FractionalMaxPoolGrad" ) 
      {
         OperationDescription desc = NewOperation("FractionalMaxPoolGrad", opName);
         desc.AddInput(orig_input);
         desc.AddInput(orig_output);
         desc.AddInput(out_backprop);
         desc.AddInput(row_pooling_sequence);
         desc.AddInput(col_pooling_sequence);

         if (overlapping != false) desc.SetAttr("overlapping", overlapping);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="value">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] flow_out(type: DtFloat).
      ///</return>
      public Operation TensorArrayScatterV3 (  Output handle , Output indices , Output value , Output flow_in ,String opName= "TensorArrayScatterV3" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayScatterV3", opName);
         desc.AddInput(handle);
         desc.AddInput(indices);
         desc.AddInput(value);
         desc.AddInput(flow_in);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="value">Input to the operation. </param>
      ///<param name="lengths">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] flow_out(type: DtFloat).
      ///</return>
      public Operation TensorArraySplitV3 (  Output handle , Output value , Output lengths , Output flow_in ,String opName= "TensorArraySplitV3" ) 
      {
         OperationDescription desc = NewOperation("TensorArraySplitV3", opName);
         desc.AddInput(handle);
         desc.AddInput(value);
         desc.AddInput(lengths);
         desc.AddInput(flow_in);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="parameters">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation GatherNd (  Output parameters , Output indices ,String opName= "GatherNd" ) 
      {
         OperationDescription desc = NewOperation("GatherNd", opName);
         desc.AddInput(parameters);
         desc.AddInput(indices);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="arguments">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      //The following attributes are not known: f: func
      public Operation MapDefun (  Output arguments , DataType[] output_types, long[][] output_shapes,String opName= "MapDefun" ) 
      {
         OperationDescription desc = NewOperation("MapDefun", opName);
         desc.AddInput(arguments);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="x_min">Input to the operation. </param>
      ///<param name="x_max">Input to the operation. </param>
      ///<param name="output_range_given"></param>
      ///<param name="given_y_min"></param>
      ///<param name="given_y_max"></param>
      ///<param name="variance_epsilon"></param>
      ///<param name="min_separation"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///[1] y_min(type: DtFloat).
      ///[2] y_max(type: DtFloat).
      ///</return>
      public Operation QuantizedInstanceNorm (  Output x , Output x_min , Output x_max , bool output_range_given = false , float given_y_min = 0f , float given_y_max = 0f , float variance_epsilon = 1E-05f , float min_separation = 0.001f ,String opName= "QuantizedInstanceNorm" ) 
      {
         OperationDescription desc = NewOperation("QuantizedInstanceNorm", opName);
         desc.AddInput(x);
         desc.AddInput(x_min);
         desc.AddInput(x_max);

         if (output_range_given != false) desc.SetAttr("output_range_given", output_range_given);
         if (given_y_min != 0f) desc.SetAttr("given_y_min", given_y_min);
         if (given_y_max != 0f) desc.SetAttr("given_y_max", given_y_max);
         if (variance_epsilon != 1E-05f) desc.SetAttr("variance_epsilon", variance_epsilon);
         if (min_separation != 0.001f) desc.SetAttr("min_separation", min_separation);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="segment_ids">Input to the operation. </param>
      ///<param name="num_segments">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SparseSegmentMeanWithNumSegments (  Output data , Output indices , Output segment_ids , Output num_segments ,String opName= "SparseSegmentMeanWithNumSegments" ) 
      {
         OperationDescription desc = NewOperation("SparseSegmentMeanWithNumSegments", opName);
         desc.AddInput(data);
         desc.AddInput(indices);
         desc.AddInput(segment_ids);
         desc.AddInput(num_segments);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] size(type: DtInt32).
      ///</return>
      public Operation TensorArraySizeV3 (  Output handle , Output flow_in ,String opName= "TensorArraySizeV3" ) 
      {
         OperationDescription desc = NewOperation("TensorArraySizeV3", opName);
         desc.AddInput(handle);
         desc.AddInput(flow_in);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation RealDiv (  Output x , Output y ,String opName= "RealDiv" ) 
      {
         OperationDescription desc = NewOperation("RealDiv", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation TensorArrayCloseV3 (  Output handle ,String opName= "TensorArrayCloseV3" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayCloseV3", opName);
         desc.AddInput(handle);


         return desc.FinishOperation();
      } 
      // Skipped function _If

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtUint8).
      ///</return>
      public Operation PopulationCount (  Output x ,String opName= "PopulationCount" ) 
      {
         OperationDescription desc = NewOperation("PopulationCount", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="size">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="dynamic_size"></param>
      ///<param name="clear_after_read"></param>
      ///<param name="tensor_array_name"></param>
      ///<param name="element_shape"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtString).
      ///</return>
      public Operation TensorArray (  Output size , DataType dtype, bool dynamic_size = false , bool clear_after_read = true , string tensor_array_name = null , long[] element_shape = null ,String opName= "TensorArray" ) 
      {
         OperationDescription desc = NewOperation("TensorArray", opName);
         desc.AddInput(size);
         desc.SetAttr("dtype", dtype);
         if (dynamic_size != false) desc.SetAttr("dynamic_size", dynamic_size);
         if (clear_after_read != true) desc.SetAttr("clear_after_read", clear_after_read);
         if (tensor_array_name != null) desc.SetAttr("tensor_array_name", tensor_array_name);
         if (element_shape != null) desc.SetAttrShape("element_shape", element_shape);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="size">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="element_shape"></param>
      ///<param name="dynamic_size"></param>
      ///<param name="clear_after_read"></param>
      ///<param name="tensor_array_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtString).
      ///</return>
      public Operation TensorArrayV2 (  Output size , DataType dtype, long[] element_shape = null , bool dynamic_size = false , bool clear_after_read = true , string tensor_array_name = null ,String opName= "TensorArrayV2" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayV2", opName);
         desc.AddInput(size);
         desc.SetAttr("dtype", dtype);
         if (element_shape != null) desc.SetAttrShape("element_shape", element_shape);
         if (dynamic_size != false) desc.SetAttr("dynamic_size", dynamic_size);
         if (clear_after_read != true) desc.SetAttr("clear_after_read", clear_after_read);
         if (tensor_array_name != null) desc.SetAttr("tensor_array_name", tensor_array_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="orig_input_shape">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="ksize"></param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="data_format"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation AvgPoolGrad (  Output orig_input_shape , Output grad , long[] ksize, long[] strides, string padding, string data_format = null ,String opName= "AvgPoolGrad" ) 
      {
         OperationDescription desc = NewOperation("AvgPoolGrad", opName);
         desc.AddInput(orig_input_shape);
         desc.AddInput(grad);
         desc.SetAttr("ksize", ksize);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation BitwiseOr (  Output x , Output y ,String opName= "BitwiseOr" ) 
      {
         OperationDescription desc = NewOperation("BitwiseOr", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="source"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] grad_handle(type: DtString).
      ///</return>
      public Operation TensorArrayGrad (  Output handle , Output flow_in , string source,String opName= "TensorArrayGrad" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayGrad", opName);
         desc.AddInput(handle);
         desc.AddInput(flow_in);
         desc.SetAttr("source", source);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="min_range">Input to the operation. </param>
      ///<param name="max_range">Input to the operation. </param>
      ///<param name="mode"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtFloat).
      ///</return>
      public Operation Dequantize (  Output input , Output min_range , Output max_range , string mode = null ,String opName= "Dequantize" ) 
      {
         OperationDescription desc = NewOperation("Dequantize", opName);
         desc.AddInput(input);
         desc.AddInput(min_range);
         desc.AddInput(max_range);

         if (mode != null) desc.SetAttr("mode", mode);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="shape">Input to the operation. </param>
      ///<param name="rate">Input to the operation. </param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation RandomPoisson (  Output shape , Output rate , long seed = 0 , long seed2 = 0 ,String opName= "RandomPoisson" ) 
      {
         OperationDescription desc = NewOperation("RandomPoisson", opName);
         desc.AddInput(shape);
         desc.AddInput(rate);

         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="set1">Input to the operation. </param>
      ///<param name="set2">Input to the operation. </param>
      ///<param name="set_operation"></param>
      ///<param name="validate_indices"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] result_indices(type: DtInt64).
      ///[1] result_values(type: DtInvalid).
      ///[2] result_shape(type: DtInt64).
      ///</return>
      public Operation DenseToDenseSetOperation (  Output set1 , Output set2 , string set_operation, bool validate_indices = true ,String opName= "DenseToDenseSetOperation" ) 
      {
         OperationDescription desc = NewOperation("DenseToDenseSetOperation", opName);
         desc.AddInput(set1);
         desc.AddInput(set2);
         desc.SetAttr("set_operation", set_operation);
         if (validate_indices != true) desc.SetAttr("validate_indices", validate_indices);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="table_handle">Input to the operation. </param>
      ///<param name="keys">Input to the operation. </param>
      ///<param name="values">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation InitializeTable (  Output table_handle , Output keys , Output values ,String opName= "InitializeTable" ) 
      {
         OperationDescription desc = NewOperation("InitializeTable", opName);
         desc.AddInput(table_handle);
         desc.AddInput(keys);
         desc.AddInput(values);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="shape">Input to the operation. </param>
      ///<param name="rate">Input to the operation. </param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="dtype"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation RandomPoissonV2 (  Output shape , Output rate , long seed = 0 , long seed2 = 0 , DataType? dtype = null ,String opName= "RandomPoissonV2" ) 
      {
         OperationDescription desc = NewOperation("RandomPoissonV2", opName);
         desc.AddInput(shape);
         desc.AddInput(rate);

         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         if (dtype.HasValue) desc.SetAttr("dtype", dtype.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="a">Input to the operation. </param>
      ///<param name="b">Input to the operation. </param>
      ///<param name="transpose_a"></param>
      ///<param name="transpose_b"></param>
      ///<param name="a_is_sparse"></param>
      ///<param name="b_is_sparse"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] product(type: DtFloat).
      ///</return>
      public Operation SparseMatMul (  Output a , Output b , bool transpose_a = false , bool transpose_b = false , bool a_is_sparse = false , bool b_is_sparse = false ,String opName= "SparseMatMul" ) 
      {
         OperationDescription desc = NewOperation("SparseMatMul", opName);
         desc.AddInput(a);
         desc.AddInput(b);

         if (transpose_a != false) desc.SetAttr("transpose_a", transpose_a);
         if (transpose_b != false) desc.SetAttr("transpose_b", transpose_b);
         if (a_is_sparse != false) desc.SetAttr("a_is_sparse", a_is_sparse);
         if (b_is_sparse != false) desc.SetAttr("b_is_sparse", b_is_sparse);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="table_handle">Input to the operation. </param>
      ///<param name="keys">Input to the operation. </param>
      ///<param name="values">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation InitializeTableV2 (  Output table_handle , Output keys , Output values ,String opName= "InitializeTableV2" ) 
      {
         OperationDescription desc = NewOperation("InitializeTableV2", opName);
         desc.AddInput(table_handle);
         desc.AddInput(keys);
         desc.AddInput(values);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="source"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] grad_handle(type: DtString).
      ///</return>
      public Operation TensorArrayGradV2 (  Output handle , Output flow_in , string source,String opName= "TensorArrayGradV2" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayGradV2", opName);
         desc.AddInput(handle);
         desc.AddInput(flow_in);
         desc.SetAttr("source", source);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="file_pattern"></param>
      ///<param name="file_random_seed"></param>
      ///<param name="file_shuffle_shift_ratio"></param>
      ///<param name="file_buffer_size"></param>
      ///<param name="file_parallelism"></param>
      ///<param name="batch_size"></param>
      ///<param name="compression_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] records(type: DtString).
      ///</return>
      public Operation RecordInput (  string file_pattern, long file_random_seed = 301 , float file_shuffle_shift_ratio = 0f , long file_buffer_size = 10000 , long file_parallelism = 16 , long batch_size = 32 , string compression_type = null ,String opName= "RecordInput" ) 
      {
         OperationDescription desc = NewOperation("RecordInput", opName);

         desc.SetAttr("file_pattern", file_pattern);
         if (file_random_seed != 301) desc.SetAttr("file_random_seed", file_random_seed);
         if (file_shuffle_shift_ratio != 0f) desc.SetAttr("file_shuffle_shift_ratio", file_shuffle_shift_ratio);
         if (file_buffer_size != 10000) desc.SetAttr("file_buffer_size", file_buffer_size);
         if (file_parallelism != 16) desc.SetAttr("file_parallelism", file_parallelism);
         if (batch_size != 32) desc.SetAttr("batch_size", batch_size);
         if (compression_type != null) desc.SetAttr("compression_type", compression_type);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="initial_state">Input to the operation. </param>
      ///<param name="other_arguments">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      //The following attributes are not known: f: func
      public Operation ScanDataset (  Output input_dataset , Output initial_state , Output other_arguments , DataType[] output_types, long[][] output_shapes,String opName= "ScanDataset" ) 
      {
         OperationDescription desc = NewOperation("ScanDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(initial_state);
         desc.AddInput(other_arguments);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="index">Input to the operation. </param>
      ///<param name="value">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] flow_out(type: DtFloat).
      ///</return>
      public Operation TensorArrayWrite (  Output handle , Output index , Output value , Output flow_in ,String opName= "TensorArrayWrite" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayWrite", opName);
         desc.AddInput(handle);
         desc.AddInput(index);
         desc.AddInput(value);
         desc.AddInput(flow_in);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="m">Input to the operation. </param>
      ///<param name="v">Input to the operation. </param>
      ///<param name="beta1_power">Input to the operation. </param>
      ///<param name="beta2_power">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="beta1">Input to the operation. </param>
      ///<param name="beta2">Input to the operation. </param>
      ///<param name="epsilon">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="use_nesterov"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceApplyAdam (  Output var , Output m , Output v , Output beta1_power , Output beta2_power , Output lr , Output beta1 , Output beta2 , Output epsilon , Output grad , bool use_locking = false , bool use_nesterov = false ,String opName= "ResourceApplyAdam" ) 
      {
         OperationDescription desc = NewOperation("ResourceApplyAdam", opName);
         desc.AddInput(var);
         desc.AddInput(m);
         desc.AddInput(v);
         desc.AddInput(beta1_power);
         desc.AddInput(beta2_power);
         desc.AddInput(lr);
         desc.AddInput(beta1);
         desc.AddInput(beta2);
         desc.AddInput(epsilon);
         desc.AddInput(grad);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         if (use_nesterov != false) desc.SetAttr("use_nesterov", use_nesterov);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation DivNoNan (  Output x , Output y ,String opName= "DivNoNan" ) 
      {
         OperationDescription desc = NewOperation("DivNoNan", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="index">Input to the operation. </param>
      ///<param name="value">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] flow_out(type: DtFloat).
      ///</return>
      public Operation TensorArrayWriteV2 (  Output handle , Output index , Output value , Output flow_in ,String opName= "TensorArrayWriteV2" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayWriteV2", opName);
         desc.AddInput(handle);
         desc.AddInput(index);
         desc.AddInput(value);
         desc.AddInput(flow_in);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="crops">Input to the operation. </param>
      ///<param name="block_size"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation BatchToSpace (  Output input , Output crops , long block_size,String opName= "BatchToSpace" ) 
      {
         OperationDescription desc = NewOperation("BatchToSpace", opName);
         desc.AddInput(input);
         desc.AddInput(crops);
         desc.SetAttr("block_size", block_size);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="segment_ids">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SegmentSum (  Output data , Output segment_ids ,String opName= "SegmentSum" ) 
      {
         OperationDescription desc = NewOperation("SegmentSum", opName);
         desc.AddInput(data);
         desc.AddInput(segment_ids);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="index">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] value(type: DtInvalid).
      ///</return>
      public Operation TensorArrayRead (  Output handle , Output index , Output flow_in , DataType dtype,String opName= "TensorArrayRead" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayRead", opName);
         desc.AddInput(handle);
         desc.AddInput(index);
         desc.AddInput(flow_in);
         desc.SetAttr("dtype", dtype);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Floor (  Output x ,String opName= "Floor" ) 
      {
         OperationDescription desc = NewOperation("Floor", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="index">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] value(type: DtInvalid).
      ///</return>
      public Operation TensorArrayReadV2 (  Output handle , Output index , Output flow_in , DataType dtype,String opName= "TensorArrayReadV2" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayReadV2", opName);
         desc.AddInput(handle);
         desc.AddInput(index);
         desc.AddInput(flow_in);
         desc.SetAttr("dtype", dtype);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="element_shape"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] value(type: DtInvalid).
      ///</return>
      public Operation TensorArrayPack (  Output handle , Output flow_in , DataType dtype, long[] element_shape = null ,String opName= "TensorArrayPack" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayPack", opName);
         desc.AddInput(handle);
         desc.AddInput(flow_in);
         desc.SetAttr("dtype", dtype);
         if (element_shape != null) desc.SetAttrShape("element_shape", element_shape);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="element_shape"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] value(type: DtInvalid).
      ///</return>
      public Operation TensorArrayGather (  Output handle , Output indices , Output flow_in , DataType dtype, long[] element_shape = null ,String opName= "TensorArrayGather" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayGather", opName);
         desc.AddInput(handle);
         desc.AddInput(indices);
         desc.AddInput(flow_in);
         desc.SetAttr("dtype", dtype);
         if (element_shape != null) desc.SetAttrShape("element_shape", element_shape);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="buffer_size">Input to the operation. </param>
      ///<param name="seed">Input to the operation. </param>
      ///<param name="seed2">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="reshuffle_each_iteration"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation ShuffleDataset (  Output input_dataset , Output buffer_size , Output seed , Output seed2 , DataType[] output_types, long[][] output_shapes, bool reshuffle_each_iteration = true ,String opName= "ShuffleDataset" ) 
      {
         OperationDescription desc = NewOperation("ShuffleDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(buffer_size);
         desc.AddInput(seed);
         desc.AddInput(seed2);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);
         if (reshuffle_each_iteration != true) desc.SetAttr("reshuffle_each_iteration", reshuffle_each_iteration);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="element_shape"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] value(type: DtInvalid).
      ///</return>
      public Operation TensorArrayGatherV2 (  Output handle , Output indices , Output flow_in , DataType dtype, long[] element_shape = null ,String opName= "TensorArrayGatherV2" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayGatherV2", opName);
         desc.AddInput(handle);
         desc.AddInput(indices);
         desc.AddInput(flow_in);
         desc.SetAttr("dtype", dtype);
         if (element_shape != null) desc.SetAttrShape("element_shape", element_shape);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="resource_handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] string_handle(type: DtString).
      ///</return>
      public Operation IteratorToStringHandle (  Output resource_handle ,String opName= "IteratorToStringHandle" ) 
      {
         OperationDescription desc = NewOperation("IteratorToStringHandle", opName);
         desc.AddInput(resource_handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_indices">Input to the operation. </param>
      ///<param name="input_shape">Input to the operation. </param>
      ///<param name="new_shape">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_indices(type: DtInt64).
      ///[1] output_shape(type: DtInt64).
      ///</return>
      public Operation SparseReshape (  Output input_indices , Output input_shape , Output new_shape ,String opName= "SparseReshape" ) 
      {
         OperationDescription desc = NewOperation("SparseReshape", opName);
         desc.AddInput(input_indices);
         desc.AddInput(input_shape);
         desc.AddInput(new_shape);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="value">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] flow_out(type: DtFloat).
      ///</return>
      public Operation TensorArrayScatter (  Output handle , Output indices , Output value , Output flow_in ,String opName= "TensorArrayScatter" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayScatter", opName);
         desc.AddInput(handle);
         desc.AddInput(indices);
         desc.AddInput(value);
         desc.AddInput(flow_in);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="value">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] flow_out(type: DtFloat).
      ///</return>
      public Operation TensorArrayScatterV2 (  Output handle , Output indices , Output value , Output flow_in ,String opName= "TensorArrayScatterV2" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayScatterV2", opName);
         desc.AddInput(handle);
         desc.AddInput(indices);
         desc.AddInput(value);
         desc.AddInput(flow_in);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="diagonal">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation BatchMatrixSetDiag (  Output input , Output diagonal ,String opName= "BatchMatrixSetDiag" ) 
      {
         OperationDescription desc = NewOperation("BatchMatrixSetDiag", opName);
         desc.AddInput(input);
         desc.AddInput(diagonal);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="element_shape_except0"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] value(type: DtInvalid).
      ///[1] lengths(type: DtInt64).
      ///</return>
      public Operation TensorArrayConcat (  Output handle , Output flow_in , DataType dtype, long[] element_shape_except0 = null ,String opName= "TensorArrayConcat" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayConcat", opName);
         desc.AddInput(handle);
         desc.AddInput(flow_in);
         desc.SetAttr("dtype", dtype);
         if (element_shape_except0 != null) desc.SetAttrShape("element_shape_except0", element_shape_except0);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="a">Input to the operation. </param>
      ///<param name="b">Input to the operation. </param>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation Betainc (  Output a , Output b , Output x ,String opName= "Betainc" ) 
      {
         OperationDescription desc = NewOperation("Betainc", opName);
         desc.AddInput(a);
         desc.AddInput(b);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_sizes">Input to the operation. </param>
      ///<param name="filter">Input to the operation. </param>
      ///<param name="out_backprop">Input to the operation. </param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="use_cudnn_on_gpu"></param>
      ///<param name="data_format"></param>
      ///<param name="dilations"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Conv2DBackpropInput (  Output input_sizes , Output filter , Output out_backprop , long[] strides, string padding, bool use_cudnn_on_gpu = true , string data_format = null , long[] dilations = null ,String opName= "Conv2DBackpropInput" ) 
      {
         OperationDescription desc = NewOperation("Conv2DBackpropInput", opName);
         desc.AddInput(input_sizes);
         desc.AddInput(filter);
         desc.AddInput(out_backprop);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);
         if (use_cudnn_on_gpu != true) desc.SetAttr("use_cudnn_on_gpu", use_cudnn_on_gpu);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         if (dilations != null) desc.SetAttr("dilations", dilations);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="driver_name">Input to the operation. </param>
      ///<param name="data_source_name">Input to the operation. </param>
      ///<param name="query">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation SqlDataset (  Output driver_name , Output data_source_name , Output query , DataType[] output_types, long[][] output_shapes,String opName= "SqlDataset" ) 
      {
         OperationDescription desc = NewOperation("SqlDataset", opName);
         desc.AddInput(driver_name);
         desc.AddInput(data_source_name);
         desc.AddInput(query);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="pattern">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] filenames(type: DtString).
      ///</return>
      public Operation MatchingFiles (  Output pattern ,String opName= "MatchingFiles" ) 
      {
         OperationDescription desc = NewOperation("MatchingFiles", opName);
         desc.AddInput(pattern);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="element_shape_except0"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] value(type: DtInvalid).
      ///[1] lengths(type: DtInt64).
      ///</return>
      public Operation TensorArrayConcatV2 (  Output handle , Output flow_in , DataType dtype, long[] element_shape_except0 = null ,String opName= "TensorArrayConcatV2" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayConcatV2", opName);
         desc.AddInput(handle);
         desc.AddInput(flow_in);
         desc.SetAttr("dtype", dtype);
         if (element_shape_except0 != null) desc.SetAttrShape("element_shape_except0", element_shape_except0);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="dtypes"></param>
      ///<param name="capacity"></param>
      ///<param name="memory_limit"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation OrderedMapClear (  DataType[] dtypes, long capacity = 0 , long memory_limit = 0 , string container = null , string shared_name = null ,String opName= "OrderedMapClear" ) 
      {
         OperationDescription desc = NewOperation("OrderedMapClear", opName);

         desc.SetAttr("dtypes", dtypes);
         if (capacity != 0) desc.SetAttr("capacity", capacity);
         if (memory_limit != 0) desc.SetAttr("memory_limit", memory_limit);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="stats_aggregator">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation SetStatsAggregatorDataset (  Output input_dataset , Output stats_aggregator , DataType[] output_types, long[][] output_shapes,String opName= "SetStatsAggregatorDataset" ) 
      {
         OperationDescription desc = NewOperation("SetStatsAggregatorDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(stats_aggregator);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="grads">Input to the operation. </param>
      ///<param name="size">Input to the operation. </param>
      ///<param name="align_corners"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation ResizeNearestNeighborGrad (  Output grads , Output size , bool align_corners = false ,String opName= "ResizeNearestNeighborGrad" ) 
      {
         OperationDescription desc = NewOperation("ResizeNearestNeighborGrad", opName);
         desc.AddInput(grads);
         desc.AddInput(size);

         if (align_corners != false) desc.SetAttr("align_corners", align_corners);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="element_shape">Input to the operation. </param>
      ///<param name="element_dtype"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation EmptyTensorList (  Output element_shape , DataType element_dtype,String opName= "EmptyTensorList" ) 
      {
         OperationDescription desc = NewOperation("EmptyTensorList", opName);
         desc.AddInput(element_shape);
         desc.SetAttr("element_dtype", element_dtype);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="value">Input to the operation. </param>
      ///<param name="size_splits">Input to the operation. </param>
      ///<param name="split_dim">Input to the operation. </param>
      ///<param name="num_split"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SplitV (  Output value , Output size_splits , Output split_dim , long num_split,String opName= "SplitV" ) 
      {
         OperationDescription desc = NewOperation("SplitV", opName);
         desc.AddInput(value);
         desc.AddInput(size_splits);
         desc.AddInput(split_dim);
         desc.SetAttr("num_split", num_split);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="ksize"></param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="data_format"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation MaxPool (  Output input , long[] ksize, long[] strides, string padding, string data_format = null ,String opName= "MaxPool" ) 
      {
         OperationDescription desc = NewOperation("MaxPool", opName);
         desc.AddInput(input);
         desc.SetAttr("ksize", ksize);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="value">Input to the operation. </param>
      ///<param name="lengths">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] flow_out(type: DtFloat).
      ///</return>
      public Operation TensorArraySplit (  Output handle , Output value , Output lengths , Output flow_in ,String opName= "TensorArraySplit" ) 
      {
         OperationDescription desc = NewOperation("TensorArraySplit", opName);
         desc.AddInput(handle);
         desc.AddInput(value);
         desc.AddInput(lengths);
         desc.AddInput(flow_in);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation MatrixDeterminant (  Output input ,String opName= "MatrixDeterminant" ) 
      {
         OperationDescription desc = NewOperation("MatrixDeterminant", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="compute_v"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] e(type: DtInvalid).
      ///[1] v(type: DtInvalid).
      ///</return>
      public Operation BatchSelfAdjointEigV2 (  Output input , bool compute_v = true ,String opName= "BatchSelfAdjointEigV2" ) 
      {
         OperationDescription desc = NewOperation("BatchSelfAdjointEigV2", opName);
         desc.AddInput(input);

         if (compute_v != true) desc.SetAttr("compute_v", compute_v);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="y">Input to the operation. </param>
      ///<param name="dy">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation SqrtGrad (  Output y , Output dy ,String opName= "SqrtGrad" ) 
      {
         OperationDescription desc = NewOperation("SqrtGrad", opName);
         desc.AddInput(y);
         desc.AddInput(dy);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="ksize">Input to the operation. </param>
      ///<param name="strides">Input to the operation. </param>
      ///<param name="padding"></param>
      ///<param name="data_format"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation MaxPoolV2 (  Output input , Output ksize , Output strides , string padding, string data_format = null ,String opName= "MaxPoolV2" ) 
      {
         OperationDescription desc = NewOperation("MaxPoolV2", opName);
         desc.AddInput(input);
         desc.AddInput(ksize);
         desc.AddInput(strides);
         desc.SetAttr("padding", padding);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="value">Input to the operation. </param>
      ///<param name="lengths">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] flow_out(type: DtFloat).
      ///</return>
      public Operation TensorArraySplitV2 (  Output handle , Output value , Output lengths , Output flow_in ,String opName= "TensorArraySplitV2" ) 
      {
         OperationDescription desc = NewOperation("TensorArraySplitV2", opName);
         desc.AddInput(handle);
         desc.AddInput(value);
         desc.AddInput(lengths);
         desc.AddInput(flow_in);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] size(type: DtInt32).
      ///</return>
      public Operation TensorArraySize (  Output handle , Output flow_in ,String opName= "TensorArraySize" ) 
      {
         OperationDescription desc = NewOperation("TensorArraySize", opName);
         desc.AddInput(handle);
         desc.AddInput(flow_in);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="iterator">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] optional(type: DtVariant).
      ///</return>
      public Operation IteratorGetNextAsOptional (  Output iterator , DataType[] output_types, long[][] output_shapes,String opName= "IteratorGetNextAsOptional" ) 
      {
         OperationDescription desc = NewOperation("IteratorGetNextAsOptional", opName);
         desc.AddInput(iterator);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="flow_in">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] size(type: DtInt32).
      ///</return>
      public Operation TensorArraySizeV2 (  Output handle , Output flow_in ,String opName= "TensorArraySizeV2" ) 
      {
         OperationDescription desc = NewOperation("TensorArraySizeV2", opName);
         desc.AddInput(handle);
         desc.AddInput(flow_in);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="reduction_indices">Input to the operation. </param>
      ///<param name="keep_dims"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Min (  Output input , Output reduction_indices , bool keep_dims = false ,String opName= "Min" ) 
      {
         OperationDescription desc = NewOperation("Min", opName);
         desc.AddInput(input);
         desc.AddInput(reduction_indices);

         if (keep_dims != false) desc.SetAttr("keep_dims", keep_dims);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reference">Input to the operation. </param>
      ///<param name="begin">Input to the operation. </param>
      ///<param name="end">Input to the operation. </param>
      ///<param name="strides">Input to the operation. </param>
      ///<param name="value">Input to the operation. </param>
      ///<param name="begin_mask"></param>
      ///<param name="end_mask"></param>
      ///<param name="ellipsis_mask"></param>
      ///<param name="new_axis_mask"></param>
      ///<param name="shrink_axis_mask"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_ref(type: DtInvalid).
      ///</return>
      public Operation StridedSliceAssign (  Output reference , Output begin , Output end , Output strides , Output value , long begin_mask = 0 , long end_mask = 0 , long ellipsis_mask = 0 , long new_axis_mask = 0 , long shrink_axis_mask = 0 ,String opName= "StridedSliceAssign" ) 
      {
         OperationDescription desc = NewOperation("StridedSliceAssign", opName);
         desc.AddInput(reference);
         desc.AddInput(begin);
         desc.AddInput(end);
         desc.AddInput(strides);
         desc.AddInput(value);

         if (begin_mask != 0) desc.SetAttr("begin_mask", begin_mask);
         if (end_mask != 0) desc.SetAttr("end_mask", end_mask);
         if (ellipsis_mask != 0) desc.SetAttr("ellipsis_mask", ellipsis_mask);
         if (new_axis_mask != 0) desc.SetAttr("new_axis_mask", new_axis_mask);
         if (shrink_axis_mask != 0) desc.SetAttr("shrink_axis_mask", shrink_axis_mask);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation TensorArrayClose (  Output handle ,String opName= "TensorArrayClose" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayClose", opName);
         desc.AddInput(handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation TensorArrayCloseV2 (  Output handle ,String opName= "TensorArrayCloseV2" ) 
      {
         OperationDescription desc = NewOperation("TensorArrayCloseV2", opName);
         desc.AddInput(handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="component_types"></param>
      ///<param name="shapes"></param>
      ///<param name="capacity"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtString).
      ///</return>
      public Operation Barrier (  DataType[] component_types, long[][] shapes = null , long capacity = -1 , string container = null , string shared_name = null ,String opName= "Barrier" ) 
      {
         OperationDescription desc = NewOperation("Barrier", opName);

         desc.SetAttr("component_types", component_types);
         if (shapes != null) desc.SetAttrShapeList("shapes", shapes);
         if (capacity != -1) desc.SetAttr("capacity", capacity);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="perm">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Transpose (  Output x , Output perm ,String opName= "Transpose" ) 
      {
         OperationDescription desc = NewOperation("Transpose", opName);
         desc.AddInput(x);
         desc.AddInput(perm);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="writer">Input to the operation. </param>
      ///<param name="step">Input to the operation. </param>
      ///<param name="tag">Input to the operation. </param>
      ///<param name="values">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation WriteHistogramSummary (  Output writer , Output step , Output tag , Output values ,String opName= "WriteHistogramSummary" ) 
      {
         OperationDescription desc = NewOperation("WriteHistogramSummary", opName);
         desc.AddInput(writer);
         desc.AddInput(step);
         desc.AddInput(tag);
         desc.AddInput(values);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="keys">Input to the operation. </param>
      ///<param name="values">Input to the operation. </param>
      ///<param name="component_index"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation BarrierInsertMany (  Output handle , Output keys , Output values , long component_index,String opName= "BarrierInsertMany" ) 
      {
         OperationDescription desc = NewOperation("BarrierInsertMany", opName);
         desc.AddInput(handle);
         desc.AddInput(keys);
         desc.AddInput(values);
         desc.SetAttr("component_index", component_index);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="num_elements">Input to the operation. </param>
      ///<param name="component_types"></param>
      ///<param name="allow_small_batch"></param>
      ///<param name="wait_for_incomplete"></param>
      ///<param name="timeout_ms"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] indices(type: DtInt64).
      ///[1] keys(type: DtString).
      ///[2] values(type: DtInvalid).
      ///</return>
      public Operation BarrierTakeMany (  Output handle , Output num_elements , DataType[] component_types, bool allow_small_batch = false , bool wait_for_incomplete = false , long timeout_ms = -1 ,String opName= "BarrierTakeMany" ) 
      {
         OperationDescription desc = NewOperation("BarrierTakeMany", opName);
         desc.AddInput(handle);
         desc.AddInput(num_elements);
         desc.SetAttr("component_types", component_types);
         if (allow_small_batch != false) desc.SetAttr("allow_small_batch", allow_small_batch);
         if (wait_for_incomplete != false) desc.SetAttr("wait_for_incomplete", wait_for_incomplete);
         if (timeout_ms != -1) desc.SetAttr("timeout_ms", timeout_ms);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="cancel_pending_enqueues"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation BarrierClose (  Output handle , bool cancel_pending_enqueues = false ,String opName= "BarrierClose" ) 
      {
         OperationDescription desc = NewOperation("BarrierClose", opName);
         desc.AddInput(handle);

         if (cancel_pending_enqueues != false) desc.SetAttr("cancel_pending_enqueues", cancel_pending_enqueues);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] size(type: DtInt32).
      ///</return>
      public Operation BarrierIncompleteSize (  Output handle ,String opName= "BarrierIncompleteSize" ) 
      {
         OperationDescription desc = NewOperation("BarrierIncompleteSize", opName);
         desc.AddInput(handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="value">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtString).
      ///</return>
      public Operation GetSessionHandle (  Output value ,String opName= "GetSessionHandle" ) 
      {
         OperationDescription desc = NewOperation("GetSessionHandle", opName);
         desc.AddInput(value);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="value">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtResource).
      ///</return>
      public Operation GetSessionHandleV2 (  Output value ,String opName= "GetSessionHandleV2" ) 
      {
         OperationDescription desc = NewOperation("GetSessionHandleV2", opName);
         desc.AddInput(value);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="serialized_sparse">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] sparse_indices(type: DtInt64).
      ///[1] sparse_values(type: DtInvalid).
      ///[2] sparse_shape(type: DtInt64).
      ///</return>
      public Operation DeserializeSparse (  Output serialized_sparse , DataType dtype,String opName= "DeserializeSparse" ) 
      {
         OperationDescription desc = NewOperation("DeserializeSparse", opName);
         desc.AddInput(serialized_sparse);
         desc.SetAttr("dtype", dtype);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="adjoint"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation MatrixInverse (  Output input , bool adjoint = false ,String opName= "MatrixInverse" ) 
      {
         OperationDescription desc = NewOperation("MatrixInverse", opName);
         desc.AddInput(input);

         if (adjoint != false) desc.SetAttr("adjoint", adjoint);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="handle">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] value(type: DtInvalid).
      ///</return>
      public Operation GetSessionTensor (  Output handle , DataType dtype,String opName= "GetSessionTensor" ) 
      {
         OperationDescription desc = NewOperation("GetSessionTensor", opName);
         desc.AddInput(handle);
         desc.SetAttr("dtype", dtype);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="condition">Input to the operation. </param>
      ///<param name="t">Input to the operation. </param>
      ///<param name="e">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Select (  Output condition , Output t , Output e ,String opName= "Select" ) 
      {
         OperationDescription desc = NewOperation("Select", opName);
         desc.AddInput(condition);
         desc.AddInput(t);
         desc.AddInput(e);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="values">Input to the operation. </param>
      ///<param name="capacity"></param>
      ///<param name="memory_limit"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation Stage (  Output values , long capacity = 0 , long memory_limit = 0 , string container = null , string shared_name = null ,String opName= "Stage" ) 
      {
         OperationDescription desc = NewOperation("Stage", opName);
         desc.AddInput(values);

         if (capacity != 0) desc.SetAttr("capacity", capacity);
         if (memory_limit != 0) desc.SetAttr("memory_limit", memory_limit);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="dtypes"></param>
      ///<param name="capacity"></param>
      ///<param name="memory_limit"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] values(type: DtInvalid).
      ///</return>
      public Operation Unstage (  DataType[] dtypes, long capacity = 0 , long memory_limit = 0 , string container = null , string shared_name = null ,String opName= "Unstage" ) 
      {
         OperationDescription desc = NewOperation("Unstage", opName);

         desc.SetAttr("dtypes", dtypes);
         if (capacity != 0) desc.SetAttr("capacity", capacity);
         if (memory_limit != 0) desc.SetAttr("memory_limit", memory_limit);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="index">Input to the operation. </param>
      ///<param name="dtypes"></param>
      ///<param name="capacity"></param>
      ///<param name="memory_limit"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] values(type: DtInvalid).
      ///</return>
      public Operation StagePeek (  Output index , DataType[] dtypes, long capacity = 0 , long memory_limit = 0 , string container = null , string shared_name = null ,String opName= "StagePeek" ) 
      {
         OperationDescription desc = NewOperation("StagePeek", opName);
         desc.AddInput(index);
         desc.SetAttr("dtypes", dtypes);
         if (capacity != 0) desc.SetAttr("capacity", capacity);
         if (memory_limit != 0) desc.SetAttr("memory_limit", memory_limit);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="dtypes"></param>
      ///<param name="capacity"></param>
      ///<param name="memory_limit"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] size(type: DtInt32).
      ///</return>
      public Operation StageSize (  DataType[] dtypes, long capacity = 0 , long memory_limit = 0 , string container = null , string shared_name = null ,String opName= "StageSize" ) 
      {
         OperationDescription desc = NewOperation("StageSize", opName);

         desc.SetAttr("dtypes", dtypes);
         if (capacity != 0) desc.SetAttr("capacity", capacity);
         if (memory_limit != 0) desc.SetAttr("memory_limit", memory_limit);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="writer">Input to the operation. </param>
      ///<param name="logdir">Input to the operation. </param>
      ///<param name="max_queue">Input to the operation. </param>
      ///<param name="flush_millis">Input to the operation. </param>
      ///<param name="filename_suffix">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation CreateSummaryFileWriter (  Output writer , Output logdir , Output max_queue , Output flush_millis , Output filename_suffix ,String opName= "CreateSummaryFileWriter" ) 
      {
         OperationDescription desc = NewOperation("CreateSummaryFileWriter", opName);
         desc.AddInput(writer);
         desc.AddInput(logdir);
         desc.AddInput(max_queue);
         desc.AddInput(flush_millis);
         desc.AddInput(filename_suffix);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Asinh (  Output x ,String opName= "Asinh" ) 
      {
         OperationDescription desc = NewOperation("Asinh", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="dtypes"></param>
      ///<param name="capacity"></param>
      ///<param name="memory_limit"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation StageClear (  DataType[] dtypes, long capacity = 0 , long memory_limit = 0 , string container = null , string shared_name = null ,String opName= "StageClear" ) 
      {
         OperationDescription desc = NewOperation("StageClear", opName);

         desc.SetAttr("dtypes", dtypes);
         if (capacity != 0) desc.SetAttr("capacity", capacity);
         if (memory_limit != 0) desc.SetAttr("memory_limit", memory_limit);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="key">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="dtypes"></param>
      ///<param name="capacity"></param>
      ///<param name="memory_limit"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] values(type: DtInvalid).
      ///</return>
      public Operation MapPeek (  Output key , Output indices , DataType[] dtypes, long capacity = 0 , long memory_limit = 0 , string container = null , string shared_name = null ,String opName= "MapPeek" ) 
      {
         OperationDescription desc = NewOperation("MapPeek", opName);
         desc.AddInput(key);
         desc.AddInput(indices);
         desc.SetAttr("dtypes", dtypes);
         if (capacity != 0) desc.SetAttr("capacity", capacity);
         if (memory_limit != 0) desc.SetAttr("memory_limit", memory_limit);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="sparse_indices">Input to the operation. </param>
      ///<param name="sparse_values">Input to the operation. </param>
      ///<param name="sparse_shape">Input to the operation. </param>
      ///<param name="out_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] serialized_sparse(type: DtInvalid).
      ///</return>
      public Operation SerializeSparse (  Output sparse_indices , Output sparse_values , Output sparse_shape , DataType? out_type = null ,String opName= "SerializeSparse" ) 
      {
         OperationDescription desc = NewOperation("SerializeSparse", opName);
         desc.AddInput(sparse_indices);
         desc.AddInput(sparse_values);
         desc.AddInput(sparse_shape);

         if (out_type.HasValue) desc.SetAttr("out_type", out_type.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="compute_v"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] e(type: DtInvalid).
      ///[1] v(type: DtInvalid).
      ///</return>
      public Operation SelfAdjointEigV2 (  Output input , bool compute_v = true ,String opName= "SelfAdjointEigV2" ) 
      {
         OperationDescription desc = NewOperation("SelfAdjointEigV2", opName);
         desc.AddInput(input);

         if (compute_v != true) desc.SetAttr("compute_v", compute_v);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="key">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="values">Input to the operation. </param>
      ///<param name="dtypes"></param>
      ///<param name="capacity"></param>
      ///<param name="memory_limit"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation MapStage (  Output key , Output indices , Output values , DataType[] dtypes, long capacity = 0 , long memory_limit = 0 , string container = null , string shared_name = null ,String opName= "MapStage" ) 
      {
         OperationDescription desc = NewOperation("MapStage", opName);
         desc.AddInput(key);
         desc.AddInput(indices);
         desc.AddInput(values);
         desc.SetAttr("dtypes", dtypes);
         if (capacity != 0) desc.SetAttr("capacity", capacity);
         if (memory_limit != 0) desc.SetAttr("memory_limit", memory_limit);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="y">Input to the operation. </param>
      ///<param name="dy">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation InvGrad (  Output y , Output dy ,String opName= "InvGrad" ) 
      {
         OperationDescription desc = NewOperation("InvGrad", opName);
         desc.AddInput(y);
         desc.AddInput(dy);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="table_handle">Input to the operation. </param>
      ///<param name="keys">Input to the operation. </param>
      ///<param name="values">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation LookupTableInsertV2 (  Output table_handle , Output keys , Output values ,String opName= "LookupTableInsertV2" ) 
      {
         OperationDescription desc = NewOperation("LookupTableInsertV2", opName);
         desc.AddInput(table_handle);
         desc.AddInput(keys);
         desc.AddInput(values);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="key">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="dtypes"></param>
      ///<param name="capacity"></param>
      ///<param name="memory_limit"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] values(type: DtInvalid).
      ///</return>
      public Operation MapUnstage (  Output key , Output indices , DataType[] dtypes, long capacity = 0 , long memory_limit = 0 , string container = null , string shared_name = null ,String opName= "MapUnstage" ) 
      {
         OperationDescription desc = NewOperation("MapUnstage", opName);
         desc.AddInput(key);
         desc.AddInput(indices);
         desc.SetAttr("dtypes", dtypes);
         if (capacity != 0) desc.SetAttr("capacity", capacity);
         if (memory_limit != 0) desc.SetAttr("memory_limit", memory_limit);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="dtypes"></param>
      ///<param name="capacity"></param>
      ///<param name="memory_limit"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] key(type: DtInt64).
      ///[1] values(type: DtInvalid).
      ///</return>
      public Operation MapUnstageNoKey (  Output indices , DataType[] dtypes, long capacity = 0 , long memory_limit = 0 , string container = null , string shared_name = null ,String opName= "MapUnstageNoKey" ) 
      {
         OperationDescription desc = NewOperation("MapUnstageNoKey", opName);
         desc.AddInput(indices);
         desc.SetAttr("dtypes", dtypes);
         if (capacity != 0) desc.SetAttr("capacity", capacity);
         if (memory_limit != 0) desc.SetAttr("memory_limit", memory_limit);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="string_handle">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] resource_handle(type: DtResource).
      ///</return>
      public Operation IteratorFromStringHandle (  Output string_handle , DataType[] output_types = null , long[][] output_shapes = null ,String opName= "IteratorFromStringHandle" ) 
      {
         OperationDescription desc = NewOperation("IteratorFromStringHandle", opName);
         desc.AddInput(string_handle);

         if (output_types != null) desc.SetAttr("output_types", output_types);
         if (output_shapes != null) desc.SetAttrShapeList("output_shapes", output_shapes);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="dtypes"></param>
      ///<param name="capacity"></param>
      ///<param name="memory_limit"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] size(type: DtInt32).
      ///</return>
      public Operation MapSize (  DataType[] dtypes, long capacity = 0 , long memory_limit = 0 , string container = null , string shared_name = null ,String opName= "MapSize" ) 
      {
         OperationDescription desc = NewOperation("MapSize", opName);

         desc.SetAttr("dtypes", dtypes);
         if (capacity != 0) desc.SetAttr("capacity", capacity);
         if (memory_limit != 0) desc.SetAttr("memory_limit", memory_limit);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="dtypes"></param>
      ///<param name="capacity"></param>
      ///<param name="memory_limit"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] size(type: DtInt32).
      ///</return>
      public Operation MapIncompleteSize (  DataType[] dtypes, long capacity = 0 , long memory_limit = 0 , string container = null , string shared_name = null ,String opName= "MapIncompleteSize" ) 
      {
         OperationDescription desc = NewOperation("MapIncompleteSize", opName);

         desc.SetAttr("dtypes", dtypes);
         if (capacity != 0) desc.SetAttr("capacity", capacity);
         if (memory_limit != 0) desc.SetAttr("memory_limit", memory_limit);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation GuaranteeConst (  Output input ,String opName= "GuaranteeConst" ) 
      {
         OperationDescription desc = NewOperation("GuaranteeConst", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="dtypes"></param>
      ///<param name="capacity"></param>
      ///<param name="memory_limit"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation MapClear (  DataType[] dtypes, long capacity = 0 , long memory_limit = 0 , string container = null , string shared_name = null ,String opName= "MapClear" ) 
      {
         OperationDescription desc = NewOperation("MapClear", opName);

         desc.SetAttr("dtypes", dtypes);
         if (capacity != 0) desc.SetAttr("capacity", capacity);
         if (memory_limit != 0) desc.SetAttr("memory_limit", memory_limit);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] diagonal(type: DtInvalid).
      ///</return>
      public Operation MatrixDiagPart (  Output input ,String opName= "MatrixDiagPart" ) 
      {
         OperationDescription desc = NewOperation("MatrixDiagPart", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="key">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="values">Input to the operation. </param>
      ///<param name="dtypes"></param>
      ///<param name="capacity"></param>
      ///<param name="memory_limit"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation OrderedMapStage (  Output key , Output indices , Output values , DataType[] dtypes, long capacity = 0 , long memory_limit = 0 , string container = null , string shared_name = null ,String opName= "OrderedMapStage" ) 
      {
         OperationDescription desc = NewOperation("OrderedMapStage", opName);
         desc.AddInput(key);
         desc.AddInput(indices);
         desc.AddInput(values);
         desc.SetAttr("dtypes", dtypes);
         if (capacity != 0) desc.SetAttr("capacity", capacity);
         if (memory_limit != 0) desc.SetAttr("memory_limit", memory_limit);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="key">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="dtypes"></param>
      ///<param name="capacity"></param>
      ///<param name="memory_limit"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] values(type: DtInvalid).
      ///</return>
      public Operation OrderedMapPeek (  Output key , Output indices , DataType[] dtypes, long capacity = 0 , long memory_limit = 0 , string container = null , string shared_name = null ,String opName= "OrderedMapPeek" ) 
      {
         OperationDescription desc = NewOperation("OrderedMapPeek", opName);
         desc.AddInput(key);
         desc.AddInput(indices);
         desc.SetAttr("dtypes", dtypes);
         if (capacity != 0) desc.SetAttr("capacity", capacity);
         if (memory_limit != 0) desc.SetAttr("memory_limit", memory_limit);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Bitcast (  Output input , DataType type,String opName= "Bitcast" ) 
      {
         OperationDescription desc = NewOperation("Bitcast", opName);
         desc.AddInput(input);
         desc.SetAttr("type", type);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reference">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="updates">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_ref(type: DtInvalid).
      ///</return>
      public Operation ScatterNdSub (  Output reference , Output indices , Output updates , bool use_locking = false ,String opName= "ScatterNdSub" ) 
      {
         OperationDescription desc = NewOperation("ScatterNdSub", opName);
         desc.AddInput(reference);
         desc.AddInput(indices);
         desc.AddInput(updates);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="key">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="dtypes"></param>
      ///<param name="capacity"></param>
      ///<param name="memory_limit"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] values(type: DtInvalid).
      ///</return>
      public Operation OrderedMapUnstage (  Output key , Output indices , DataType[] dtypes, long capacity = 0 , long memory_limit = 0 , string container = null , string shared_name = null ,String opName= "OrderedMapUnstage" ) 
      {
         OperationDescription desc = NewOperation("OrderedMapUnstage", opName);
         desc.AddInput(key);
         desc.AddInput(indices);
         desc.SetAttr("dtypes", dtypes);
         if (capacity != 0) desc.SetAttr("capacity", capacity);
         if (memory_limit != 0) desc.SetAttr("memory_limit", memory_limit);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="value">Input to the operation. </param>
      ///<param name="num"></param>
      ///<param name="axis"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Unpack (  Output value , long num, long axis = 0 ,String opName= "Unpack" ) 
      {
         OperationDescription desc = NewOperation("Unpack", opName);
         desc.AddInput(value);
         desc.SetAttr("num", num);
         if (axis != 0) desc.SetAttr("axis", axis);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="dtypes"></param>
      ///<param name="capacity"></param>
      ///<param name="memory_limit"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] key(type: DtInt64).
      ///[1] values(type: DtInvalid).
      ///</return>
      public Operation OrderedMapUnstageNoKey (  Output indices , DataType[] dtypes, long capacity = 0 , long memory_limit = 0 , string container = null , string shared_name = null ,String opName= "OrderedMapUnstageNoKey" ) 
      {
         OperationDescription desc = NewOperation("OrderedMapUnstageNoKey", opName);
         desc.AddInput(indices);
         desc.SetAttr("dtypes", dtypes);
         if (capacity != 0) desc.SetAttr("capacity", capacity);
         if (memory_limit != 0) desc.SetAttr("memory_limit", memory_limit);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="serialized">Input to the operation. </param>
      ///<param name="feature_list_dense_missing_assumed_empty">Input to the operation. </param>
      ///<param name="context_sparse_keys">Input to the operation. </param>
      ///<param name="context_dense_keys">Input to the operation. </param>
      ///<param name="feature_list_sparse_keys">Input to the operation. </param>
      ///<param name="feature_list_dense_keys">Input to the operation. </param>
      ///<param name="context_dense_defaults">Input to the operation. </param>
      ///<param name="debug_name">Input to the operation. </param>
      ///<param name="context_sparse_types"></param>
      ///<param name="feature_list_dense_types"></param>
      ///<param name="context_dense_shapes"></param>
      ///<param name="feature_list_sparse_types"></param>
      ///<param name="feature_list_dense_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] context_sparse_indices(type: DtInt64).
      ///[1] context_sparse_values(type: DtInvalid).
      ///[2] context_sparse_shapes(type: DtInt64).
      ///[3] context_dense_values(type: DtInvalid).
      ///[4] feature_list_sparse_indices(type: DtInt64).
      ///[5] feature_list_sparse_values(type: DtInvalid).
      ///[6] feature_list_sparse_shapes(type: DtInt64).
      ///[7] feature_list_dense_values(type: DtInvalid).
      ///</return>
      public Operation ParseSingleSequenceExample (  Output serialized , Output feature_list_dense_missing_assumed_empty , Output context_sparse_keys , Output context_dense_keys , Output feature_list_sparse_keys , Output feature_list_dense_keys , Output context_dense_defaults , Output debug_name , DataType[] context_sparse_types = null , DataType[] feature_list_dense_types = null , long[][] context_dense_shapes = null , DataType[] feature_list_sparse_types = null , long[][] feature_list_dense_shapes = null ,String opName= "ParseSingleSequenceExample" ) 
      {
         OperationDescription desc = NewOperation("ParseSingleSequenceExample", opName);
         desc.AddInput(serialized);
         desc.AddInput(feature_list_dense_missing_assumed_empty);
         desc.AddInput(context_sparse_keys);
         desc.AddInput(context_dense_keys);
         desc.AddInput(feature_list_sparse_keys);
         desc.AddInput(feature_list_dense_keys);
         desc.AddInput(context_dense_defaults);
         desc.AddInput(debug_name);

         if (context_sparse_types != null) desc.SetAttr("context_sparse_types", context_sparse_types);
         if (feature_list_dense_types != null) desc.SetAttr("feature_list_dense_types", feature_list_dense_types);
         if (context_dense_shapes != null) desc.SetAttrShapeList("context_dense_shapes", context_dense_shapes);
         if (feature_list_sparse_types != null) desc.SetAttr("feature_list_sparse_types", feature_list_sparse_types);
         if (feature_list_dense_shapes != null) desc.SetAttrShapeList("feature_list_dense_shapes", feature_list_dense_shapes);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="matrix">Input to the operation. </param>
      ///<param name="rhs">Input to the operation. </param>
      ///<param name="adjoint"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation BatchMatrixSolve (  Output matrix , Output rhs , bool adjoint = false ,String opName= "BatchMatrixSolve" ) 
      {
         OperationDescription desc = NewOperation("BatchMatrixSolve", opName);
         desc.AddInput(matrix);
         desc.AddInput(rhs);

         if (adjoint != false) desc.SetAttr("adjoint", adjoint);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="a_indices">Input to the operation. </param>
      ///<param name="a_values">Input to the operation. </param>
      ///<param name="a_shape">Input to the operation. </param>
      ///<param name="b_indices">Input to the operation. </param>
      ///<param name="b_values">Input to the operation. </param>
      ///<param name="b_shape">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_indices(type: DtInt64).
      ///[1] output_values(type: DtInvalid).
      ///</return>
      public Operation SparseSparseMaximum (  Output a_indices , Output a_values , Output a_shape , Output b_indices , Output b_values , Output b_shape ,String opName= "SparseSparseMaximum" ) 
      {
         OperationDescription desc = NewOperation("SparseSparseMaximum", opName);
         desc.AddInput(a_indices);
         desc.AddInput(a_values);
         desc.AddInput(a_shape);
         desc.AddInput(b_indices);
         desc.AddInput(b_values);
         desc.AddInput(b_shape);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="dtypes"></param>
      ///<param name="capacity"></param>
      ///<param name="memory_limit"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] size(type: DtInt32).
      ///</return>
      public Operation OrderedMapSize (  DataType[] dtypes, long capacity = 0 , long memory_limit = 0 , string container = null , string shared_name = null ,String opName= "OrderedMapSize" ) 
      {
         OperationDescription desc = NewOperation("OrderedMapSize", opName);

         desc.SetAttr("dtypes", dtypes);
         if (capacity != 0) desc.SetAttr("capacity", capacity);
         if (memory_limit != 0) desc.SetAttr("memory_limit", memory_limit);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="dataset">Input to the operation. </param>
      ///<param name="iterator">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation MakeIterator (  Output dataset , Output iterator ,String opName= "MakeIterator" ) 
      {
         OperationDescription desc = NewOperation("MakeIterator", opName);
         desc.AddInput(dataset);
         desc.AddInput(iterator);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="alpha">Input to the operation. </param>
      ///<param name="l1">Input to the operation. </param>
      ///<param name="l2">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceSparseApplyProximalGradientDescent (  Output var , Output alpha , Output l1 , Output l2 , Output grad , Output indices , bool use_locking = false ,String opName= "ResourceSparseApplyProximalGradientDescent" ) 
      {
         OperationDescription desc = NewOperation("ResourceSparseApplyProximalGradientDescent", opName);
         desc.AddInput(var);
         desc.AddInput(alpha);
         desc.AddInput(l1);
         desc.AddInput(l2);
         desc.AddInput(grad);
         desc.AddInput(indices);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="dtypes"></param>
      ///<param name="capacity"></param>
      ///<param name="memory_limit"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] size(type: DtInt32).
      ///</return>
      public Operation OrderedMapIncompleteSize (  DataType[] dtypes, long capacity = 0 , long memory_limit = 0 , string container = null , string shared_name = null ,String opName= "OrderedMapIncompleteSize" ) 
      {
         OperationDescription desc = NewOperation("OrderedMapIncompleteSize", opName);

         desc.SetAttr("dtypes", dtypes);
         if (capacity != 0) desc.SetAttr("capacity", capacity);
         if (memory_limit != 0) desc.SetAttr("memory_limit", memory_limit);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="optional">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] has_value(type: DtBool).
      ///</return>
      public Operation OptionalHasValue (  Output optional ,String opName= "OptionalHasValue" ) 
      {
         OperationDescription desc = NewOperation("OptionalHasValue", opName);
         desc.AddInput(optional);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] reader_handle(type: DtString).
      ///</return>
      public Operation IdentityReader (  string container = null , string shared_name = null ,String opName= "IdentityReader" ) 
      {
         OperationDescription desc = NewOperation("IdentityReader", opName);


         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="components">Input to the operation. </param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation TensorDataset (  Output components , long[][] output_shapes,String opName= "TensorDataset" ) 
      {
         OperationDescription desc = NewOperation("TensorDataset", opName);
         desc.AddInput(components);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="components">Input to the operation. </param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation TensorSliceDataset (  Output components , long[][] output_shapes,String opName= "TensorSliceDataset" ) 
      {
         OperationDescription desc = NewOperation("TensorSliceDataset", opName);
         desc.AddInput(components);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="init_func_other_args">Input to the operation. </param>
      ///<param name="next_func_other_args">Input to the operation. </param>
      ///<param name="finalize_func_other_args">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      //The following attributes are not known: init_func: func; next_func: func; finalize_func: func
      public Operation GeneratorDataset (  Output init_func_other_args , Output next_func_other_args , Output finalize_func_other_args , DataType[] output_types, long[][] output_shapes,String opName= "GeneratorDataset" ) 
      {
         OperationDescription desc = NewOperation("GeneratorDataset", opName);
         desc.AddInput(init_func_other_args);
         desc.AddInput(next_func_other_args);
         desc.AddInput(finalize_func_other_args);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtComplex64).
      ///</return>
      public Operation BatchIFFT (  Output input ,String opName= "BatchIFFT" ) 
      {
         OperationDescription desc = NewOperation("BatchIFFT", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="dtype"></param>
      ///<param name="shape"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation PlaceholderV2 (  DataType dtype, long[] shape,String opName= "PlaceholderV2" ) 
      {
         OperationDescription desc = NewOperation("PlaceholderV2", opName);

         desc.SetAttr("dtype", dtype);
         desc.SetAttrShape("shape", shape);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation UnbatchDataset (  Output input_dataset , DataType[] output_types, long[][] output_shapes,String opName= "UnbatchDataset" ) 
      {
         OperationDescription desc = NewOperation("UnbatchDataset", opName);
         desc.AddInput(input_dataset);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="address">Input to the operation. </param>
      ///<param name="method">Input to the operation. </param>
      ///<param name="request">Input to the operation. </param>
      ///<param name="protocol"></param>
      ///<param name="fail_fast"></param>
      ///<param name="timeout_in_ms"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] response(type: DtString).
      ///</return>
      public Operation Rpc (  Output address , Output method , Output request , string protocol = null , bool fail_fast = true , long timeout_in_ms = 0 ,String opName= "Rpc" ) 
      {
         OperationDescription desc = NewOperation("Rpc", opName);
         desc.AddInput(address);
         desc.AddInput(method);
         desc.AddInput(request);

         if (protocol != null) desc.SetAttr("protocol", protocol);
         if (fail_fast != true) desc.SetAttr("fail_fast", fail_fast);
         if (timeout_in_ms != 0) desc.SetAttr("timeout_in_ms", timeout_in_ms);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_datasets">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation ZipDataset (  Output input_datasets , DataType[] output_types, long[][] output_shapes,String opName= "ZipDataset" ) 
      {
         OperationDescription desc = NewOperation("ZipDataset", opName);
         desc.AddInput(input_datasets);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="out_idx"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///[1] idx(type: DtInvalid).
      ///[2] count(type: DtInvalid).
      ///</return>
      public Operation UniqueWithCounts (  Output x , DataType? out_idx = null ,String opName= "UniqueWithCounts" ) 
      {
         OperationDescription desc = NewOperation("UniqueWithCounts", opName);
         desc.AddInput(x);

         if (out_idx.HasValue) desc.SetAttr("out_idx", out_idx.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="count">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation TakeDataset (  Output input_dataset , Output count , DataType[] output_types, long[][] output_shapes,String opName= "TakeDataset" ) 
      {
         OperationDescription desc = NewOperation("TakeDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(count);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="writer">Input to the operation. </param>
      ///<param name="db_uri">Input to the operation. </param>
      ///<param name="experiment_name">Input to the operation. </param>
      ///<param name="run_name">Input to the operation. </param>
      ///<param name="user_name">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation CreateSummaryDbWriter (  Output writer , Output db_uri , Output experiment_name , Output run_name , Output user_name ,String opName= "CreateSummaryDbWriter" ) 
      {
         OperationDescription desc = NewOperation("CreateSummaryDbWriter", opName);
         desc.AddInput(writer);
         desc.AddInput(db_uri);
         desc.AddInput(experiment_name);
         desc.AddInput(run_name);
         desc.AddInput(user_name);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="a">Input to the operation. </param>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation Igammac (  Output a , Output x ,String opName= "Igammac" ) 
      {
         OperationDescription desc = NewOperation("Igammac", opName);
         desc.AddInput(a);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="count">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation SkipDataset (  Output input_dataset , Output count , DataType[] output_types, long[][] output_shapes,String opName= "SkipDataset" ) 
      {
         OperationDescription desc = NewOperation("SkipDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(count);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="concat_dim">Input to the operation. </param>
      ///<param name="values">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Concat (  Output concat_dim , Output values ,String opName= "Concat" ) 
      {
         OperationDescription desc = NewOperation("Concat", opName);
         desc.AddInput(concat_dim);
         desc.AddInput(values);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="tag">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation BytesProducedStatsDataset (  Output input_dataset , Output tag , DataType[] output_types, long[][] output_shapes,String opName= "BytesProducedStatsDataset" ) 
      {
         OperationDescription desc = NewOperation("BytesProducedStatsDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(tag);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="tag">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation LatencyStatsDataset (  Output input_dataset , Output tag , DataType[] output_types, long[][] output_shapes,String opName= "LatencyStatsDataset" ) 
      {
         OperationDescription desc = NewOperation("LatencyStatsDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(tag);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="string_handle">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] resource_handle(type: DtResource).
      ///</return>
      public Operation IteratorFromStringHandleV2 (  Output string_handle , DataType[] output_types = null , long[][] output_shapes = null ,String opName= "IteratorFromStringHandleV2" ) 
      {
         OperationDescription desc = NewOperation("IteratorFromStringHandleV2", opName);
         desc.AddInput(string_handle);

         if (output_types != null) desc.SetAttr("output_types", output_types);
         if (output_shapes != null) desc.SetAttrShapeList("output_shapes", output_shapes);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation TruncateDiv (  Output x , Output y ,String opName= "TruncateDiv" ) 
      {
         OperationDescription desc = NewOperation("TruncateDiv", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="filter">Input to the operation. </param>
      ///<param name="out_backprop">Input to the operation. </param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="dilations"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Conv3DBackpropInput (  Output input , Output filter , Output out_backprop , long[] strides, string padding, long[] dilations = null ,String opName= "Conv3DBackpropInput" ) 
      {
         OperationDescription desc = NewOperation("Conv3DBackpropInput", opName);
         desc.AddInput(input);
         desc.AddInput(filter);
         desc.AddInput(out_backprop);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);
         if (dilations != null) desc.SetAttr("dilations", dilations);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="num_parallel_calls">Input to the operation. </param>
      ///<param name="dense_defaults">Input to the operation. </param>
      ///<param name="sparse_keys"></param>
      ///<param name="dense_keys"></param>
      ///<param name="sparse_types"></param>
      ///<param name="dense_shapes"></param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation ParseExampleDataset (  Output input_dataset , Output num_parallel_calls , Output dense_defaults , string[] sparse_keys, string[] dense_keys, DataType[] sparse_types, long[][] dense_shapes, DataType[] output_types, long[][] output_shapes,String opName= "ParseExampleDataset" ) 
      {
         OperationDescription desc = NewOperation("ParseExampleDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(num_parallel_calls);
         desc.AddInput(dense_defaults);
         desc.SetAttr("sparse_keys", sparse_keys);
         desc.SetAttr("dense_keys", dense_keys);
         desc.SetAttr("sparse_types", sparse_types);
         desc.SetAttrShapeList("dense_shapes", dense_shapes);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="gradient_accumulator">Input to the operation. </param>
      ///<param name="gradient_squared_accumulator">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="l1">Input to the operation. </param>
      ///<param name="l2">Input to the operation. </param>
      ///<param name="global_step">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceSparseApplyAdagradDA (  Output var , Output gradient_accumulator , Output gradient_squared_accumulator , Output grad , Output indices , Output lr , Output l1 , Output l2 , Output global_step , bool use_locking = false ,String opName= "ResourceSparseApplyAdagradDA" ) 
      {
         OperationDescription desc = NewOperation("ResourceSparseApplyAdagradDA", opName);
         desc.AddInput(var);
         desc.AddInput(gradient_accumulator);
         desc.AddInput(gradient_squared_accumulator);
         desc.AddInput(grad);
         desc.AddInput(indices);
         desc.AddInput(lr);
         desc.AddInput(l1);
         desc.AddInput(l2);
         desc.AddInput(global_step);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Expm1 (  Output x ,String opName= "Expm1" ) 
      {
         OperationDescription desc = NewOperation("Expm1", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_sizes">Input to the operation. </param>
      ///<param name="filter">Input to the operation. </param>
      ///<param name="out_backprop">Input to the operation. </param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="data_format"></param>
      ///<param name="dilations"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Conv3DBackpropInputV2 (  Output input_sizes , Output filter , Output out_backprop , long[] strides, string padding, string data_format = null , long[] dilations = null ,String opName= "Conv3DBackpropInputV2" ) 
      {
         OperationDescription desc = NewOperation("Conv3DBackpropInputV2", opName);
         desc.AddInput(input_sizes);
         desc.AddInput(filter);
         desc.AddInput(out_backprop);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         if (dilations != null) desc.SetAttr("dilations", dilations);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="buffer_size">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation PrefetchDataset (  Output input_dataset , Output buffer_size , DataType[] output_types, long[][] output_shapes,String opName= "PrefetchDataset" ) 
      {
         OperationDescription desc = NewOperation("PrefetchDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(buffer_size);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="other_arguments">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      //The following attributes are not known: f: func
      public Operation FlatMapDataset (  Output input_dataset , Output other_arguments , DataType[] output_types, long[][] output_shapes,String opName= "FlatMapDataset" ) 
      {
         OperationDescription desc = NewOperation("FlatMapDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(other_arguments);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="other_arguments">Input to the operation. </param>
      ///<param name="cycle_length">Input to the operation. </param>
      ///<param name="block_length">Input to the operation. </param>
      ///<param name="sloppy">Input to the operation. </param>
      ///<param name="buffer_output_elements">Input to the operation. </param>
      ///<param name="prefetch_input_elements">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      //The following attributes are not known: f: func
      public Operation ParallelInterleaveDataset (  Output input_dataset , Output other_arguments , Output cycle_length , Output block_length , Output sloppy , Output buffer_output_elements , Output prefetch_input_elements , DataType[] output_types, long[][] output_shapes,String opName= "ParallelInterleaveDataset" ) 
      {
         OperationDescription desc = NewOperation("ParallelInterleaveDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(other_arguments);
         desc.AddInput(cycle_length);
         desc.AddInput(block_length);
         desc.AddInput(sloppy);
         desc.AddInput(buffer_output_elements);
         desc.AddInput(prefetch_input_elements);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="update_slots"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceSparseApplyAdagrad (  Output var , Output accum , Output lr , Output grad , Output indices , bool use_locking = false , bool update_slots = true ,String opName= "ResourceSparseApplyAdagrad" ) 
      {
         OperationDescription desc = NewOperation("ResourceSparseApplyAdagrad", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(lr);
         desc.AddInput(grad);
         desc.AddInput(indices);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         if (update_slots != true) desc.SetAttr("update_slots", update_slots);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="segment_ids">Input to the operation. </param>
      ///<param name="num_segments">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation UnsortedSegmentProd (  Output data , Output segment_ids , Output num_segments ,String opName= "UnsortedSegmentProd" ) 
      {
         OperationDescription desc = NewOperation("UnsortedSegmentProd", opName);
         desc.AddInput(data);
         desc.AddInput(segment_ids);
         desc.AddInput(num_segments);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="key_func_other_arguments">Input to the operation. </param>
      ///<param name="init_func_other_arguments">Input to the operation. </param>
      ///<param name="reduce_func_other_arguments">Input to the operation. </param>
      ///<param name="finalize_func_other_arguments">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      //The following attributes are not known: key_func: func; init_func: func; reduce_func: func; finalize_func: func
      public Operation GroupByReducerDataset (  Output input_dataset , Output key_func_other_arguments , Output init_func_other_arguments , Output reduce_func_other_arguments , Output finalize_func_other_arguments , DataType[] output_types, long[][] output_shapes,String opName= "GroupByReducerDataset" ) 
      {
         OperationDescription desc = NewOperation("GroupByReducerDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(key_func_other_arguments);
         desc.AddInput(init_func_other_arguments);
         desc.AddInput(reduce_func_other_arguments);
         desc.AddInput(finalize_func_other_arguments);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="gradients">Input to the operation. </param>
      ///<param name="inputs">Input to the operation. </param>
      ///<param name="min">Input to the operation. </param>
      ///<param name="max">Input to the operation. </param>
      ///<param name="num_bits"></param>
      ///<param name="narrow_range"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] backprops_wrt_input(type: DtFloat).
      ///[1] backprop_wrt_min(type: DtFloat).
      ///[2] backprop_wrt_max(type: DtFloat).
      ///</return>
      public Operation FakeQuantWithMinMaxVarsPerChannelGradient (  Output gradients , Output inputs , Output min , Output max , long num_bits = 8 , bool narrow_range = false ,String opName= "FakeQuantWithMinMaxVarsPerChannelGradient" ) 
      {
         OperationDescription desc = NewOperation("FakeQuantWithMinMaxVarsPerChannelGradient", opName);
         desc.AddInput(gradients);
         desc.AddInput(inputs);
         desc.AddInput(min);
         desc.AddInput(max);

         if (num_bits != 8) desc.SetAttr("num_bits", num_bits);
         if (narrow_range != false) desc.SetAttr("narrow_range", narrow_range);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_a">Input to the operation. </param>
      ///<param name="input_b">Input to the operation. </param>
      ///<param name="element_dtype"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtVariant).
      ///</return>
      public Operation TensorListConcatLists (  Output input_a , Output input_b , DataType element_dtype,String opName= "TensorListConcatLists" ) 
      {
         OperationDescription desc = NewOperation("TensorListConcatLists", opName);
         desc.AddInput(input_a);
         desc.AddInput(input_b);
         desc.SetAttr("element_dtype", element_dtype);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="alpha">Input to the operation. </param>
      ///<param name="l1">Input to the operation. </param>
      ///<param name="l2">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation SparseApplyProximalGradientDescent (  Output var , Output alpha , Output l1 , Output l2 , Output grad , Output indices , bool use_locking = false ,String opName= "SparseApplyProximalGradientDescent" ) 
      {
         OperationDescription desc = NewOperation("SparseApplyProximalGradientDescent", opName);
         desc.AddInput(var);
         desc.AddInput(alpha);
         desc.AddInput(l1);
         desc.AddInput(l2);
         desc.AddInput(grad);
         desc.AddInput(indices);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="other_arguments">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      //The following attributes are not known: predicate: func
      public Operation FilterDataset (  Output input_dataset , Output other_arguments , DataType[] output_types, long[][] output_shapes,String opName= "FilterDataset" ) 
      {
         OperationDescription desc = NewOperation("FilterDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(other_arguments);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtVariant).
      ///</return>
      public Operation FilterByLastComponentDataset (  Output input_dataset , DataType[] output_types, long[][] output_shapes,String opName= "FilterByLastComponentDataset" ) 
      {
         OperationDescription desc = NewOperation("FilterByLastComponentDataset", opName);
         desc.AddInput(input_dataset);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="window_size">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation WindowDataset (  Output input_dataset , Output window_size , DataType[] output_types, long[][] output_shapes,String opName= "WindowDataset" ) 
      {
         OperationDescription desc = NewOperation("WindowDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(window_size);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="update_slots"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation ApplyAdagrad (  Output var , Output accum , Output lr , Output grad , bool use_locking = false , bool update_slots = true ,String opName= "ApplyAdagrad" ) 
      {
         OperationDescription desc = NewOperation("ApplyAdagrad", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(lr);
         desc.AddInput(grad);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         if (update_slots != true) desc.SetAttr("update_slots", update_slots);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="batch_size">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation BatchDataset (  Output input_dataset , Output batch_size , DataType[] output_types, long[][] output_shapes,String opName= "BatchDataset" ) 
      {
         OperationDescription desc = NewOperation("BatchDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(batch_size);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="momentum">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="use_nesterov"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation ApplyMomentum (  Output var , Output accum , Output lr , Output grad , Output momentum , bool use_locking = false , bool use_nesterov = false ,String opName= "ApplyMomentum" ) 
      {
         OperationDescription desc = NewOperation("ApplyMomentum", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(lr);
         desc.AddInput(grad);
         desc.AddInput(momentum);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         if (use_nesterov != false) desc.SetAttr("use_nesterov", use_nesterov);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="batch_size">Input to the operation. </param>
      ///<param name="drop_remainder">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation BatchDatasetV2 (  Output input_dataset , Output batch_size , Output drop_remainder , DataType[] output_types, long[][] output_shapes,String opName= "BatchDatasetV2" ) 
      {
         OperationDescription desc = NewOperation("BatchDatasetV2", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(batch_size);
         desc.AddInput(drop_remainder);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] optional(type: DtVariant).
      ///</return>
      public Operation OptionalNone ( String opName= "OptionalNone" ) 
      {
         OperationDescription desc = NewOperation("OptionalNone", opName);



         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="batch_size">Input to the operation. </param>
      ///<param name="padded_shapes">Input to the operation. </param>
      ///<param name="padding_values">Input to the operation. </param>
      ///<param name="drop_remainder">Input to the operation. </param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation PaddedBatchDatasetV2 (  Output input_dataset , Output batch_size , Output padded_shapes , Output padding_values , Output drop_remainder , long[][] output_shapes,String opName= "PaddedBatchDatasetV2" ) 
      {
         OperationDescription desc = NewOperation("PaddedBatchDatasetV2", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(batch_size);
         desc.AddInput(padded_shapes);
         desc.AddInput(padding_values);
         desc.AddInput(drop_remainder);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="start">Input to the operation. </param>
      ///<param name="stop">Input to the operation. </param>
      ///<param name="step">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation RangeDataset (  Output start , Output stop , Output step , DataType[] output_types, long[][] output_shapes,String opName= "RangeDataset" ) 
      {
         OperationDescription desc = NewOperation("RangeDataset", opName);
         desc.AddInput(start);
         desc.AddInput(stop);
         desc.AddInput(step);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="buffer_size">Input to the operation. </param>
      ///<param name="seed">Input to the operation. </param>
      ///<param name="seed2">Input to the operation. </param>
      ///<param name="count">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation ShuffleAndRepeatDataset (  Output input_dataset , Output buffer_size , Output seed , Output seed2 , Output count , DataType[] output_types, long[][] output_shapes,String opName= "ShuffleAndRepeatDataset" ) 
      {
         OperationDescription desc = NewOperation("ShuffleAndRepeatDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(buffer_size);
         desc.AddInput(seed);
         desc.AddInput(seed2);
         desc.AddInput(count);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="optional">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] components(type: DtInvalid).
      ///</return>
      public Operation OptionalGetValue (  Output optional , DataType[] output_types, long[][] output_shapes,String opName= "OptionalGetValue" ) 
      {
         OperationDescription desc = NewOperation("OptionalGetValue", opName);
         desc.AddInput(optional);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="images">Input to the operation. </param>
      ///<param name="size">Input to the operation. </param>
      ///<param name="align_corners"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] resized_images(type: DtFloat).
      ///</return>
      public Operation ResizeArea (  Output images , Output size , bool align_corners = false ,String opName= "ResizeArea" ) 
      {
         OperationDescription desc = NewOperation("ResizeArea", opName);
         desc.AddInput(images);
         desc.AddInput(size);

         if (align_corners != false) desc.SetAttr("align_corners", align_corners);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] ts(type: DtDouble).
      ///</return>
      public Operation Timestamp ( String opName= "Timestamp" ) 
      {
         OperationDescription desc = NewOperation("Timestamp", opName);



         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="filename">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation CacheDataset (  Output input_dataset , Output filename , DataType[] output_types, long[][] output_shapes,String opName= "CacheDataset" ) 
      {
         OperationDescription desc = NewOperation("CacheDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(filename);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="tag">Input to the operation. </param>
      ///<param name="tensor">Input to the operation. </param>
      ///<param name="serialized_summary_metadata">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] summary(type: DtString).
      ///</return>
      public Operation TensorSummaryV2 (  Output tag , Output tensor , Output serialized_summary_metadata ,String opName= "TensorSummaryV2" ) 
      {
         OperationDescription desc = NewOperation("TensorSummaryV2", opName);
         desc.AddInput(tag);
         desc.AddInput(tensor);
         desc.AddInput(serialized_summary_metadata);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="filenames">Input to the operation. </param>
      ///<param name="compression_type">Input to the operation. </param>
      ///<param name="buffer_size">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation TextLineDataset (  Output filenames , Output compression_type , Output buffer_size ,String opName= "TextLineDataset" ) 
      {
         OperationDescription desc = NewOperation("TextLineDataset", opName);
         desc.AddInput(filenames);
         desc.AddInput(compression_type);
         desc.AddInput(buffer_size);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="filenames">Input to the operation. </param>
      ///<param name="compression_type">Input to the operation. </param>
      ///<param name="buffer_size">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation TFRecordDataset (  Output filenames , Output compression_type , Output buffer_size ,String opName= "TFRecordDataset" ) 
      {
         OperationDescription desc = NewOperation("TFRecordDataset", opName);
         desc.AddInput(filenames);
         desc.AddInput(compression_type);
         desc.AddInput(buffer_size);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reader_handle">Input to the operation. </param>
      ///<param name="queue_handle">Input to the operation. </param>
      ///<param name="num_records">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] keys(type: DtString).
      ///[1] values(type: DtString).
      ///</return>
      public Operation ReaderReadUpTo (  Output reader_handle , Output queue_handle , Output num_records ,String opName= "ReaderReadUpTo" ) 
      {
         OperationDescription desc = NewOperation("ReaderReadUpTo", opName);
         desc.AddInput(reader_handle);
         desc.AddInput(queue_handle);
         desc.AddInput(num_records);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="shared_name"></param>
      ///<param name="container"></param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtResource).
      ///</return>
      public Operation Iterator (  string shared_name, string container, DataType[] output_types, long[][] output_shapes,String opName= "Iterator" ) 
      {
         OperationDescription desc = NewOperation("Iterator", opName);

         desc.SetAttr("shared_name", shared_name);
         desc.SetAttr("container", container);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="mutex">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] mutex_lock(type: DtVariant).
      ///</return>
      public Operation MutexLock (  Output mutex ,String opName= "MutexLock" ) 
      {
         OperationDescription desc = NewOperation("MutexLock", opName);
         desc.AddInput(mutex);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="shared_name"></param>
      ///<param name="container"></param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtResource).
      ///</return>
      public Operation IteratorV2 (  string shared_name, string container, DataType[] output_types, long[][] output_shapes,String opName= "IteratorV2" ) 
      {
         OperationDescription desc = NewOperation("IteratorV2", opName);

         desc.SetAttr("shared_name", shared_name);
         desc.SetAttr("container", container);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtResource).
      ///</return>
      public Operation AnonymousIterator (  DataType[] output_types, long[][] output_shapes,String opName= "AnonymousIterator" ) 
      {
         OperationDescription desc = NewOperation("AnonymousIterator", opName);

         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="sparse_example_indices">Input to the operation. </param>
      ///<param name="sparse_feature_indices">Input to the operation. </param>
      ///<param name="sparse_feature_values">Input to the operation. </param>
      ///<param name="dense_features">Input to the operation. </param>
      ///<param name="example_weights">Input to the operation. </param>
      ///<param name="example_labels">Input to the operation. </param>
      ///<param name="sparse_indices">Input to the operation. </param>
      ///<param name="sparse_weights">Input to the operation. </param>
      ///<param name="dense_weights">Input to the operation. </param>
      ///<param name="example_state_data">Input to the operation. </param>
      ///<param name="loss_type"></param>
      ///<param name="l1"></param>
      ///<param name="l2"></param>
      ///<param name="num_loss_partitions"></param>
      ///<param name="num_inner_iterations"></param>
      ///<param name="adaptative"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out_example_state_data(type: DtFloat).
      ///[1] out_delta_sparse_weights(type: DtFloat).
      ///[2] out_delta_dense_weights(type: DtFloat).
      ///</return>
      public Operation SdcaOptimizer (  Output sparse_example_indices , Output sparse_feature_indices , Output sparse_feature_values , Output dense_features , Output example_weights , Output example_labels , Output sparse_indices , Output sparse_weights , Output dense_weights , Output example_state_data , string loss_type, float l1, float l2, long num_loss_partitions, long num_inner_iterations, bool adaptative = false ,String opName= "SdcaOptimizer" ) 
      {
         OperationDescription desc = NewOperation("SdcaOptimizer", opName);
         desc.AddInput(sparse_example_indices);
         desc.AddInput(sparse_feature_indices);
         desc.AddInput(sparse_feature_values);
         desc.AddInput(dense_features);
         desc.AddInput(example_weights);
         desc.AddInput(example_labels);
         desc.AddInput(sparse_indices);
         desc.AddInput(sparse_weights);
         desc.AddInput(dense_weights);
         desc.AddInput(example_state_data);
         desc.SetAttr("loss_type", loss_type);
         desc.SetAttr("l1", l1);
         desc.SetAttr("l2", l2);
         desc.SetAttr("num_loss_partitions", num_loss_partitions);
         desc.SetAttr("num_inner_iterations", num_inner_iterations);
         if (adaptative != false) desc.SetAttr("adaptative", adaptative);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_handles">Input to the operation. </param>
      ///<param name="tensor">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_handles(type: DtVariant).
      ///</return>
      public Operation TensorListPushBackBatch (  Output input_handles , Output tensor ,String opName= "TensorListPushBackBatch" ) 
      {
         OperationDescription desc = NewOperation("TensorListPushBackBatch", opName);
         desc.AddInput(input_handles);
         desc.AddInput(tensor);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="argmax">Input to the operation. </param>
      ///<param name="ksize"></param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation MaxPoolGradWithArgmax (  Output input , Output grad , Output argmax , long[] ksize, long[] strides, string padding,String opName= "MaxPoolGradWithArgmax" ) 
      {
         OperationDescription desc = NewOperation("MaxPoolGradWithArgmax", opName);
         desc.AddInput(input);
         desc.AddInput(grad);
         desc.AddInput(argmax);
         desc.SetAttr("ksize", ksize);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtResource).
      ///</return>
      //The following attributes are not known: dataset_factory: func
      public Operation OneShotIterator (  DataType[] output_types, long[][] output_shapes, string container = null , string shared_name = null ,String opName= "OneShotIterator" ) 
      {
         OperationDescription desc = NewOperation("OneShotIterator", opName);

         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="iterator">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] components(type: DtInvalid).
      ///</return>
      public Operation IteratorGetNext (  Output iterator , DataType[] output_types, long[][] output_shapes,String opName= "IteratorGetNext" ) 
      {
         OperationDescription desc = NewOperation("IteratorGetNext", opName);
         desc.AddInput(iterator);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="num_lower">Input to the operation. </param>
      ///<param name="num_upper">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] band(type: DtInvalid).
      ///</return>
      public Operation BatchMatrixBandPart (  Output input , Output num_lower , Output num_upper ,String opName= "BatchMatrixBandPart" ) 
      {
         OperationDescription desc = NewOperation("BatchMatrixBandPart", opName);
         desc.AddInput(input);
         desc.AddInput(num_lower);
         desc.AddInput(num_upper);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="tag">Input to the operation. </param>
      ///<param name="tensor">Input to the operation. </param>
      ///<param name="sample_rate"></param>
      ///<param name="max_outputs"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] summary(type: DtString).
      ///</return>
      public Operation AudioSummary (  Output tag , Output tensor , float sample_rate, long max_outputs = 3 ,String opName= "AudioSummary" ) 
      {
         OperationDescription desc = NewOperation("AudioSummary", opName);
         desc.AddInput(tag);
         desc.AddInput(tensor);
         desc.SetAttr("sample_rate", sample_rate);
         if (max_outputs != 3) desc.SetAttr("max_outputs", max_outputs);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="iterator">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] components(type: DtInvalid).
      ///</return>
      public Operation IteratorGetNextSync (  Output iterator , DataType[] output_types, long[][] output_shapes,String opName= "IteratorGetNextSync" ) 
      {
         OperationDescription desc = NewOperation("IteratorGetNextSync", opName);
         desc.AddInput(iterator);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="dataset">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] components(type: DtInvalid).
      ///</return>
      public Operation DatasetToSingleElement (  Output dataset , DataType[] output_types, long[][] output_shapes,String opName= "DatasetToSingleElement" ) 
      {
         OperationDescription desc = NewOperation("DatasetToSingleElement", opName);
         desc.AddInput(dataset);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="images">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation RGBToHSV (  Output images ,String opName= "RGBToHSV" ) 
      {
         OperationDescription desc = NewOperation("RGBToHSV", opName);
         desc.AddInput(images);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="dtype"></param>
      ///<param name="shape"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Placeholder (  DataType dtype, long[] shape = null ,String opName= "Placeholder" ) 
      {
         OperationDescription desc = NewOperation("Placeholder", opName);

         desc.SetAttr("dtype", dtype);
         if (shape != null) desc.SetAttrShape("shape", shape);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="resource_handle">Input to the operation. </param>
      ///<param name="serialized">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation DeserializeIterator (  Output resource_handle , Output serialized ,String opName= "DeserializeIterator" ) 
      {
         OperationDescription desc = NewOperation("DeserializeIterator", opName);
         desc.AddInput(resource_handle);
         desc.AddInput(serialized);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtResource).
      ///</return>
      public Operation StatsAggregatorHandle (  string container = null , string shared_name = null ,String opName= "StatsAggregatorHandle" ) 
      {
         OperationDescription desc = NewOperation("StatsAggregatorHandle", opName);


         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="filename">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] contents(type: DtString).
      ///</return>
      public Operation ReadFile (  Output filename ,String opName= "ReadFile" ) 
      {
         OperationDescription desc = NewOperation("ReadFile", opName);
         desc.AddInput(filename);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="iterator">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] summary(type: DtString).
      ///</return>
      public Operation StatsAggregatorSummary (  Output iterator ,String opName= "StatsAggregatorSummary" ) 
      {
         OperationDescription desc = NewOperation("StatsAggregatorSummary", opName);
         desc.AddInput(iterator);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="sizes">Input to the operation. </param>
      ///<param name="values">Input to the operation. </param>
      ///<param name="field_names"></param>
      ///<param name="message_type"></param>
      ///<param name="descriptor_source"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] bytes(type: DtString).
      ///</return>
      public Operation EncodeProto (  Output sizes , Output values , string[] field_names, string message_type, string descriptor_source = null ,String opName= "EncodeProto" ) 
      {
         OperationDescription desc = NewOperation("EncodeProto", opName);
         desc.AddInput(sizes);
         desc.AddInput(values);
         desc.SetAttr("field_names", field_names);
         desc.SetAttr("message_type", message_type);
         if (descriptor_source != null) desc.SetAttr("descriptor_source", descriptor_source);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="batch_size">Input to the operation. </param>
      ///<param name="padded_shapes">Input to the operation. </param>
      ///<param name="padding_values">Input to the operation. </param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation PrependFromQueueAndPaddedBatchDataset (  Output input_dataset , Output batch_size , Output padded_shapes , Output padding_values , long[][] output_shapes,String opName= "PrependFromQueueAndPaddedBatchDataset" ) 
      {
         OperationDescription desc = NewOperation("PrependFromQueueAndPaddedBatchDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(batch_size);
         desc.AddInput(padded_shapes);
         desc.AddInput(padding_values);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="overlaps">Input to the operation. </param>
      ///<param name="scores">Input to the operation. </param>
      ///<param name="max_output_size">Input to the operation. </param>
      ///<param name="overlap_threshold">Input to the operation. </param>
      ///<param name="score_threshold">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] selected_indices(type: DtInt32).
      ///</return>
      public Operation NonMaxSuppressionWithOverlaps (  Output overlaps , Output scores , Output max_output_size , Output overlap_threshold , Output score_threshold ,String opName= "NonMaxSuppressionWithOverlaps" ) 
      {
         OperationDescription desc = NewOperation("NonMaxSuppressionWithOverlaps", opName);
         desc.AddInput(overlaps);
         desc.AddInput(scores);
         desc.AddInput(max_output_size);
         desc.AddInput(overlap_threshold);
         desc.AddInput(score_threshold);


         return desc.FinishOperation();
      } 
      // Skipped function _HostCast

      ///<summary>
      ///
      ///</summary>
      ///<param name="queue">Input to the operation. </param>
      ///<param name="components">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation EnqueueInQueueDataset (  Output queue , Output components ,String opName= "EnqueueInQueueDataset" ) 
      {
         OperationDescription desc = NewOperation("EnqueueInQueueDataset", opName);
         desc.AddInput(queue);
         desc.AddInput(components);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_handle">Input to the operation. </param>
      ///<param name="index">Input to the operation. </param>
      ///<param name="element_dtype"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] item(type: DtInvalid).
      ///</return>
      public Operation TensorListGetItem (  Output input_handle , Output index , DataType element_dtype,String opName= "TensorListGetItem" ) 
      {
         OperationDescription desc = NewOperation("TensorListGetItem", opName);
         desc.AddInput(input_handle);
         desc.AddInput(index);
         desc.SetAttr("element_dtype", element_dtype);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="matrix">Input to the operation. </param>
      ///<param name="rhs">Input to the operation. </param>
      ///<param name="adjoint"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation MatrixSolve (  Output matrix , Output rhs , bool adjoint = false ,String opName= "MatrixSolve" ) 
      {
         OperationDescription desc = NewOperation("MatrixSolve", opName);
         desc.AddInput(matrix);
         desc.AddInput(rhs);

         if (adjoint != false) desc.SetAttr("adjoint", adjoint);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="filename">Input to the operation. </param>
      ///<param name="compression_type">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation DatasetToTFRecord (  Output input_dataset , Output filename , Output compression_type ,String opName= "DatasetToTFRecord" ) 
      {
         OperationDescription desc = NewOperation("DatasetToTFRecord", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(filename);
         desc.AddInput(compression_type);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] graph(type: DtString).
      ///</return>
      public Operation DatasetToGraph (  Output input_dataset ,String opName= "DatasetToGraph" ) 
      {
         OperationDescription desc = NewOperation("DatasetToGraph", opName);
         desc.AddInput(input_dataset);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation SinkDataset (  Output input_dataset ,String opName= "SinkDataset" ) 
      {
         OperationDescription desc = NewOperation("SinkDataset", opName);
         desc.AddInput(input_dataset);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_dataset">Input to the operation. </param>
      ///<param name="optimizations">Input to the operation. </param>
      ///<param name="output_types"></param>
      ///<param name="output_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation OptimizeDataset (  Output input_dataset , Output optimizations , DataType[] output_types, long[][] output_shapes,String opName= "OptimizeDataset" ) 
      {
         OperationDescription desc = NewOperation("OptimizeDataset", opName);
         desc.AddInput(input_dataset);
         desc.AddInput(optimizations);
         desc.SetAttr("output_types", output_types);
         desc.SetAttrShapeList("output_shapes", output_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="matrix">Input to the operation. </param>
      ///<param name="rhs">Input to the operation. </param>
      ///<param name="lower"></param>
      ///<param name="adjoint"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation BatchMatrixTriangularSolve (  Output matrix , Output rhs , bool lower = true , bool adjoint = false ,String opName= "BatchMatrixTriangularSolve" ) 
      {
         OperationDescription desc = NewOperation("BatchMatrixTriangularSolve", opName);
         desc.AddInput(matrix);
         desc.AddInput(rhs);

         if (lower != true) desc.SetAttr("lower", lower);
         if (adjoint != false) desc.SetAttr("adjoint", adjoint);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="start">Input to the operation. </param>
      ///<param name="stop">Input to the operation. </param>
      ///<param name="num">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation LinSpace (  Output start , Output stop , Output num ,String opName= "LinSpace" ) 
      {
         OperationDescription desc = NewOperation("LinSpace", opName);
         desc.AddInput(start);
         desc.AddInput(stop);
         desc.AddInput(num);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtBool).
      ///</return>
      public Operation NotEqual (  Output x , Output y ,String opName= "NotEqual" ) 
      {
         OperationDescription desc = NewOperation("NotEqual", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="components">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] optional(type: DtVariant).
      ///</return>
      public Operation OptionalFromValue (  Output components ,String opName= "OptionalFromValue" ) 
      {
         OperationDescription desc = NewOperation("OptionalFromValue", opName);
         desc.AddInput(components);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="bytes">Input to the operation. </param>
      ///<param name="message_type"></param>
      ///<param name="field_names"></param>
      ///<param name="output_types"></param>
      ///<param name="descriptor_source"></param>
      ///<param name="message_format"></param>
      ///<param name="sanitize"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] sizes(type: DtInt32).
      ///[1] values(type: DtInvalid).
      ///</return>
      public Operation DecodeProtoV2 (  Output bytes , string message_type, string[] field_names, DataType[] output_types, string descriptor_source = null , string message_format = null , bool sanitize = false ,String opName= "DecodeProtoV2" ) 
      {
         OperationDescription desc = NewOperation("DecodeProtoV2", opName);
         desc.AddInput(bytes);
         desc.SetAttr("message_type", message_type);
         desc.SetAttr("field_names", field_names);
         desc.SetAttr("output_types", output_types);
         if (descriptor_source != null) desc.SetAttr("descriptor_source", descriptor_source);
         if (message_format != null) desc.SetAttr("message_format", message_format);
         if (sanitize != false) desc.SetAttr("sanitize", sanitize);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="images">Input to the operation. </param>
      ///<param name="size">Input to the operation. </param>
      ///<param name="align_corners"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] resized_images(type: DtFloat).
      ///</return>
      public Operation ResizeBicubic (  Output images , Output size , bool align_corners = false ,String opName= "ResizeBicubic" ) 
      {
         OperationDescription desc = NewOperation("ResizeBicubic", opName);
         desc.AddInput(images);
         desc.AddInput(size);

         if (align_corners != false) desc.SetAttr("align_corners", align_corners);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="predictions">Input to the operation. </param>
      ///<param name="targets">Input to the operation. </param>
      ///<param name="k">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] precision(type: DtBool).
      ///</return>
      public Operation InTopKV2 (  Output predictions , Output targets , Output k ,String opName= "InTopKV2" ) 
      {
         OperationDescription desc = NewOperation("InTopKV2", opName);
         desc.AddInput(predictions);
         desc.AddInput(targets);
         desc.AddInput(k);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="grads">Input to the operation. </param>
      ///<param name="original_image">Input to the operation. </param>
      ///<param name="align_corners"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation ResizeBicubicGrad (  Output grads , Output original_image , bool align_corners = false ,String opName= "ResizeBicubicGrad" ) 
      {
         OperationDescription desc = NewOperation("ResizeBicubicGrad", opName);
         desc.AddInput(grads);
         desc.AddInput(original_image);

         if (align_corners != false) desc.SetAttr("align_corners", align_corners);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="images">Input to the operation. </param>
      ///<param name="size">Input to the operation. </param>
      ///<param name="align_corners"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] resized_images(type: DtFloat).
      ///</return>
      public Operation ResizeBilinear (  Output images , Output size , bool align_corners = false ,String opName= "ResizeBilinear" ) 
      {
         OperationDescription desc = NewOperation("ResizeBilinear", opName);
         desc.AddInput(images);
         desc.AddInput(size);

         if (align_corners != false) desc.SetAttr("align_corners", align_corners);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="block_size"></param>
      ///<param name="data_format"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SpaceToDepth (  Output input , long block_size, string data_format = null ,String opName= "SpaceToDepth" ) 
      {
         OperationDescription desc = NewOperation("SpaceToDepth", opName);
         desc.AddInput(input);
         desc.SetAttr("block_size", block_size);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="num_lower">Input to the operation. </param>
      ///<param name="num_upper">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] band(type: DtInvalid).
      ///</return>
      public Operation MatrixBandPart (  Output input , Output num_lower , Output num_upper ,String opName= "MatrixBandPart" ) 
      {
         OperationDescription desc = NewOperation("MatrixBandPart", opName);
         desc.AddInput(input);
         desc.AddInput(num_lower);
         desc.AddInput(num_upper);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="images">Input to the operation. </param>
      ///<param name="size">Input to the operation. </param>
      ///<param name="min">Input to the operation. </param>
      ///<param name="max">Input to the operation. </param>
      ///<param name="align_corners"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] resized_images(type: DtInvalid).
      ///[1] out_min(type: DtFloat).
      ///[2] out_max(type: DtFloat).
      ///</return>
      public Operation QuantizedResizeBilinear (  Output images , Output size , Output min , Output max , bool align_corners = false ,String opName= "QuantizedResizeBilinear" ) 
      {
         OperationDescription desc = NewOperation("QuantizedResizeBilinear", opName);
         desc.AddInput(images);
         desc.AddInput(size);
         desc.AddInput(min);
         desc.AddInput(max);

         if (align_corners != false) desc.SetAttr("align_corners", align_corners);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="grads">Input to the operation. </param>
      ///<param name="original_image">Input to the operation. </param>
      ///<param name="align_corners"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation ResizeBilinearGrad (  Output grads , Output original_image , bool align_corners = false ,String opName= "ResizeBilinearGrad" ) 
      {
         OperationDescription desc = NewOperation("ResizeBilinearGrad", opName);
         desc.AddInput(grads);
         desc.AddInput(original_image);

         if (align_corners != false) desc.SetAttr("align_corners", align_corners);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="images">Input to the operation. </param>
      ///<param name="size">Input to the operation. </param>
      ///<param name="align_corners"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] resized_images(type: DtInvalid).
      ///</return>
      public Operation ResizeNearestNeighbor (  Output images , Output size , bool align_corners = false ,String opName= "ResizeNearestNeighbor" ) 
      {
         OperationDescription desc = NewOperation("ResizeNearestNeighbor", opName);
         desc.AddInput(images);
         desc.AddInput(size);

         if (align_corners != false) desc.SetAttr("align_corners", align_corners);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="diagonal">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation MatrixDiag (  Output diagonal ,String opName= "MatrixDiag" ) 
      {
         OperationDescription desc = NewOperation("MatrixDiag", opName);
         desc.AddInput(diagonal);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reference">Input to the operation. </param>
      ///<param name="value">Input to the operation. </param>
      ///<param name="validate_shape"></param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_ref(type: DtInvalid).
      ///</return>
      public Operation Assign (  Output reference , Output value , bool validate_shape = true , bool use_locking = true ,String opName= "Assign" ) 
      {
         OperationDescription desc = NewOperation("Assign", opName);
         desc.AddInput(reference);
         desc.AddInput(value);

         if (validate_shape != true) desc.SetAttr("validate_shape", validate_shape);
         if (use_locking != true) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="element_shape">Input to the operation. </param>
      ///<param name="num_elements">Input to the operation. </param>
      ///<param name="element_dtype"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] handle(type: DtVariant).
      ///</return>
      public Operation TensorListReserve (  Output element_shape , Output num_elements , DataType element_dtype,String opName= "TensorListReserve" ) 
      {
         OperationDescription desc = NewOperation("TensorListReserve", opName);
         desc.AddInput(element_shape);
         desc.AddInput(num_elements);
         desc.SetAttr("element_dtype", element_dtype);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="image">Input to the operation. </param>
      ///<param name="size">Input to the operation. </param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation RandomCrop (  Output image , Output size , long seed = 0 , long seed2 = 0 ,String opName= "RandomCrop" ) 
      {
         OperationDescription desc = NewOperation("RandomCrop", opName);
         desc.AddInput(image);
         desc.AddInput(size);

         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="image">Input to the operation. </param>
      ///<param name="format"></param>
      ///<param name="quality"></param>
      ///<param name="progressive"></param>
      ///<param name="optimize_size"></param>
      ///<param name="chroma_downsampling"></param>
      ///<param name="density_unit"></param>
      ///<param name="x_density"></param>
      ///<param name="y_density"></param>
      ///<param name="xmp_metadata"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] contents(type: DtString).
      ///</return>
      public Operation EncodeJpeg (  Output image , string format = null , long quality = 95 , bool progressive = false , bool optimize_size = false , bool chroma_downsampling = true , string density_unit = null , long x_density = 300 , long y_density = 300 , string xmp_metadata = null ,String opName= "EncodeJpeg" ) 
      {
         OperationDescription desc = NewOperation("EncodeJpeg", opName);
         desc.AddInput(image);

         if (format != null) desc.SetAttr("format", format);
         if (quality != 95) desc.SetAttr("quality", quality);
         if (progressive != false) desc.SetAttr("progressive", progressive);
         if (optimize_size != false) desc.SetAttr("optimize_size", optimize_size);
         if (chroma_downsampling != true) desc.SetAttr("chroma_downsampling", chroma_downsampling);
         if (density_unit != null) desc.SetAttr("density_unit", density_unit);
         if (x_density != 300) desc.SetAttr("x_density", x_density);
         if (y_density != 300) desc.SetAttr("y_density", y_density);
         if (xmp_metadata != null) desc.SetAttr("xmp_metadata", xmp_metadata);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="contents">Input to the operation. </param>
      ///<param name="output_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] image_shape(type: DtInvalid).
      ///</return>
      public Operation ExtractJpegShape (  Output contents , DataType? output_type = null ,String opName= "ExtractJpegShape" ) 
      {
         OperationDescription desc = NewOperation("ExtractJpegShape", opName);
         desc.AddInput(contents);

         if (output_type.HasValue) desc.SetAttr("output_type", output_type.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation BesselI1e (  Output x ,String opName= "BesselI1e" ) 
      {
         OperationDescription desc = NewOperation("BesselI1e", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="images">Input to the operation. </param>
      ///<param name="contrast_factor">Input to the operation. </param>
      ///<param name="min_value">Input to the operation. </param>
      ///<param name="max_value">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtFloat).
      ///</return>
      public Operation AdjustContrast (  Output images , Output contrast_factor , Output min_value , Output max_value ,String opName= "AdjustContrast" ) 
      {
         OperationDescription desc = NewOperation("AdjustContrast", opName);
         desc.AddInput(images);
         desc.AddInput(contrast_factor);
         desc.AddInput(min_value);
         desc.AddInput(max_value);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="images">Input to the operation. </param>
      ///<param name="delta">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtFloat).
      ///</return>
      public Operation AdjustHue (  Output images , Output delta ,String opName= "AdjustHue" ) 
      {
         OperationDescription desc = NewOperation("AdjustHue", opName);
         desc.AddInput(images);
         desc.AddInput(delta);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="images">Input to the operation. </param>
      ///<param name="scale">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtFloat).
      ///</return>
      public Operation AdjustSaturation (  Output images , Output scale ,String opName= "AdjustSaturation" ) 
      {
         OperationDescription desc = NewOperation("AdjustSaturation", opName);
         desc.AddInput(images);
         desc.AddInput(scale);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="axis">Input to the operation. </param>
      ///<param name="out_idx"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///[1] idx(type: DtInvalid).
      ///[2] count(type: DtInvalid).
      ///</return>
      public Operation UniqueWithCountsV2 (  Output x , Output axis , DataType? out_idx = null ,String opName= "UniqueWithCountsV2" ) 
      {
         OperationDescription desc = NewOperation("UniqueWithCountsV2", opName);
         desc.AddInput(x);
         desc.AddInput(axis);

         if (out_idx.HasValue) desc.SetAttr("out_idx", out_idx.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="image">Input to the operation. </param>
      ///<param name="compression"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] contents(type: DtString).
      ///</return>
      public Operation EncodePng (  Output image , long compression = -1 ,String opName= "EncodePng" ) 
      {
         OperationDescription desc = NewOperation("EncodePng", opName);
         desc.AddInput(image);

         if (compression != -1) desc.SetAttr("compression", compression);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="contents">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] image(type: DtUint8).
      ///</return>
      public Operation DecodeGif (  Output contents ,String opName= "DecodeGif" ) 
      {
         OperationDescription desc = NewOperation("DecodeGif", opName);
         desc.AddInput(contents);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="images">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation HSVToRGB (  Output images ,String opName= "HSVToRGB" ) 
      {
         OperationDescription desc = NewOperation("HSVToRGB", opName);
         desc.AddInput(images);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="images">Input to the operation. </param>
      ///<param name="boxes">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation DrawBoundingBoxes (  Output images , Output boxes ,String opName= "DrawBoundingBoxes" ) 
      {
         OperationDescription desc = NewOperation("DrawBoundingBoxes", opName);
         desc.AddInput(images);
         desc.AddInput(boxes);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] reader_handle(type: DtResource).
      ///</return>
      public Operation IdentityReaderV2 (  string container = null , string shared_name = null ,String opName= "IdentityReaderV2" ) 
      {
         OperationDescription desc = NewOperation("IdentityReaderV2", opName);


         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="image_size">Input to the operation. </param>
      ///<param name="bounding_boxes">Input to the operation. </param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="min_object_covered"></param>
      ///<param name="aspect_ratio_range"></param>
      ///<param name="area_range"></param>
      ///<param name="max_attempts"></param>
      ///<param name="use_image_if_no_bounding_boxes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] begin(type: DtInvalid).
      ///[1] size(type: DtInvalid).
      ///[2] bboxes(type: DtFloat).
      ///</return>
      public Operation SampleDistortedBoundingBox (  Output image_size , Output bounding_boxes , long seed = 0 , long seed2 = 0 , float min_object_covered = 0.1f , float[] aspect_ratio_range = null , float[] area_range = null , long max_attempts = 100 , bool use_image_if_no_bounding_boxes = false ,String opName= "SampleDistortedBoundingBox" ) 
      {
         OperationDescription desc = NewOperation("SampleDistortedBoundingBox", opName);
         desc.AddInput(image_size);
         desc.AddInput(bounding_boxes);

         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         if (min_object_covered != 0.1f) desc.SetAttr("min_object_covered", min_object_covered);
         if (aspect_ratio_range != null) desc.SetAttr("aspect_ratio_range", aspect_ratio_range);
         if (area_range != null) desc.SetAttr("area_range", area_range);
         if (max_attempts != 100) desc.SetAttr("max_attempts", max_attempts);
         if (use_image_if_no_bounding_boxes != false) desc.SetAttr("use_image_if_no_bounding_boxes", use_image_if_no_bounding_boxes);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="inputs">Input to the operation. </param>
      ///<param name="min"></param>
      ///<param name="max"></param>
      ///<param name="num_bits"></param>
      ///<param name="narrow_range"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] outputs(type: DtFloat).
      ///</return>
      public Operation FakeQuantWithMinMaxArgs (  Output inputs , float min = -6f , float max = 6f , long num_bits = 8 , bool narrow_range = false ,String opName= "FakeQuantWithMinMaxArgs" ) 
      {
         OperationDescription desc = NewOperation("FakeQuantWithMinMaxArgs", opName);
         desc.AddInput(inputs);

         if (min != -6f) desc.SetAttr("min", min);
         if (max != 6f) desc.SetAttr("max", max);
         if (num_bits != 8) desc.SetAttr("num_bits", num_bits);
         if (narrow_range != false) desc.SetAttr("narrow_range", narrow_range);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="image_size">Input to the operation. </param>
      ///<param name="bounding_boxes">Input to the operation. </param>
      ///<param name="min_object_covered">Input to the operation. </param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="aspect_ratio_range"></param>
      ///<param name="area_range"></param>
      ///<param name="max_attempts"></param>
      ///<param name="use_image_if_no_bounding_boxes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] begin(type: DtInvalid).
      ///[1] size(type: DtInvalid).
      ///[2] bboxes(type: DtFloat).
      ///</return>
      public Operation SampleDistortedBoundingBoxV2 (  Output image_size , Output bounding_boxes , Output min_object_covered , long seed = 0 , long seed2 = 0 , float[] aspect_ratio_range = null , float[] area_range = null , long max_attempts = 100 , bool use_image_if_no_bounding_boxes = false ,String opName= "SampleDistortedBoundingBoxV2" ) 
      {
         OperationDescription desc = NewOperation("SampleDistortedBoundingBoxV2", opName);
         desc.AddInput(image_size);
         desc.AddInput(bounding_boxes);
         desc.AddInput(min_object_covered);

         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         if (aspect_ratio_range != null) desc.SetAttr("aspect_ratio_range", aspect_ratio_range);
         if (area_range != null) desc.SetAttr("area_range", area_range);
         if (max_attempts != 100) desc.SetAttr("max_attempts", max_attempts);
         if (use_image_if_no_bounding_boxes != false) desc.SetAttr("use_image_if_no_bounding_boxes", use_image_if_no_bounding_boxes);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reader_handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] state(type: DtString).
      ///</return>
      public Operation ReaderSerializeState (  Output reader_handle ,String opName= "ReaderSerializeState" ) 
      {
         OperationDescription desc = NewOperation("ReaderSerializeState", opName);
         desc.AddInput(reader_handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="size">Input to the operation. </param>
      ///<param name="offsets">Input to the operation. </param>
      ///<param name="centered"></param>
      ///<param name="normalized"></param>
      ///<param name="uniform_noise"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] glimpse(type: DtFloat).
      ///</return>
      public Operation ExtractGlimpse (  Output input , Output size , Output offsets , bool centered = true , bool normalized = true , bool uniform_noise = true ,String opName= "ExtractGlimpse" ) 
      {
         OperationDescription desc = NewOperation("ExtractGlimpse", opName);
         desc.AddInput(input);
         desc.AddInput(size);
         desc.AddInput(offsets);

         if (centered != true) desc.SetAttr("centered", centered);
         if (normalized != true) desc.SetAttr("normalized", normalized);
         if (uniform_noise != true) desc.SetAttr("uniform_noise", uniform_noise);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtBool).
      ///</return>
      public Operation IsInf (  Output x ,String opName= "IsInf" ) 
      {
         OperationDescription desc = NewOperation("IsInf", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="image">Input to the operation. </param>
      ///<param name="boxes">Input to the operation. </param>
      ///<param name="box_ind">Input to the operation. </param>
      ///<param name="crop_size">Input to the operation. </param>
      ///<param name="method"></param>
      ///<param name="extrapolation_value"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] crops(type: DtFloat).
      ///</return>
      public Operation CropAndResize (  Output image , Output boxes , Output box_ind , Output crop_size , string method = null , float extrapolation_value = 0f ,String opName= "CropAndResize" ) 
      {
         OperationDescription desc = NewOperation("CropAndResize", opName);
         desc.AddInput(image);
         desc.AddInput(boxes);
         desc.AddInput(box_ind);
         desc.AddInput(crop_size);

         if (method != null) desc.SetAttr("method", method);
         if (extrapolation_value != 0f) desc.SetAttr("extrapolation_value", extrapolation_value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="prefix">Input to the operation. </param>
      ///<param name="tensor_names">Input to the operation. </param>
      ///<param name="shape_and_slices">Input to the operation. </param>
      ///<param name="tensors">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation SaveV2 (  Output prefix , Output tensor_names , Output shape_and_slices , Output tensors ,String opName= "SaveV2" ) 
      {
         OperationDescription desc = NewOperation("SaveV2", opName);
         desc.AddInput(prefix);
         desc.AddInput(tensor_names);
         desc.AddInput(shape_and_slices);
         desc.AddInput(tensors);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="key_dtype"></param>
      ///<param name="value_dtype"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="use_node_name_sharing"></param>
      ///<param name="value_shape"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] table_handle(type: DtResource).
      ///</return>
      public Operation MutableHashTableOfTensorsV2 (  DataType key_dtype, DataType value_dtype, string container = null , string shared_name = null , bool use_node_name_sharing = false , long[] value_shape = null ,String opName= "MutableHashTableOfTensorsV2" ) 
      {
         OperationDescription desc = NewOperation("MutableHashTableOfTensorsV2", opName);

         desc.SetAttr("key_dtype", key_dtype);
         desc.SetAttr("value_dtype", value_dtype);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         if (use_node_name_sharing != false) desc.SetAttr("use_node_name_sharing", use_node_name_sharing);
         if (value_shape != null) desc.SetAttrShape("value_shape", value_shape);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="grads">Input to the operation. </param>
      ///<param name="boxes">Input to the operation. </param>
      ///<param name="box_ind">Input to the operation. </param>
      ///<param name="image_size">Input to the operation. </param>
      ///<param name="T"></param>
      ///<param name="method"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation CropAndResizeGradImage (  Output grads , Output boxes , Output box_ind , Output image_size , DataType T, string method = null ,String opName= "CropAndResizeGradImage" ) 
      {
         OperationDescription desc = NewOperation("CropAndResizeGradImage", opName);
         desc.AddInput(grads);
         desc.AddInput(boxes);
         desc.AddInput(box_ind);
         desc.AddInput(image_size);
         desc.SetAttr("T", T);
         if (method != null) desc.SetAttr("method", method);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="compression_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] reader_handle(type: DtResource).
      ///</return>
      public Operation TFRecordReaderV2 (  string container = null , string shared_name = null , string compression_type = null ,String opName= "TFRecordReaderV2" ) 
      {
         OperationDescription desc = NewOperation("TFRecordReaderV2", opName);


         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         if (compression_type != null) desc.SetAttr("compression_type", compression_type);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Atanh (  Output x ,String opName= "Atanh" ) 
      {
         OperationDescription desc = NewOperation("Atanh", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="boxes">Input to the operation. </param>
      ///<param name="scores">Input to the operation. </param>
      ///<param name="max_output_size">Input to the operation. </param>
      ///<param name="iou_threshold"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] selected_indices(type: DtInt32).
      ///</return>
      public Operation NonMaxSuppression (  Output boxes , Output scores , Output max_output_size , float iou_threshold = 0.5f ,String opName= "NonMaxSuppression" ) 
      {
         OperationDescription desc = NewOperation("NonMaxSuppression", opName);
         desc.AddInput(boxes);
         desc.AddInput(scores);
         desc.AddInput(max_output_size);

         if (iou_threshold != 0.5f) desc.SetAttr("iou_threshold", iou_threshold);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="grads">Input to the operation. </param>
      ///<param name="image">Input to the operation. </param>
      ///<param name="boxes">Input to the operation. </param>
      ///<param name="box_ind">Input to the operation. </param>
      ///<param name="method"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtFloat).
      ///</return>
      public Operation CropAndResizeGradBoxes (  Output grads , Output image , Output boxes , Output box_ind , string method = null ,String opName= "CropAndResizeGradBoxes" ) 
      {
         OperationDescription desc = NewOperation("CropAndResizeGradBoxes", opName);
         desc.AddInput(grads);
         desc.AddInput(image);
         desc.AddInput(boxes);
         desc.AddInput(box_ind);

         if (method != null) desc.SetAttr("method", method);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="boxes">Input to the operation. </param>
      ///<param name="scores">Input to the operation. </param>
      ///<param name="max_output_size">Input to the operation. </param>
      ///<param name="iou_threshold">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] selected_indices(type: DtInt32).
      ///</return>
      public Operation NonMaxSuppressionV2 (  Output boxes , Output scores , Output max_output_size , Output iou_threshold ,String opName= "NonMaxSuppressionV2" ) 
      {
         OperationDescription desc = NewOperation("NonMaxSuppressionV2", opName);
         desc.AddInput(boxes);
         desc.AddInput(scores);
         desc.AddInput(max_output_size);
         desc.AddInput(iou_threshold);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="begin">Input to the operation. </param>
      ///<param name="size">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Slice (  Output input , Output begin , Output size ,String opName= "Slice" ) 
      {
         OperationDescription desc = NewOperation("Slice", opName);
         desc.AddInput(input);
         desc.AddInput(begin);
         desc.AddInput(size);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="boxes">Input to the operation. </param>
      ///<param name="scores">Input to the operation. </param>
      ///<param name="max_output_size">Input to the operation. </param>
      ///<param name="iou_threshold">Input to the operation. </param>
      ///<param name="score_threshold">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] selected_indices(type: DtInt32).
      ///</return>
      public Operation NonMaxSuppressionV3 (  Output boxes , Output scores , Output max_output_size , Output iou_threshold , Output score_threshold ,String opName= "NonMaxSuppressionV3" ) 
      {
         OperationDescription desc = NewOperation("NonMaxSuppressionV3", opName);
         desc.AddInput(boxes);
         desc.AddInput(scores);
         desc.AddInput(max_output_size);
         desc.AddInput(iou_threshold);
         desc.AddInput(score_threshold);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="boxes">Input to the operation. </param>
      ///<param name="scores">Input to the operation. </param>
      ///<param name="max_output_size">Input to the operation. </param>
      ///<param name="iou_threshold">Input to the operation. </param>
      ///<param name="score_threshold">Input to the operation. </param>
      ///<param name="pad_to_max_output_size"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] selected_indices(type: DtInt32).
      ///[1] valid_outputs(type: DtInt32).
      ///</return>
      public Operation NonMaxSuppressionV4 (  Output boxes , Output scores , Output max_output_size , Output iou_threshold , Output score_threshold , bool pad_to_max_output_size = false ,String opName= "NonMaxSuppressionV4" ) 
      {
         OperationDescription desc = NewOperation("NonMaxSuppressionV4", opName);
         desc.AddInput(boxes);
         desc.AddInput(scores);
         desc.AddInput(max_output_size);
         desc.AddInput(iou_threshold);
         desc.AddInput(score_threshold);

         if (pad_to_max_output_size != false) desc.SetAttr("pad_to_max_output_size", pad_to_max_output_size);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="segment_ids">Input to the operation. </param>
      ///<param name="num_segments">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation UnsortedSegmentMin (  Output data , Output segment_ids , Output num_segments ,String opName= "UnsortedSegmentMin" ) 
      {
         OperationDescription desc = NewOperation("UnsortedSegmentMin", opName);
         desc.AddInput(data);
         desc.AddInput(segment_ids);
         desc.AddInput(num_segments);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="filter_sizes">Input to the operation. </param>
      ///<param name="out_backprop">Input to the operation. </param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="data_format"></param>
      ///<param name="dilations"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Conv3DBackpropFilterV2 (  Output input , Output filter_sizes , Output out_backprop , long[] strides, string padding, string data_format = null , long[] dilations = null ,String opName= "Conv3DBackpropFilterV2" ) 
      {
         OperationDescription desc = NewOperation("Conv3DBackpropFilterV2", opName);
         desc.AddInput(input);
         desc.AddInput(filter_sizes);
         desc.AddInput(out_backprop);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         if (dilations != null) desc.SetAttr("dilations", dilations);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="filename">Input to the operation. </param>
      ///<param name="tensor_names">Input to the operation. </param>
      ///<param name="data">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation Save (  Output filename , Output tensor_names , Output data ,String opName= "Save" ) 
      {
         OperationDescription desc = NewOperation("Save", opName);
         desc.AddInput(filename);
         desc.AddInput(tensor_names);
         desc.AddInput(data);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="key_dtype"></param>
      ///<param name="value_dtype"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="use_node_name_sharing"></param>
      ///<param name="value_shape"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] table_handle(type: DtString).
      ///</return>
      public Operation MutableHashTableOfTensors (  DataType key_dtype, DataType value_dtype, string container = null , string shared_name = null , bool use_node_name_sharing = false , long[] value_shape = null ,String opName= "MutableHashTableOfTensors" ) 
      {
         OperationDescription desc = NewOperation("MutableHashTableOfTensors", opName);

         desc.SetAttr("key_dtype", key_dtype);
         desc.SetAttr("value_dtype", value_dtype);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         if (use_node_name_sharing != false) desc.SetAttr("use_node_name_sharing", use_node_name_sharing);
         if (value_shape != null) desc.SetAttrShape("value_shape", value_shape);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="k">Input to the operation. </param>
      ///<param name="sorted"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] values(type: DtInvalid).
      ///[1] indices(type: DtInt32).
      ///</return>
      public Operation TopKV2 (  Output input , Output k , bool sorted = true ,String opName= "TopKV2" ) 
      {
         OperationDescription desc = NewOperation("TopKV2", opName);
         desc.AddInput(input);
         desc.AddInput(k);

         if (sorted != true) desc.SetAttr("sorted", sorted);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="file_pattern">Input to the operation. </param>
      ///<param name="tensor_name">Input to the operation. </param>
      ///<param name="dt"></param>
      ///<param name="preferred_shard"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] tensor(type: DtInvalid).
      ///</return>
      public Operation Restore (  Output file_pattern , Output tensor_name , DataType dt, long preferred_shard = -1 ,String opName= "Restore" ) 
      {
         OperationDescription desc = NewOperation("Restore", opName);
         desc.AddInput(file_pattern);
         desc.AddInput(tensor_name);
         desc.SetAttr("dt", dt);
         if (preferred_shard != -1) desc.SetAttr("preferred_shard", preferred_shard);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="features">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] activations(type: DtInvalid).
      ///</return>
      public Operation Softplus (  Output features ,String opName= "Softplus" ) 
      {
         OperationDescription desc = NewOperation("Softplus", opName);
         desc.AddInput(features);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation StopGradient (  Output input ,String opName= "StopGradient" ) 
      {
         OperationDescription desc = NewOperation("StopGradient", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="file_pattern">Input to the operation. </param>
      ///<param name="tensor_name">Input to the operation. </param>
      ///<param name="shape_and_slice">Input to the operation. </param>
      ///<param name="dt"></param>
      ///<param name="preferred_shard"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] tensor(type: DtInvalid).
      ///</return>
      public Operation RestoreSlice (  Output file_pattern , Output tensor_name , Output shape_and_slice , DataType dt, long preferred_shard = -1 ,String opName= "RestoreSlice" ) 
      {
         OperationDescription desc = NewOperation("RestoreSlice", opName);
         desc.AddInput(file_pattern);
         desc.AddInput(tensor_name);
         desc.AddInput(shape_and_slice);
         desc.SetAttr("dt", dt);
         if (preferred_shard != -1) desc.SetAttr("preferred_shard", preferred_shard);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="basename">Input to the operation. </param>
      ///<param name="shard">Input to the operation. </param>
      ///<param name="num_shards">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] filename(type: DtString).
      ///</return>
      public Operation ShardedFilename (  Output basename , Output shard , Output num_shards ,String opName= "ShardedFilename" ) 
      {
         OperationDescription desc = NewOperation("ShardedFilename", opName);
         desc.AddInput(basename);
         desc.AddInput(shard);
         desc.AddInput(num_shards);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="value">Input to the operation. </param>
      ///<param name="bias">Input to the operation. </param>
      ///<param name="data_format"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation BiasAdd (  Output value , Output bias , string data_format = null ,String opName= "BiasAdd" ) 
      {
         OperationDescription desc = NewOperation("BiasAdd", opName);
         desc.AddInput(value);
         desc.AddInput(bias);

         if (data_format != null) desc.SetAttr("data_format", data_format);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="basename">Input to the operation. </param>
      ///<param name="num_shards">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] filename(type: DtString).
      ///</return>
      public Operation ShardedFilespec (  Output basename , Output num_shards ,String opName= "ShardedFilespec" ) 
      {
         OperationDescription desc = NewOperation("ShardedFilespec", opName);
         desc.AddInput(basename);
         desc.AddInput(num_shards);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="gradients">Input to the operation. </param>
      ///<param name="features">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] backprops(type: DtInvalid).
      ///</return>
      public Operation Relu6Grad (  Output gradients , Output features ,String opName= "Relu6Grad" ) 
      {
         OperationDescription desc = NewOperation("Relu6Grad", opName);
         desc.AddInput(gradients);
         desc.AddInput(features);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="updates">Input to the operation. </param>
      ///<param name="shape">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation ScatterNd (  Output indices , Output updates , Output shape ,String opName= "ScatterNd" ) 
      {
         OperationDescription desc = NewOperation("ScatterNd", opName);
         desc.AddInput(indices);
         desc.AddInput(updates);
         desc.AddInput(shape);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="skip_header_lines"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] reader_handle(type: DtResource).
      ///</return>
      public Operation TextLineReaderV2 (  long skip_header_lines = 0 , string container = null , string shared_name = null ,String opName= "TextLineReaderV2" ) 
      {
         OperationDescription desc = NewOperation("TextLineReaderV2", opName);


         if (skip_header_lines != 0) desc.SetAttr("skip_header_lines", skip_header_lines);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_handle">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="element_dtype"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] values(type: DtInvalid).
      ///</return>
      public Operation TensorListGather (  Output input_handle , Output indices , DataType element_dtype,String opName= "TensorListGather" ) 
      {
         OperationDescription desc = NewOperation("TensorListGather", opName);
         desc.AddInput(input_handle);
         desc.AddInput(indices);
         desc.SetAttr("element_dtype", element_dtype);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="paddings">Input to the operation. </param>
      ///<param name="mode"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation MirrorPad (  Output input , Output paddings , string mode,String opName= "MirrorPad" ) 
      {
         OperationDescription desc = NewOperation("MirrorPad", opName);
         desc.AddInput(input);
         desc.AddInput(paddings);
         desc.SetAttr("mode", mode);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="record_bytes"></param>
      ///<param name="header_bytes"></param>
      ///<param name="footer_bytes"></param>
      ///<param name="hop_bytes"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] reader_handle(type: DtString).
      ///</return>
      public Operation FixedLengthRecordReader (  long record_bytes, long header_bytes = 0 , long footer_bytes = 0 , long hop_bytes = 0 , string container = null , string shared_name = null ,String opName= "FixedLengthRecordReader" ) 
      {
         OperationDescription desc = NewOperation("FixedLengthRecordReader", opName);

         desc.SetAttr("record_bytes", record_bytes);
         if (header_bytes != 0) desc.SetAttr("header_bytes", header_bytes);
         if (footer_bytes != 0) desc.SetAttr("footer_bytes", footer_bytes);
         if (hop_bytes != 0) desc.SetAttr("hop_bytes", hop_bytes);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="compression_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] reader_handle(type: DtString).
      ///</return>
      public Operation TFRecordReader (  string container = null , string shared_name = null , string compression_type = null ,String opName= "TFRecordReader" ) 
      {
         OperationDescription desc = NewOperation("TFRecordReader", opName);


         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         if (compression_type != null) desc.SetAttr("compression_type", compression_type);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="values">Input to the operation. </param>
      ///<param name="axis">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation ConcatV2 (  Output values , Output axis ,String opName= "ConcatV2" ) 
      {
         OperationDescription desc = NewOperation("ConcatV2", opName);
         desc.AddInput(values);
         desc.AddInput(axis);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="split_dim">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="values">Input to the operation. </param>
      ///<param name="shape">Input to the operation. </param>
      ///<param name="num_split"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_indices(type: DtInt64).
      ///[1] output_values(type: DtInvalid).
      ///[2] output_shape(type: DtInt64).
      ///</return>
      public Operation SparseSplit (  Output split_dim , Output indices , Output values , Output shape , long num_split,String opName= "SparseSplit" ) 
      {
         OperationDescription desc = NewOperation("SparseSplit", opName);
         desc.AddInput(split_dim);
         desc.AddInput(indices);
         desc.AddInput(values);
         desc.AddInput(shape);
         desc.SetAttr("num_split", num_split);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] reader_handle(type: DtString).
      ///</return>
      public Operation LMDBReader (  string container = null , string shared_name = null ,String opName= "LMDBReader" ) 
      {
         OperationDescription desc = NewOperation("LMDBReader", opName);


         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reader_handle">Input to the operation. </param>
      ///<param name="queue_handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] key(type: DtString).
      ///[1] value(type: DtString).
      ///</return>
      public Operation ReaderRead (  Output reader_handle , Output queue_handle ,String opName= "ReaderRead" ) 
      {
         OperationDescription desc = NewOperation("ReaderRead", opName);
         desc.AddInput(reader_handle);
         desc.AddInput(queue_handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="orig_input_shape">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="ksize"></param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="data_format"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation AvgPool3DGrad (  Output orig_input_shape , Output grad , long[] ksize, long[] strides, string padding, string data_format = null ,String opName= "AvgPool3DGrad" ) 
      {
         OperationDescription desc = NewOperation("AvgPool3DGrad", opName);
         desc.AddInput(orig_input_shape);
         desc.AddInput(grad);
         desc.SetAttr("ksize", ksize);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reader_handle">Input to the operation. </param>
      ///<param name="queue_handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] key(type: DtString).
      ///[1] value(type: DtString).
      ///</return>
      public Operation ReaderReadV2 (  Output reader_handle , Output queue_handle ,String opName= "ReaderReadV2" ) 
      {
         OperationDescription desc = NewOperation("ReaderReadV2", opName);
         desc.AddInput(reader_handle);
         desc.AddInput(queue_handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="shape">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="init"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Empty (  Output shape , DataType dtype, bool init = false ,String opName= "Empty" ) 
      {
         OperationDescription desc = NewOperation("Empty", opName);
         desc.AddInput(shape);
         desc.SetAttr("dtype", dtype);
         if (init != false) desc.SetAttr("init", init);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="begin">Input to the operation. </param>
      ///<param name="end">Input to the operation. </param>
      ///<param name="strides">Input to the operation. </param>
      ///<param name="begin_mask"></param>
      ///<param name="end_mask"></param>
      ///<param name="ellipsis_mask"></param>
      ///<param name="new_axis_mask"></param>
      ///<param name="shrink_axis_mask"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation StridedSlice (  Output input , Output begin , Output end , Output strides , long begin_mask = 0 , long end_mask = 0 , long ellipsis_mask = 0 , long new_axis_mask = 0 , long shrink_axis_mask = 0 ,String opName= "StridedSlice" ) 
      {
         OperationDescription desc = NewOperation("StridedSlice", opName);
         desc.AddInput(input);
         desc.AddInput(begin);
         desc.AddInput(end);
         desc.AddInput(strides);

         if (begin_mask != 0) desc.SetAttr("begin_mask", begin_mask);
         if (end_mask != 0) desc.SetAttr("end_mask", end_mask);
         if (ellipsis_mask != 0) desc.SetAttr("ellipsis_mask", ellipsis_mask);
         if (new_axis_mask != 0) desc.SetAttr("new_axis_mask", new_axis_mask);
         if (shrink_axis_mask != 0) desc.SetAttr("shrink_axis_mask", shrink_axis_mask);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reader_handle">Input to the operation. </param>
      ///<param name="queue_handle">Input to the operation. </param>
      ///<param name="num_records">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] keys(type: DtString).
      ///[1] values(type: DtString).
      ///</return>
      public Operation ReaderReadUpToV2 (  Output reader_handle , Output queue_handle , Output num_records ,String opName= "ReaderReadUpToV2" ) 
      {
         OperationDescription desc = NewOperation("ReaderReadUpToV2", opName);
         desc.AddInput(reader_handle);
         desc.AddInput(queue_handle);
         desc.AddInput(num_records);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reader_handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] records_produced(type: DtInt64).
      ///</return>
      public Operation ReaderNumRecordsProduced (  Output reader_handle ,String opName= "ReaderNumRecordsProduced" ) 
      {
         OperationDescription desc = NewOperation("ReaderNumRecordsProduced", opName);
         desc.AddInput(reader_handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reader_handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] units_completed(type: DtInt64).
      ///</return>
      public Operation ReaderNumWorkUnitsCompleted (  Output reader_handle ,String opName= "ReaderNumWorkUnitsCompleted" ) 
      {
         OperationDescription desc = NewOperation("ReaderNumWorkUnitsCompleted", opName);
         desc.AddInput(reader_handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] sign(type: DtInvalid).
      ///[1] log_abs_determinant(type: DtInvalid).
      ///</return>
      public Operation LogMatrixDeterminant (  Output input ,String opName= "LogMatrixDeterminant" ) 
      {
         OperationDescription desc = NewOperation("LogMatrixDeterminant", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reader_handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] units_completed(type: DtInt64).
      ///</return>
      public Operation ReaderNumWorkUnitsCompletedV2 (  Output reader_handle ,String opName= "ReaderNumWorkUnitsCompletedV2" ) 
      {
         OperationDescription desc = NewOperation("ReaderNumWorkUnitsCompletedV2", opName);
         desc.AddInput(reader_handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reader_handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] state(type: DtString).
      ///</return>
      public Operation ReaderSerializeStateV2 (  Output reader_handle ,String opName= "ReaderSerializeStateV2" ) 
      {
         OperationDescription desc = NewOperation("ReaderSerializeStateV2", opName);
         desc.AddInput(reader_handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reader_handle">Input to the operation. </param>
      ///<param name="state">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation ReaderRestoreState (  Output reader_handle , Output state ,String opName= "ReaderRestoreState" ) 
      {
         OperationDescription desc = NewOperation("ReaderRestoreState", opName);
         desc.AddInput(reader_handle);
         desc.AddInput(state);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="multiples">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation TileGrad (  Output input , Output multiples ,String opName= "TileGrad" ) 
      {
         OperationDescription desc = NewOperation("TileGrad", opName);
         desc.AddInput(input);
         desc.AddInput(multiples);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="resource">Input to the operation. </param>
      ///<param name="value">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation AssignSubVariableOp (  Output resource , Output value ,String opName= "AssignSubVariableOp" ) 
      {
         OperationDescription desc = NewOperation("AssignSubVariableOp", opName);
         desc.AddInput(resource);
         desc.AddInput(value);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reader_handle">Input to the operation. </param>
      ///<param name="state">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation ReaderRestoreStateV2 (  Output reader_handle , Output state ,String opName= "ReaderRestoreStateV2" ) 
      {
         OperationDescription desc = NewOperation("ReaderRestoreStateV2", opName);
         desc.AddInput(reader_handle);
         desc.AddInput(state);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reader_handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation ReaderReset (  Output reader_handle ,String opName= "ReaderReset" ) 
      {
         OperationDescription desc = NewOperation("ReaderReset", opName);
         desc.AddInput(reader_handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="logits">Input to the operation. </param>
      ///<param name="num_samples">Input to the operation. </param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="output_dtype"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Multinomial (  Output logits , Output num_samples , long seed = 0 , long seed2 = 0 , DataType? output_dtype = null ,String opName= "Multinomial" ) 
      {
         OperationDescription desc = NewOperation("Multinomial", opName);
         desc.AddInput(logits);
         desc.AddInput(num_samples);

         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         if (output_dtype.HasValue) desc.SetAttr("output_dtype", output_dtype.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="filename">Input to the operation. </param>
      ///<param name="contents">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation WriteFile (  Output filename , Output contents ,String opName= "WriteFile" ) 
      {
         OperationDescription desc = NewOperation("WriteFile", opName);
         desc.AddInput(filename);
         desc.AddInput(contents);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation IFFT2D (  Output input ,String opName= "IFFT2D" ) 
      {
         OperationDescription desc = NewOperation("IFFT2D", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reference">Input to the operation. </param>
      ///<param name="begin">Input to the operation. </param>
      ///<param name="end">Input to the operation. </param>
      ///<param name="strides">Input to the operation. </param>
      ///<param name="value">Input to the operation. </param>
      ///<param name="begin_mask"></param>
      ///<param name="end_mask"></param>
      ///<param name="ellipsis_mask"></param>
      ///<param name="new_axis_mask"></param>
      ///<param name="shrink_axis_mask"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceStridedSliceAssign (  Output reference , Output begin , Output end , Output strides , Output value , long begin_mask = 0 , long end_mask = 0 , long ellipsis_mask = 0 , long new_axis_mask = 0 , long shrink_axis_mask = 0 ,String opName= "ResourceStridedSliceAssign" ) 
      {
         OperationDescription desc = NewOperation("ResourceStridedSliceAssign", opName);
         desc.AddInput(reference);
         desc.AddInput(begin);
         desc.AddInput(end);
         desc.AddInput(strides);
         desc.AddInput(value);

         if (begin_mask != 0) desc.SetAttr("begin_mask", begin_mask);
         if (end_mask != 0) desc.SetAttr("end_mask", end_mask);
         if (ellipsis_mask != 0) desc.SetAttr("ellipsis_mask", ellipsis_mask);
         if (new_axis_mask != 0) desc.SetAttr("new_axis_mask", new_axis_mask);
         if (shrink_axis_mask != 0) desc.SetAttr("shrink_axis_mask", shrink_axis_mask);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation MatrixLogarithm (  Output input ,String opName= "MatrixLogarithm" ) 
      {
         OperationDescription desc = NewOperation("MatrixLogarithm", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation InvertPermutation (  Output x ,String opName= "InvertPermutation" ) 
      {
         OperationDescription desc = NewOperation("InvertPermutation", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="k"></param>
      ///<param name="sorted"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] values(type: DtInvalid).
      ///[1] indices(type: DtInt32).
      ///</return>
      public Operation TopK (  Output input , long k, bool sorted = true ,String opName= "TopK" ) 
      {
         OperationDescription desc = NewOperation("TopK", opName);
         desc.AddInput(input);
         desc.SetAttr("k", k);
         if (sorted != true) desc.SetAttr("sorted", sorted);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Cholesky (  Output input ,String opName= "Cholesky" ) 
      {
         OperationDescription desc = NewOperation("Cholesky", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="l">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation CholeskyGrad (  Output l , Output grad ,String opName= "CholeskyGrad" ) 
      {
         OperationDescription desc = NewOperation("CholeskyGrad", opName);
         desc.AddInput(l);
         desc.AddInput(grad);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="m">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="logbase">Input to the operation. </param>
      ///<param name="sign_decay">Input to the operation. </param>
      ///<param name="beta">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation ApplyPowerSign (  Output var , Output m , Output lr , Output logbase , Output sign_decay , Output beta , Output grad , bool use_locking = false ,String opName= "ApplyPowerSign" ) 
      {
         OperationDescription desc = NewOperation("ApplyPowerSign", opName);
         desc.AddInput(var);
         desc.AddInput(m);
         desc.AddInput(lr);
         desc.AddInput(logbase);
         desc.AddInput(sign_decay);
         desc.AddInput(beta);
         desc.AddInput(grad);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SelfAdjointEig (  Output input ,String opName= "SelfAdjointEig" ) 
      {
         OperationDescription desc = NewOperation("SelfAdjointEig", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="matrix">Input to the operation. </param>
      ///<param name="rhs">Input to the operation. </param>
      ///<param name="lower"></param>
      ///<param name="adjoint"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation MatrixTriangularSolve (  Output matrix , Output rhs , bool lower = true , bool adjoint = false ,String opName= "MatrixTriangularSolve" ) 
      {
         OperationDescription desc = NewOperation("MatrixTriangularSolve", opName);
         desc.AddInput(matrix);
         desc.AddInput(rhs);

         if (lower != true) desc.SetAttr("lower", lower);
         if (adjoint != false) desc.SetAttr("adjoint", adjoint);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reference">Input to the operation. </param>
      ///<param name="limit"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation CountUpTo (  Output reference , long limit,String opName= "CountUpTo" ) 
      {
         OperationDescription desc = NewOperation("CountUpTo", opName);
         desc.AddInput(reference);
         desc.SetAttr("limit", limit);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Exp (  Output x ,String opName= "Exp" ) 
      {
         OperationDescription desc = NewOperation("Exp", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="compute_uv"></param>
      ///<param name="full_matrices"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] s(type: DtInvalid).
      ///[1] u(type: DtInvalid).
      ///[2] v(type: DtInvalid).
      ///</return>
      public Operation Svd (  Output input , bool compute_uv = true , bool full_matrices = false ,String opName= "Svd" ) 
      {
         OperationDescription desc = NewOperation("Svd", opName);
         desc.AddInput(input);

         if (compute_uv != true) desc.SetAttr("compute_uv", compute_uv);
         if (full_matrices != false) desc.SetAttr("full_matrices", full_matrices);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="value">Input to the operation. </param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation RandomShuffle (  Output value , long seed = 0 , long seed2 = 0 ,String opName= "RandomShuffle" ) 
      {
         OperationDescription desc = NewOperation("RandomShuffle", opName);
         desc.AddInput(value);

         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="input_min">Input to the operation. </param>
      ///<param name="input_max">Input to the operation. </param>
      ///<param name="requested_output_min">Input to the operation. </param>
      ///<param name="requested_output_max">Input to the operation. </param>
      ///<param name="out_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///[1] output_min(type: DtFloat).
      ///[2] output_max(type: DtFloat).
      ///</return>
      public Operation Requantize (  Output input , Output input_min , Output input_max , Output requested_output_min , Output requested_output_max , DataType out_type,String opName= "Requantize" ) 
      {
         OperationDescription desc = NewOperation("Requantize", opName);
         desc.AddInput(input);
         desc.AddInput(input_min);
         desc.AddInput(input_max);
         desc.AddInput(requested_output_min);
         desc.AddInput(requested_output_max);
         desc.SetAttr("out_type", out_type);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation BatchSelfAdjointEig (  Output input ,String opName= "BatchSelfAdjointEig" ) 
      {
         OperationDescription desc = NewOperation("BatchSelfAdjointEig", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation BatchMatrixDeterminant (  Output input ,String opName= "BatchMatrixDeterminant" ) 
      {
         OperationDescription desc = NewOperation("BatchMatrixDeterminant", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      //The following attributes are not known: cond: func; body: func
      public Operation While (  Output input ,String opName= "While" ) 
      {
         OperationDescription desc = NewOperation("While", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Rint (  Output x ,String opName= "Rint" ) 
      {
         OperationDescription desc = NewOperation("Rint", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="inputs">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] sum(type: DtInvalid).
      ///</return>
      public Operation AddN (  Output inputs ,String opName= "AddN" ) 
      {
         OperationDescription desc = NewOperation("AddN", opName);
         desc.AddInput(inputs);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="adjoint"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation BatchMatrixInverse (  Output input , bool adjoint = false ,String opName= "BatchMatrixInverse" ) 
      {
         OperationDescription desc = NewOperation("BatchMatrixInverse", opName);
         desc.AddInput(input);

         if (adjoint != false) desc.SetAttr("adjoint", adjoint);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="diagonal">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Diag (  Output diagonal ,String opName= "Diag" ) 
      {
         OperationDescription desc = NewOperation("Diag", opName);
         desc.AddInput(diagonal);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation BatchCholesky (  Output input ,String opName= "BatchCholesky" ) 
      {
         OperationDescription desc = NewOperation("BatchCholesky", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="gradients">Input to the operation. </param>
      ///<param name="inputs">Input to the operation. </param>
      ///<param name="min">Input to the operation. </param>
      ///<param name="max">Input to the operation. </param>
      ///<param name="num_bits"></param>
      ///<param name="narrow_range"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] backprops_wrt_input(type: DtFloat).
      ///[1] backprop_wrt_min(type: DtFloat).
      ///[2] backprop_wrt_max(type: DtFloat).
      ///</return>
      public Operation FakeQuantWithMinMaxVarsGradient (  Output gradients , Output inputs , Output min , Output max , long num_bits = 8 , bool narrow_range = false ,String opName= "FakeQuantWithMinMaxVarsGradient" ) 
      {
         OperationDescription desc = NewOperation("FakeQuantWithMinMaxVarsGradient", opName);
         desc.AddInput(gradients);
         desc.AddInput(inputs);
         desc.AddInput(min);
         desc.AddInput(max);

         if (num_bits != 8) desc.SetAttr("num_bits", num_bits);
         if (narrow_range != false) desc.SetAttr("narrow_range", narrow_range);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="l">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation BatchCholeskyGrad (  Output l , Output grad ,String opName= "BatchCholeskyGrad" ) 
      {
         OperationDescription desc = NewOperation("BatchCholeskyGrad", opName);
         desc.AddInput(l);
         desc.AddInput(grad);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="resource">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="updates">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceScatterDiv (  Output resource , Output indices , Output updates ,String opName= "ResourceScatterDiv" ) 
      {
         OperationDescription desc = NewOperation("ResourceScatterDiv", opName);
         desc.AddInput(resource);
         desc.AddInput(indices);
         desc.AddInput(updates);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="matrix">Input to the operation. </param>
      ///<param name="rhs">Input to the operation. </param>
      ///<param name="l2_regularizer">Input to the operation. </param>
      ///<param name="fast"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation BatchMatrixSolveLs (  Output matrix , Output rhs , Output l2_regularizer , bool fast = true ,String opName= "BatchMatrixSolveLs" ) 
      {
         OperationDescription desc = NewOperation("BatchMatrixSolveLs", opName);
         desc.AddInput(matrix);
         desc.AddInput(rhs);
         desc.AddInput(l2_regularizer);

         if (fast != true) desc.SetAttr("fast", fast);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="table_handle">Input to the operation. </param>
      ///<param name="keys">Input to the operation. </param>
      ///<param name="values">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation LookupTableImport (  Output table_handle , Output keys , Output values ,String opName= "LookupTableImport" ) 
      {
         OperationDescription desc = NewOperation("LookupTableImport", opName);
         desc.AddInput(table_handle);
         desc.AddInput(keys);
         desc.AddInput(values);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtBool).
      ///</return>
      public Operation IsNan (  Output x ,String opName= "IsNan" ) 
      {
         OperationDescription desc = NewOperation("IsNan", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="compute_uv"></param>
      ///<param name="full_matrices"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] s(type: DtInvalid).
      ///[1] u(type: DtInvalid).
      ///[2] v(type: DtInvalid).
      ///</return>
      public Operation BatchSvd (  Output input , bool compute_uv = true , bool full_matrices = false ,String opName= "BatchSvd" ) 
      {
         OperationDescription desc = NewOperation("BatchSvd", opName);
         desc.AddInput(input);

         if (compute_uv != true) desc.SetAttr("compute_uv", compute_uv);
         if (full_matrices != false) desc.SetAttr("full_matrices", full_matrices);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_handle">Input to the operation. </param>
      ///<param name="tensor">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_handle(type: DtVariant).
      ///</return>
      public Operation TensorListPushBack (  Output input_handle , Output tensor ,String opName= "TensorListPushBack" ) 
      {
         OperationDescription desc = NewOperation("TensorListPushBack", opName);
         desc.AddInput(input_handle);
         desc.AddInput(tensor);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="value">Input to the operation. </param>
      ///<param name="pooling_ratio"></param>
      ///<param name="pseudo_random"></param>
      ///<param name="overlapping"></param>
      ///<param name="deterministic"></param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///[1] row_pooling_sequence(type: DtInt64).
      ///[2] col_pooling_sequence(type: DtInt64).
      ///</return>
      public Operation FractionalAvgPool (  Output value , float[] pooling_ratio, bool pseudo_random = false , bool overlapping = false , bool deterministic = false , long seed = 0 , long seed2 = 0 ,String opName= "FractionalAvgPool" ) 
      {
         OperationDescription desc = NewOperation("FractionalAvgPool", opName);
         desc.AddInput(value);
         desc.SetAttr("pooling_ratio", pooling_ratio);
         if (pseudo_random != false) desc.SetAttr("pseudo_random", pseudo_random);
         if (overlapping != false) desc.SetAttr("overlapping", overlapping);
         if (deterministic != false) desc.SetAttr("deterministic", deterministic);
         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] length(type: DtInt32).
      ///</return>
      public Operation TensorListLength (  Output input_handle ,String opName= "TensorListLength" ) 
      {
         OperationDescription desc = NewOperation("TensorListLength", opName);
         desc.AddInput(input_handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="reduction_indices">Input to the operation. </param>
      ///<param name="keep_dims"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Mean (  Output input , Output reduction_indices , bool keep_dims = false ,String opName= "Mean" ) 
      {
         OperationDescription desc = NewOperation("Mean", opName);
         desc.AddInput(input);
         desc.AddInput(reduction_indices);

         if (keep_dims != false) desc.SetAttr("keep_dims", keep_dims);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_handle">Input to the operation. </param>
      ///<param name="element_dtype"></param>
      ///<param name="num_elements"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] tensor(type: DtInvalid).
      ///</return>
      public Operation TensorListStack (  Output input_handle , DataType element_dtype, long num_elements = -1 ,String opName= "TensorListStack" ) 
      {
         OperationDescription desc = NewOperation("TensorListStack", opName);
         desc.AddInput(input_handle);
         desc.SetAttr("element_dtype", element_dtype);
         if (num_elements != -1) desc.SetAttr("num_elements", num_elements);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_handle">Input to the operation. </param>
      ///<param name="shape_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] element_shape(type: DtInvalid).
      ///</return>
      public Operation TensorListElementShape (  Output input_handle , DataType shape_type,String opName= "TensorListElementShape" ) 
      {
         OperationDescription desc = NewOperation("TensorListElementShape", opName);
         desc.AddInput(input_handle);
         desc.SetAttr("shape_type", shape_type);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_handle">Input to the operation. </param>
      ///<param name="index">Input to the operation. </param>
      ///<param name="item">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_handle(type: DtVariant).
      ///</return>
      public Operation TensorListSetItem (  Output input_handle , Output index , Output item ,String opName= "TensorListSetItem" ) 
      {
         OperationDescription desc = NewOperation("TensorListSetItem", opName);
         desc.AddInput(input_handle);
         desc.AddInput(index);
         desc.AddInput(item);


         return desc.FinishOperation();
      } 
      // Skipped function _ParallelConcatStart

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Identity (  Output input ,String opName= "Identity" ) 
      {
         OperationDescription desc = NewOperation("Identity", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="table_handle">Input to the operation. </param>
      ///<param name="keys">Input to the operation. </param>
      ///<param name="default_value">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] values(type: DtInvalid).
      ///</return>
      public Operation LookupTableFind (  Output table_handle , Output keys , Output default_value ,String opName= "LookupTableFind" ) 
      {
         OperationDescription desc = NewOperation("LookupTableFind", opName);
         desc.AddInput(table_handle);
         desc.AddInput(keys);
         desc.AddInput(default_value);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="tensor">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] serialized(type: DtString).
      ///</return>
      public Operation SerializeTensor (  Output tensor ,String opName= "SerializeTensor" ) 
      {
         OperationDescription desc = NewOperation("SerializeTensor", opName);
         desc.AddInput(tensor);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="table_handle">Input to the operation. </param>
      ///<param name="keys">Input to the operation. </param>
      ///<param name="values">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation LookupTableInsert (  Output table_handle , Output keys , Output values ,String opName= "LookupTableInsert" ) 
      {
         OperationDescription desc = NewOperation("LookupTableInsert", opName);
         desc.AddInput(table_handle);
         desc.AddInput(keys);
         desc.AddInput(values);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="table_handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] size(type: DtInt64).
      ///</return>
      public Operation LookupTableSize (  Output table_handle ,String opName= "LookupTableSize" ) 
      {
         OperationDescription desc = NewOperation("LookupTableSize", opName);
         desc.AddInput(table_handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="table_handle">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] size(type: DtInt64).
      ///</return>
      public Operation LookupTableSizeV2 (  Output table_handle ,String opName= "LookupTableSizeV2" ) 
      {
         OperationDescription desc = NewOperation("LookupTableSizeV2", opName);
         desc.AddInput(table_handle);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="table_handle">Input to the operation. </param>
      ///<param name="Tkeys"></param>
      ///<param name="Tvalues"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] keys(type: DtInvalid).
      ///[1] values(type: DtInvalid).
      ///</return>
      public Operation LookupTableExport (  Output table_handle , DataType Tkeys, DataType Tvalues,String opName= "LookupTableExport" ) 
      {
         OperationDescription desc = NewOperation("LookupTableExport", opName);
         desc.AddInput(table_handle);
         desc.SetAttr("Tkeys", Tkeys);
         desc.SetAttr("Tvalues", Tvalues);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="inputs">Input to the operation. </param>
      ///<param name="min">Input to the operation. </param>
      ///<param name="max">Input to the operation. </param>
      ///<param name="num_bits"></param>
      ///<param name="narrow_range"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] outputs(type: DtFloat).
      ///</return>
      public Operation FakeQuantWithMinMaxVars (  Output inputs , Output min , Output max , long num_bits = 8 , bool narrow_range = false ,String opName= "FakeQuantWithMinMaxVars" ) 
      {
         OperationDescription desc = NewOperation("FakeQuantWithMinMaxVars", opName);
         desc.AddInput(inputs);
         desc.AddInput(min);
         desc.AddInput(max);

         if (num_bits != 8) desc.SetAttr("num_bits", num_bits);
         if (narrow_range != false) desc.SetAttr("narrow_range", narrow_range);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Rsqrt (  Output x ,String opName= "Rsqrt" ) 
      {
         OperationDescription desc = NewOperation("Rsqrt", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="table_handle">Input to the operation. </param>
      ///<param name="Tkeys"></param>
      ///<param name="Tvalues"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] keys(type: DtInvalid).
      ///[1] values(type: DtInvalid).
      ///</return>
      public Operation LookupTableExportV2 (  Output table_handle , DataType Tkeys, DataType Tvalues,String opName= "LookupTableExportV2" ) 
      {
         OperationDescription desc = NewOperation("LookupTableExportV2", opName);
         desc.AddInput(table_handle);
         desc.SetAttr("Tkeys", Tkeys);
         desc.SetAttr("Tvalues", Tvalues);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="resource">Input to the operation. </param>
      ///<param name="value">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation AssignAddVariableOp (  Output resource , Output value ,String opName= "AssignAddVariableOp" ) 
      {
         OperationDescription desc = NewOperation("AssignAddVariableOp", opName);
         desc.AddInput(resource);
         desc.AddInput(value);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="table_handle">Input to the operation. </param>
      ///<param name="keys">Input to the operation. </param>
      ///<param name="values">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation LookupTableImportV2 (  Output table_handle , Output keys , Output values ,String opName= "LookupTableImportV2" ) 
      {
         OperationDescription desc = NewOperation("LookupTableImportV2", opName);
         desc.AddInput(table_handle);
         desc.AddInput(keys);
         desc.AddInput(values);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="key_dtype"></param>
      ///<param name="value_dtype"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="use_node_name_sharing"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] table_handle(type: DtString).
      ///</return>
      public Operation HashTable (  DataType key_dtype, DataType value_dtype, string container = null , string shared_name = null , bool use_node_name_sharing = false ,String opName= "HashTable" ) 
      {
         OperationDescription desc = NewOperation("HashTable", opName);

         desc.SetAttr("key_dtype", key_dtype);
         desc.SetAttr("value_dtype", value_dtype);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         if (use_node_name_sharing != false) desc.SetAttr("use_node_name_sharing", use_node_name_sharing);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="key_dtype"></param>
      ///<param name="value_dtype"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="use_node_name_sharing"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] table_handle(type: DtResource).
      ///</return>
      public Operation HashTableV2 (  DataType key_dtype, DataType value_dtype, string container = null , string shared_name = null , bool use_node_name_sharing = false ,String opName= "HashTableV2" ) 
      {
         OperationDescription desc = NewOperation("HashTableV2", opName);

         desc.SetAttr("key_dtype", key_dtype);
         desc.SetAttr("value_dtype", value_dtype);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         if (use_node_name_sharing != false) desc.SetAttr("use_node_name_sharing", use_node_name_sharing);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="key_dtype"></param>
      ///<param name="value_dtype"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="use_node_name_sharing"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] table_handle(type: DtResource).
      ///</return>
      public Operation MutableHashTableV2 (  DataType key_dtype, DataType value_dtype, string container = null , string shared_name = null , bool use_node_name_sharing = false ,String opName= "MutableHashTableV2" ) 
      {
         OperationDescription desc = NewOperation("MutableHashTableV2", opName);

         desc.SetAttr("key_dtype", key_dtype);
         desc.SetAttr("value_dtype", value_dtype);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         if (use_node_name_sharing != false) desc.SetAttr("use_node_name_sharing", use_node_name_sharing);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="empty_key">Input to the operation. </param>
      ///<param name="value_dtype"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="use_node_name_sharing"></param>
      ///<param name="value_shape"></param>
      ///<param name="initial_num_buckets"></param>
      ///<param name="max_load_factor"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] table_handle(type: DtString).
      ///</return>
      public Operation MutableDenseHashTable (  Output empty_key , DataType value_dtype, string container = null , string shared_name = null , bool use_node_name_sharing = false , long[] value_shape = null , long initial_num_buckets = 131072 , float max_load_factor = 0.8f ,String opName= "MutableDenseHashTable" ) 
      {
         OperationDescription desc = NewOperation("MutableDenseHashTable", opName);
         desc.AddInput(empty_key);
         desc.SetAttr("value_dtype", value_dtype);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         if (use_node_name_sharing != false) desc.SetAttr("use_node_name_sharing", use_node_name_sharing);
         if (value_shape != null) desc.SetAttrShape("value_shape", value_shape);
         if (initial_num_buckets != 131072) desc.SetAttr("initial_num_buckets", initial_num_buckets);
         if (max_load_factor != 0.8f) desc.SetAttr("max_load_factor", max_load_factor);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="empty_key">Input to the operation. </param>
      ///<param name="value_dtype"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="use_node_name_sharing"></param>
      ///<param name="value_shape"></param>
      ///<param name="initial_num_buckets"></param>
      ///<param name="max_load_factor"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] table_handle(type: DtResource).
      ///</return>
      public Operation MutableDenseHashTableV2 (  Output empty_key , DataType value_dtype, string container = null , string shared_name = null , bool use_node_name_sharing = false , long[] value_shape = null , long initial_num_buckets = 131072 , float max_load_factor = 0.8f ,String opName= "MutableDenseHashTableV2" ) 
      {
         OperationDescription desc = NewOperation("MutableDenseHashTableV2", opName);
         desc.AddInput(empty_key);
         desc.SetAttr("value_dtype", value_dtype);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         if (use_node_name_sharing != false) desc.SetAttr("use_node_name_sharing", use_node_name_sharing);
         if (value_shape != null) desc.SetAttrShape("value_shape", value_shape);
         if (initial_num_buckets != 131072) desc.SetAttr("initial_num_buckets", initial_num_buckets);
         if (max_load_factor != 0.8f) desc.SetAttr("max_load_factor", max_load_factor);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="m">Input to the operation. </param>
      ///<param name="v">Input to the operation. </param>
      ///<param name="beta1_power">Input to the operation. </param>
      ///<param name="beta2_power">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="beta1">Input to the operation. </param>
      ///<param name="beta2">Input to the operation. </param>
      ///<param name="epsilon">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="use_nesterov"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation ApplyAdam (  Output var , Output m , Output v , Output beta1_power , Output beta2_power , Output lr , Output beta1 , Output beta2 , Output epsilon , Output grad , bool use_locking = false , bool use_nesterov = false ,String opName= "ApplyAdam" ) 
      {
         OperationDescription desc = NewOperation("ApplyAdam", opName);
         desc.AddInput(var);
         desc.AddInput(m);
         desc.AddInput(v);
         desc.AddInput(beta1_power);
         desc.AddInput(beta2_power);
         desc.AddInput(lr);
         desc.AddInput(beta1);
         desc.AddInput(beta2);
         desc.AddInput(epsilon);
         desc.AddInput(grad);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         if (use_nesterov != false) desc.SetAttr("use_nesterov", use_nesterov);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="table_handle">Input to the operation. </param>
      ///<param name="filename">Input to the operation. </param>
      ///<param name="key_index"></param>
      ///<param name="value_index"></param>
      ///<param name="vocab_size"></param>
      ///<param name="delimiter"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation InitializeTableFromTextFile (  Output table_handle , Output filename , long key_index, long value_index, long vocab_size = -1 , string delimiter = null ,String opName= "InitializeTableFromTextFile" ) 
      {
         OperationDescription desc = NewOperation("InitializeTableFromTextFile", opName);
         desc.AddInput(table_handle);
         desc.AddInput(filename);
         desc.SetAttr("key_index", key_index);
         desc.SetAttr("value_index", value_index);
         if (vocab_size != -1) desc.SetAttr("vocab_size", vocab_size);
         if (delimiter != null) desc.SetAttr("delimiter", delimiter);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="start">Input to the operation. </param>
      ///<param name="limit">Input to the operation. </param>
      ///<param name="delta">Input to the operation. </param>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      //The following attributes are not known: body: func
      public Operation For (  Output start , Output limit , Output delta , Output input ,String opName= "For" ) 
      {
         OperationDescription desc = NewOperation("For", opName);
         desc.AddInput(start);
         desc.AddInput(limit);
         desc.AddInput(delta);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Tanh (  Output x ,String opName= "Tanh" ) 
      {
         OperationDescription desc = NewOperation("Tanh", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="table_handle">Input to the operation. </param>
      ///<param name="filename">Input to the operation. </param>
      ///<param name="key_index"></param>
      ///<param name="value_index"></param>
      ///<param name="vocab_size"></param>
      ///<param name="delimiter"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation InitializeTableFromTextFileV2 (  Output table_handle , Output filename , long key_index, long value_index, long vocab_size = -1 , string delimiter = null ,String opName= "InitializeTableFromTextFileV2" ) 
      {
         OperationDescription desc = NewOperation("InitializeTableFromTextFileV2", opName);
         desc.AddInput(table_handle);
         desc.AddInput(filename);
         desc.SetAttr("key_index", key_index);
         desc.SetAttr("value_index", value_index);
         if (vocab_size != -1) desc.SetAttr("vocab_size", vocab_size);
         if (delimiter != null) desc.SetAttr("delimiter", delimiter);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="condition">Input to the operation. </param>
      ///<param name="data">Input to the operation. </param>
      ///<param name="summarize"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation Assert (  Output condition , Output data , long summarize = 3 ,String opName= "Assert" ) 
      {
         OperationDescription desc = NewOperation("Assert", opName);
         desc.AddInput(condition);
         desc.AddInput(data);

         if (summarize != 3) desc.SetAttr("summarize", summarize);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="data">Input to the operation. </param>
      ///<param name="message"></param>
      ///<param name="first_n"></param>
      ///<param name="summarize"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Print (  Output input , Output data , string message = null , long first_n = -1 , long summarize = 3 ,String opName= "Print" ) 
      {
         OperationDescription desc = NewOperation("Print", opName);
         desc.AddInput(input);
         desc.AddInput(data);

         if (message != null) desc.SetAttr("message", message);
         if (first_n != -1) desc.SetAttr("first_n", first_n);
         if (summarize != 3) desc.SetAttr("summarize", summarize);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="tensor">Input to the operation. </param>
      ///<param name="description"></param>
      ///<param name="labels"></param>
      ///<param name="display_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] summary(type: DtString).
      ///</return>
      public Operation TensorSummary (  Output tensor , string description = null , string[] labels = null , string display_name = null ,String opName= "TensorSummary" ) 
      {
         OperationDescription desc = NewOperation("TensorSummary", opName);
         desc.AddInput(tensor);

         if (description != null) desc.SetAttr("description", description);
         if (labels != null) desc.SetAttr("labels", labels);
         if (display_name != null) desc.SetAttr("display_name", display_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="tag">Input to the operation. </param>
      ///<param name="values">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] summary(type: DtString).
      ///</return>
      public Operation HistogramSummary (  Output tag , Output values ,String opName= "HistogramSummary" ) 
      {
         OperationDescription desc = NewOperation("HistogramSummary", opName);
         desc.AddInput(tag);
         desc.AddInput(values);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="tag">Input to the operation. </param>
      ///<param name="tensor">Input to the operation. </param>
      ///<param name="sample_rate">Input to the operation. </param>
      ///<param name="max_outputs"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] summary(type: DtString).
      ///</return>
      public Operation AudioSummaryV2 (  Output tag , Output tensor , Output sample_rate , long max_outputs = 3 ,String opName= "AudioSummaryV2" ) 
      {
         OperationDescription desc = NewOperation("AudioSummaryV2", opName);
         desc.AddInput(tag);
         desc.AddInput(tensor);
         desc.AddInput(sample_rate);

         if (max_outputs != 3) desc.SetAttr("max_outputs", max_outputs);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="m">Input to the operation. </param>
      ///<param name="v">Input to the operation. </param>
      ///<param name="beta1_power">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="beta1">Input to the operation. </param>
      ///<param name="beta2">Input to the operation. </param>
      ///<param name="epsilon">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceApplyAdaMax (  Output var , Output m , Output v , Output beta1_power , Output lr , Output beta1 , Output beta2 , Output epsilon , Output grad , bool use_locking = false ,String opName= "ResourceApplyAdaMax" ) 
      {
         OperationDescription desc = NewOperation("ResourceApplyAdaMax", opName);
         desc.AddInput(var);
         desc.AddInput(m);
         desc.AddInput(v);
         desc.AddInput(beta1_power);
         desc.AddInput(lr);
         desc.AddInput(beta1);
         desc.AddInput(beta2);
         desc.AddInput(epsilon);
         desc.AddInput(grad);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="inputs">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] summary(type: DtString).
      ///</return>
      public Operation MergeSummary (  Output inputs ,String opName= "MergeSummary" ) 
      {
         OperationDescription desc = NewOperation("MergeSummary", opName);
         desc.AddInput(inputs);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="i">Input to the operation. </param>
      ///<param name="v">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation InplaceUpdate (  Output x , Output i , Output v ,String opName= "InplaceUpdate" ) 
      {
         OperationDescription desc = NewOperation("InplaceUpdate", opName);
         desc.AddInput(x);
         desc.AddInput(i);
         desc.AddInput(v);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation RefIdentity (  Output input ,String opName= "RefIdentity" ) 
      {
         OperationDescription desc = NewOperation("RefIdentity", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="i">Input to the operation. </param>
      ///<param name="v">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation InplaceAdd (  Output x , Output i , Output v ,String opName= "InplaceAdd" ) 
      {
         OperationDescription desc = NewOperation("InplaceAdd", opName);
         desc.AddInput(x);
         desc.AddInput(i);
         desc.AddInput(v);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="dims">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation UnravelIndex (  Output indices , Output dims ,String opName= "UnravelIndex" ) 
      {
         OperationDescription desc = NewOperation("UnravelIndex", opName);
         desc.AddInput(indices);
         desc.AddInput(dims);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="shape">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation BroadcastTo (  Output input , Output shape ,String opName= "BroadcastTo" ) 
      {
         OperationDescription desc = NewOperation("BroadcastTo", opName);
         desc.AddInput(input);
         desc.AddInput(shape);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="concat_dim">Input to the operation. </param>
      ///<param name="shape">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] offset(type: DtInt32).
      ///</return>
      public Operation ConcatOffset (  Output concat_dim , Output shape ,String opName= "ConcatOffset" ) 
      {
         OperationDescription desc = NewOperation("ConcatOffset", opName);
         desc.AddInput(concat_dim);
         desc.AddInput(shape);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="split_dim">Input to the operation. </param>
      ///<param name="value">Input to the operation. </param>
      ///<param name="num_split"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Split (  Output split_dim , Output value , long num_split,String opName= "Split" ) 
      {
         OperationDescription desc = NewOperation("Split", opName);
         desc.AddInput(split_dim);
         desc.AddInput(value);
         desc.SetAttr("num_split", num_split);

         return desc.FinishOperation();
      } 
      // Skipped function _Send

      ///<summary>
      ///
      ///</summary>
      ///<param name="value"></param>
      ///<param name="dtype"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Const (  Tensor value, DataType dtype,String opName= "Const" ) 
      {
         OperationDescription desc = NewOperation("Const", opName);

         desc.SetAttr("value", value);
         desc.SetAttr("dtype", dtype);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="value"></param>
      ///<param name="dtype"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation HostConst (  Tensor value, DataType dtype,String opName= "HostConst" ) 
      {
         OperationDescription desc = NewOperation("HostConst", opName);

         desc.SetAttr("value", value);
         desc.SetAttr("dtype", dtype);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="resource">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="validate_indices"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation ResourceGather (  Output resource , Output indices , DataType dtype, bool validate_indices = true ,String opName= "ResourceGather" ) 
      {
         OperationDescription desc = NewOperation("ResourceGather", opName);
         desc.AddInput(resource);
         desc.AddInput(indices);
         desc.SetAttr("dtype", dtype);
         if (validate_indices != true) desc.SetAttr("validate_indices", validate_indices);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="dtype"></param>
      ///<param name="shape"></param>
      ///<param name="memory_region_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] tensor(type: DtInvalid).
      ///</return>
      public Operation ImmutableConst (  DataType dtype, long[] shape, string memory_region_name,String opName= "ImmutableConst" ) 
      {
         OperationDescription desc = NewOperation("ImmutableConst", opName);

         desc.SetAttr("dtype", dtype);
         desc.SetAttrShape("shape", shape);
         desc.SetAttr("memory_region_name", memory_region_name);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation ZerosLike (  Output x ,String opName= "ZerosLike" ) 
      {
         OperationDescription desc = NewOperation("ZerosLike", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation OnesLike (  Output x ,String opName= "OnesLike" ) 
      {
         OperationDescription desc = NewOperation("OnesLike", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] diagonal(type: DtInvalid).
      ///</return>
      public Operation DiagPart (  Output input ,String opName= "DiagPart" ) 
      {
         OperationDescription desc = NewOperation("DiagPart", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInt32).
      ///</return>
      public Operation Rank (  Output input ,String opName= "Rank" ) 
      {
         OperationDescription desc = NewOperation("Rank", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reference">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="updates">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_ref(type: DtInvalid).
      ///</return>
      public Operation ScatterMax (  Output reference , Output indices , Output updates , bool use_locking = false ,String opName= "ScatterMax" ) 
      {
         OperationDescription desc = NewOperation("ScatterMax", opName);
         desc.AddInput(reference);
         desc.AddInput(indices);
         desc.AddInput(updates);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="tensor">Input to the operation. </param>
      ///<param name="dims">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Reverse (  Output tensor , Output dims ,String opName= "Reverse" ) 
      {
         OperationDescription desc = NewOperation("Reverse", opName);
         desc.AddInput(tensor);
         desc.AddInput(dims);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtComplex64).
      ///</return>
      public Operation BatchIFFT3D (  Output input ,String opName= "BatchIFFT3D" ) 
      {
         OperationDescription desc = NewOperation("BatchIFFT3D", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtComplex64).
      ///</return>
      public Operation BatchFFT (  Output input ,String opName= "BatchFFT" ) 
      {
         OperationDescription desc = NewOperation("BatchFFT", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="tensor">Input to the operation. </param>
      ///<param name="axis">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation ReverseV2 (  Output tensor , Output axis ,String opName= "ReverseV2" ) 
      {
         OperationDescription desc = NewOperation("ReverseV2", opName);
         desc.AddInput(tensor);
         desc.AddInput(axis);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="hypothesis_indices">Input to the operation. </param>
      ///<param name="hypothesis_values">Input to the operation. </param>
      ///<param name="hypothesis_shape">Input to the operation. </param>
      ///<param name="truth_indices">Input to the operation. </param>
      ///<param name="truth_values">Input to the operation. </param>
      ///<param name="truth_shape">Input to the operation. </param>
      ///<param name="normalize"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtFloat).
      ///</return>
      public Operation EditDistance (  Output hypothesis_indices , Output hypothesis_values , Output hypothesis_shape , Output truth_indices , Output truth_values , Output truth_shape , bool normalize = true ,String opName= "EditDistance" ) 
      {
         OperationDescription desc = NewOperation("EditDistance", opName);
         desc.AddInput(hypothesis_indices);
         desc.AddInput(hypothesis_values);
         desc.AddInput(hypothesis_shape);
         desc.AddInput(truth_indices);
         desc.AddInput(truth_values);
         desc.AddInput(truth_shape);

         if (normalize != true) desc.SetAttr("normalize", normalize);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="writer">Input to the operation. </param>
      ///<param name="step">Input to the operation. </param>
      ///<param name="tag">Input to the operation. </param>
      ///<param name="value">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation WriteScalarSummary (  Output writer , Output step , Output tag , Output value ,String opName= "WriteScalarSummary" ) 
      {
         OperationDescription desc = NewOperation("WriteScalarSummary", opName);
         desc.AddInput(writer);
         desc.AddInput(step);
         desc.AddInput(tag);
         desc.AddInput(value);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="sp_indices">Input to the operation. </param>
      ///<param name="sp_values">Input to the operation. </param>
      ///<param name="sp_shape">Input to the operation. </param>
      ///<param name="dense">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SparseDenseCwiseAdd (  Output sp_indices , Output sp_values , Output sp_shape , Output dense ,String opName= "SparseDenseCwiseAdd" ) 
      {
         OperationDescription desc = NewOperation("SparseDenseCwiseAdd", opName);
         desc.AddInput(sp_indices);
         desc.AddInput(sp_values);
         desc.AddInput(sp_shape);
         desc.AddInput(dense);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation Div (  Output x , Output y ,String opName= "Div" ) 
      {
         OperationDescription desc = NewOperation("Div", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="filter">Input to the operation. </param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="data_format"></param>
      ///<param name="dilations"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Conv3D (  Output input , Output filter , long[] strides, string padding, string data_format = null , long[] dilations = null ,String opName= "Conv3D" ) 
      {
         OperationDescription desc = NewOperation("Conv3D", opName);
         desc.AddInput(input);
         desc.AddInput(filter);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         if (dilations != null) desc.SetAttr("dilations", dilations);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="dims">Input to the operation. </param>
      ///<param name="value">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Fill (  Output dims , Output value ,String opName= "Fill" ) 
      {
         OperationDescription desc = NewOperation("Fill", opName);
         desc.AddInput(dims);
         desc.AddInput(value);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] diagonal(type: DtInvalid).
      ///</return>
      public Operation BatchMatrixDiagPart (  Output input ,String opName= "BatchMatrixDiagPart" ) 
      {
         OperationDescription desc = NewOperation("BatchMatrixDiagPart", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 
      // Skipped function _ParallelConcatUpdate

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Snapshot (  Output input ,String opName= "Snapshot" ) 
      {
         OperationDescription desc = NewOperation("Snapshot", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation IdentityN (  Output input ,String opName= "IdentityN" ) 
      {
         OperationDescription desc = NewOperation("IdentityN", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation DebugGradientIdentity (  Output input ,String opName= "DebugGradientIdentity" ) 
      {
         OperationDescription desc = NewOperation("DebugGradientIdentity", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="dim">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation ExpandDims (  Output input , Output dim ,String opName= "ExpandDims" ) 
      {
         OperationDescription desc = NewOperation("ExpandDims", opName);
         desc.AddInput(input);
         desc.AddInput(dim);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation DebugGradientRefIdentity (  Output input ,String opName= "DebugGradientRefIdentity" ) 
      {
         OperationDescription desc = NewOperation("DebugGradientRefIdentity", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="alpha">Input to the operation. </param>
      ///<param name="l1">Input to the operation. </param>
      ///<param name="l2">Input to the operation. </param>
      ///<param name="delta">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation ApplyProximalGradientDescent (  Output var , Output alpha , Output l1 , Output l2 , Output delta , bool use_locking = false ,String opName= "ApplyProximalGradientDescent" ) 
      {
         OperationDescription desc = NewOperation("ApplyProximalGradientDescent", opName);
         desc.AddInput(var);
         desc.AddInput(alpha);
         desc.AddInput(l1);
         desc.AddInput(l2);
         desc.AddInput(delta);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="serialized">Input to the operation. </param>
      ///<param name="out_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation ParseTensor (  Output serialized , DataType out_type,String opName= "ParseTensor" ) 
      {
         OperationDescription desc = NewOperation("ParseTensor", opName);
         desc.AddInput(serialized);
         desc.SetAttr("out_type", out_type);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="message"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation PreventGradient (  Output input , string message = null ,String opName= "PreventGradient" ) 
      {
         OperationDescription desc = NewOperation("PreventGradient", opName);
         desc.AddInput(input);

         if (message != null) desc.SetAttr("message", message);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="backprop_val_grad">Input to the operation. </param>
      ///<param name="input_indices">Input to the operation. </param>
      ///<param name="input_start">Input to the operation. </param>
      ///<param name="output_indices">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] val_grad(type: DtInvalid).
      ///</return>
      public Operation SparseSliceGrad (  Output backprop_val_grad , Output input_indices , Output input_start , Output output_indices ,String opName= "SparseSliceGrad" ) 
      {
         OperationDescription desc = NewOperation("SparseSliceGrad", opName);
         desc.AddInput(backprop_val_grad);
         desc.AddInput(input_indices);
         desc.AddInput(input_start);
         desc.AddInput(output_indices);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="tensor">Input to the operation. </param>
      ///<param name="shape">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Reshape (  Output tensor , Output shape ,String opName= "Reshape" ) 
      {
         OperationDescription desc = NewOperation("Reshape", opName);
         desc.AddInput(tensor);
         desc.AddInput(shape);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="perm">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation ConjugateTranspose (  Output x , Output perm ,String opName= "ConjugateTranspose" ) 
      {
         OperationDescription desc = NewOperation("ConjugateTranspose", opName);
         desc.AddInput(x);
         desc.AddInput(perm);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="out_idx"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///[1] idx(type: DtInvalid).
      ///</return>
      public Operation Unique (  Output x , DataType? out_idx = null ,String opName= "Unique" ) 
      {
         OperationDescription desc = NewOperation("Unique", opName);
         desc.AddInput(x);

         if (out_idx.HasValue) desc.SetAttr("out_idx", out_idx.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="axis">Input to the operation. </param>
      ///<param name="out_idx"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///[1] idx(type: DtInvalid).
      ///</return>
      public Operation UniqueV2 (  Output x , Output axis , DataType? out_idx = null ,String opName= "UniqueV2" ) 
      {
         OperationDescription desc = NewOperation("UniqueV2", opName);
         desc.AddInput(x);
         desc.AddInput(axis);

         if (out_idx.HasValue) desc.SetAttr("out_idx", out_idx.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="filter">Input to the operation. </param>
      ///<param name="out_backprop">Input to the operation. </param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="dilations"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Conv3DBackpropFilter (  Output input , Output filter , Output out_backprop , long[] strides, string padding, long[] dilations = null ,String opName= "Conv3DBackpropFilter" ) 
      {
         OperationDescription desc = NewOperation("Conv3DBackpropFilter", opName);
         desc.AddInput(input);
         desc.AddInput(filter);
         desc.AddInput(out_backprop);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);
         if (dilations != null) desc.SetAttr("dilations", dilations);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="out_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation ShapeN (  Output input , DataType? out_type = null ,String opName= "ShapeN" ) 
      {
         OperationDescription desc = NewOperation("ShapeN", opName);
         desc.AddInput(input);

         if (out_type.HasValue) desc.SetAttr("out_type", out_type.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Ceil (  Output x ,String opName= "Ceil" ) 
      {
         OperationDescription desc = NewOperation("Ceil", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="resource">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="updates">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceScatterAdd (  Output resource , Output indices , Output updates ,String opName= "ResourceScatterAdd" ) 
      {
         OperationDescription desc = NewOperation("ResourceScatterAdd", opName);
         desc.AddInput(resource);
         desc.AddInput(indices);
         desc.AddInput(updates);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="seq_lengths">Input to the operation. </param>
      ///<param name="seq_dim"></param>
      ///<param name="batch_dim"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation ReverseSequence (  Output input , Output seq_lengths , long seq_dim, long batch_dim = 0 ,String opName= "ReverseSequence" ) 
      {
         OperationDescription desc = NewOperation("ReverseSequence", opName);
         desc.AddInput(input);
         desc.AddInput(seq_lengths);
         desc.SetAttr("seq_dim", seq_dim);
         if (batch_dim != 0) desc.SetAttr("batch_dim", batch_dim);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="out_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Size (  Output input , DataType? out_type = null ,String opName= "Size" ) 
      {
         OperationDescription desc = NewOperation("Size", opName);
         desc.AddInput(input);

         if (out_type.HasValue) desc.SetAttr("out_type", out_type.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="shape">Input to the operation. </param>
      ///<param name="begin">Input to the operation. </param>
      ///<param name="end">Input to the operation. </param>
      ///<param name="strides">Input to the operation. </param>
      ///<param name="dy">Input to the operation. </param>
      ///<param name="begin_mask"></param>
      ///<param name="end_mask"></param>
      ///<param name="ellipsis_mask"></param>
      ///<param name="new_axis_mask"></param>
      ///<param name="shrink_axis_mask"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation StridedSliceGrad (  Output shape , Output begin , Output end , Output strides , Output dy , long begin_mask = 0 , long end_mask = 0 , long ellipsis_mask = 0 , long new_axis_mask = 0 , long shrink_axis_mask = 0 ,String opName= "StridedSliceGrad" ) 
      {
         OperationDescription desc = NewOperation("StridedSliceGrad", opName);
         desc.AddInput(shape);
         desc.AddInput(begin);
         desc.AddInput(end);
         desc.AddInput(strides);
         desc.AddInput(dy);

         if (begin_mask != 0) desc.SetAttr("begin_mask", begin_mask);
         if (end_mask != 0) desc.SetAttr("end_mask", end_mask);
         if (ellipsis_mask != 0) desc.SetAttr("ellipsis_mask", ellipsis_mask);
         if (new_axis_mask != 0) desc.SetAttr("new_axis_mask", new_axis_mask);
         if (shrink_axis_mask != 0) desc.SetAttr("shrink_axis_mask", shrink_axis_mask);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="json_examples">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] binary_examples(type: DtString).
      ///</return>
      public Operation DecodeJSONExample (  Output json_examples ,String opName= "DecodeJSONExample" ) 
      {
         OperationDescription desc = NewOperation("DecodeJSONExample", opName);
         desc.AddInput(json_examples);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="multiples">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Tile (  Output input , Output multiples ,String opName= "Tile" ) 
      {
         OperationDescription desc = NewOperation("Tile", opName);
         desc.AddInput(input);
         desc.AddInput(multiples);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] index(type: DtInt64).
      ///</return>
      public Operation Where (  Output input ,String opName= "Where" ) 
      {
         OperationDescription desc = NewOperation("Where", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="s0">Input to the operation. </param>
      ///<param name="s1">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] r0(type: DtInvalid).
      ///</return>
      public Operation BroadcastArgs (  Output s0 , Output s1 ,String opName= "BroadcastArgs" ) 
      {
         OperationDescription desc = NewOperation("BroadcastArgs", opName);
         desc.AddInput(s0);
         desc.AddInput(s1);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="s0">Input to the operation. </param>
      ///<param name="s1">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] r0(type: DtInvalid).
      ///[1] r1(type: DtInvalid).
      ///</return>
      public Operation BroadcastGradientArgs (  Output s0 , Output s1 ,String opName= "BroadcastGradientArgs" ) 
      {
         OperationDescription desc = NewOperation("BroadcastGradientArgs", opName);
         desc.AddInput(s0);
         desc.AddInput(s1);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="paddings">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Pad (  Output input , Output paddings ,String opName= "Pad" ) 
      {
         OperationDescription desc = NewOperation("Pad", opName);
         desc.AddInput(input);
         desc.AddInput(paddings);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="paddings">Input to the operation. </param>
      ///<param name="constant_values">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation PadV2 (  Output input , Output paddings , Output constant_values ,String opName= "PadV2" ) 
      {
         OperationDescription desc = NewOperation("PadV2", opName);
         desc.AddInput(input);
         desc.AddInput(paddings);
         desc.AddInput(constant_values);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="paddings">Input to the operation. </param>
      ///<param name="mode"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation MirrorPadGrad (  Output input , Output paddings , string mode,String opName= "MirrorPadGrad" ) 
      {
         OperationDescription desc = NewOperation("MirrorPadGrad", opName);
         desc.AddInput(input);
         desc.AddInput(paddings);
         desc.SetAttr("mode", mode);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="squeeze_dims"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Squeeze (  Output input , long[] squeeze_dims = null ,String opName= "Squeeze" ) 
      {
         OperationDescription desc = NewOperation("Squeeze", opName);
         desc.AddInput(input);

         if (squeeze_dims != null) desc.SetAttr("squeeze_dims", squeeze_dims);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="block_shape">Input to the operation. </param>
      ///<param name="crops">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation BatchToSpaceND (  Output input , Output block_shape , Output crops ,String opName= "BatchToSpaceND" ) 
      {
         OperationDescription desc = NewOperation("BatchToSpaceND", opName);
         desc.AddInput(input);
         desc.AddInput(block_shape);
         desc.AddInput(crops);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="block_size"></param>
      ///<param name="data_format"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation DepthToSpace (  Output input , long block_size, string data_format = null ,String opName= "DepthToSpace" ) 
      {
         OperationDescription desc = NewOperation("DepthToSpace", opName);
         desc.AddInput(input);
         desc.SetAttr("block_size", block_size);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_indices">Input to the operation. </param>
      ///<param name="input_values">Input to the operation. </param>
      ///<param name="input_shape">Input to the operation. </param>
      ///<param name="reduction_axes">Input to the operation. </param>
      ///<param name="keep_dims"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SparseReduceMax (  Output input_indices , Output input_values , Output input_shape , Output reduction_axes , bool keep_dims = false ,String opName= "SparseReduceMax" ) 
      {
         OperationDescription desc = NewOperation("SparseReduceMax", opName);
         desc.AddInput(input_indices);
         desc.AddInput(input_values);
         desc.AddInput(input_shape);
         desc.AddInput(reduction_axes);

         if (keep_dims != false) desc.SetAttr("keep_dims", keep_dims);
         return desc.FinishOperation();
      } 
      // Skipped function _UnaryOpsComposition

      ///<summary>
      ///
      ///</summary>
      ///<param name="images">Input to the operation. </param>
      ///<param name="ksizes"></param>
      ///<param name="strides"></param>
      ///<param name="rates"></param>
      ///<param name="padding"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] patches(type: DtInvalid).
      ///</return>
      public Operation ExtractImagePatches (  Output images , long[] ksizes, long[] strides, long[] rates, string padding,String opName= "ExtractImagePatches" ) 
      {
         OperationDescription desc = NewOperation("ExtractImagePatches", opName);
         desc.AddInput(images);
         desc.SetAttr("ksizes", ksizes);
         desc.SetAttr("strides", strides);
         desc.SetAttr("rates", rates);
         desc.SetAttr("padding", padding);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="depth">Input to the operation. </param>
      ///<param name="on_value">Input to the operation. </param>
      ///<param name="off_value">Input to the operation. </param>
      ///<param name="axis"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation OneHot (  Output indices , Output depth , Output on_value , Output off_value , long axis = -1 ,String opName= "OneHot" ) 
      {
         OperationDescription desc = NewOperation("OneHot", opName);
         desc.AddInput(indices);
         desc.AddInput(depth);
         desc.AddInput(on_value);
         desc.AddInput(off_value);

         if (axis != -1) desc.SetAttr("axis", axis);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="input_min">Input to the operation. </param>
      ///<param name="input_max">Input to the operation. </param>
      ///<param name="signed_input"></param>
      ///<param name="num_bits"></param>
      ///<param name="range_given"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation QuantizeAndDequantizeV2 (  Output input , Output input_min , Output input_max , bool signed_input = true , long num_bits = 8 , bool range_given = false ,String opName= "QuantizeAndDequantizeV2" ) 
      {
         OperationDescription desc = NewOperation("QuantizeAndDequantizeV2", opName);
         desc.AddInput(input);
         desc.AddInput(input_min);
         desc.AddInput(input_max);

         if (signed_input != true) desc.SetAttr("signed_input", signed_input);
         if (num_bits != 8) desc.SetAttr("num_bits", num_bits);
         if (range_given != false) desc.SetAttr("range_given", range_given);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="input_min">Input to the operation. </param>
      ///<param name="input_max">Input to the operation. </param>
      ///<param name="num_bits">Input to the operation. </param>
      ///<param name="signed_input"></param>
      ///<param name="range_given"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation QuantizeAndDequantizeV3 (  Output input , Output input_min , Output input_max , Output num_bits , bool signed_input = true , bool range_given = true ,String opName= "QuantizeAndDequantizeV3" ) 
      {
         OperationDescription desc = NewOperation("QuantizeAndDequantizeV3", opName);
         desc.AddInput(input);
         desc.AddInput(input_min);
         desc.AddInput(input_max);
         desc.AddInput(num_bits);

         if (signed_input != true) desc.SetAttr("signed_input", signed_input);
         if (range_given != true) desc.SetAttr("range_given", range_given);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="min_range">Input to the operation. </param>
      ///<param name="max_range">Input to the operation. </param>
      ///<param name="T"></param>
      ///<param name="mode"></param>
      ///<param name="round_mode"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///[1] output_min(type: DtFloat).
      ///[2] output_max(type: DtFloat).
      ///</return>
      public Operation QuantizeV2 (  Output input , Output min_range , Output max_range , DataType T, string mode = null , string round_mode = null ,String opName= "QuantizeV2" ) 
      {
         OperationDescription desc = NewOperation("QuantizeV2", opName);
         desc.AddInput(input);
         desc.AddInput(min_range);
         desc.AddInput(max_range);
         desc.SetAttr("T", T);
         if (mode != null) desc.SetAttr("mode", mode);
         if (round_mode != null) desc.SetAttr("round_mode", round_mode);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="concat_dim">Input to the operation. </param>
      ///<param name="values">Input to the operation. </param>
      ///<param name="input_mins">Input to the operation. </param>
      ///<param name="input_maxes">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///[1] output_min(type: DtFloat).
      ///[2] output_max(type: DtFloat).
      ///</return>
      public Operation QuantizedConcat (  Output concat_dim , Output values , Output input_mins , Output input_maxes ,String opName= "QuantizedConcat" ) 
      {
         OperationDescription desc = NewOperation("QuantizedConcat", opName);
         desc.AddInput(concat_dim);
         desc.AddInput(values);
         desc.AddInput(input_mins);
         desc.AddInput(input_maxes);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="tensor">Input to the operation. </param>
      ///<param name="shape">Input to the operation. </param>
      ///<param name="input_min">Input to the operation. </param>
      ///<param name="input_max">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///[1] output_min(type: DtFloat).
      ///[2] output_max(type: DtFloat).
      ///</return>
      public Operation QuantizedReshape (  Output tensor , Output shape , Output input_min , Output input_max ,String opName= "QuantizedReshape" ) 
      {
         OperationDescription desc = NewOperation("QuantizedReshape", opName);
         desc.AddInput(tensor);
         desc.AddInput(shape);
         desc.AddInput(input_min);
         desc.AddInput(input_max);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="gradients">Input to the operation. </param>
      ///<param name="inputs">Input to the operation. </param>
      ///<param name="min"></param>
      ///<param name="max"></param>
      ///<param name="num_bits"></param>
      ///<param name="narrow_range"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] backprops(type: DtFloat).
      ///</return>
      public Operation FakeQuantWithMinMaxArgsGradient (  Output gradients , Output inputs , float min = -6f , float max = 6f , long num_bits = 8 , bool narrow_range = false ,String opName= "FakeQuantWithMinMaxArgsGradient" ) 
      {
         OperationDescription desc = NewOperation("FakeQuantWithMinMaxArgsGradient", opName);
         desc.AddInput(gradients);
         desc.AddInput(inputs);

         if (min != -6f) desc.SetAttr("min", min);
         if (max != 6f) desc.SetAttr("max", max);
         if (num_bits != 8) desc.SetAttr("num_bits", num_bits);
         if (narrow_range != false) desc.SetAttr("narrow_range", narrow_range);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="inputs">Input to the operation. </param>
      ///<param name="min">Input to the operation. </param>
      ///<param name="max">Input to the operation. </param>
      ///<param name="num_bits"></param>
      ///<param name="narrow_range"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] outputs(type: DtFloat).
      ///</return>
      public Operation FakeQuantWithMinMaxVarsPerChannel (  Output inputs , Output min , Output max , long num_bits = 8 , bool narrow_range = false ,String opName= "FakeQuantWithMinMaxVarsPerChannel" ) 
      {
         OperationDescription desc = NewOperation("FakeQuantWithMinMaxVarsPerChannel", opName);
         desc.AddInput(inputs);
         desc.AddInput(min);
         desc.AddInput(max);

         if (num_bits != 8) desc.SetAttr("num_bits", num_bits);
         if (narrow_range != false) desc.SetAttr("narrow_range", narrow_range);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="diagonal">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation BatchMatrixDiag (  Output diagonal ,String opName= "BatchMatrixDiag" ) 
      {
         OperationDescription desc = NewOperation("BatchMatrixDiag", opName);
         desc.AddInput(diagonal);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation IFFT (  Output input ,String opName= "IFFT" ) 
      {
         OperationDescription desc = NewOperation("IFFT", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation FFT2D (  Output input ,String opName= "FFT2D" ) 
      {
         OperationDescription desc = NewOperation("FFT2D", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation FFT3D (  Output input ,String opName= "FFT3D" ) 
      {
         OperationDescription desc = NewOperation("FFT3D", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="fft_length">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtComplex64).
      ///</return>
      public Operation RFFT (  Output input , Output fft_length ,String opName= "RFFT" ) 
      {
         OperationDescription desc = NewOperation("RFFT", opName);
         desc.AddInput(input);
         desc.AddInput(fft_length);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="fft_length">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtFloat).
      ///</return>
      public Operation IRFFT (  Output input , Output fft_length ,String opName= "IRFFT" ) 
      {
         OperationDescription desc = NewOperation("IRFFT", opName);
         desc.AddInput(input);
         desc.AddInput(fft_length);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="fft_length">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtComplex64).
      ///</return>
      public Operation RFFT2D (  Output input , Output fft_length ,String opName= "RFFT2D" ) 
      {
         OperationDescription desc = NewOperation("RFFT2D", opName);
         desc.AddInput(input);
         desc.AddInput(fft_length);


         return desc.FinishOperation();
      } 
      // Skipped function _ScopedAllocatorSplit

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="ksize"></param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="Targmax"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///[1] argmax(type: DtInvalid).
      ///</return>
      public Operation MaxPoolWithArgmax (  Output input , long[] ksize, long[] strides, string padding, DataType? Targmax = null ,String opName= "MaxPoolWithArgmax" ) 
      {
         OperationDescription desc = NewOperation("MaxPoolWithArgmax", opName);
         desc.AddInput(input);
         desc.SetAttr("ksize", ksize);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);
         if (Targmax.HasValue) desc.SetAttr("Targmax", Targmax.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="fft_length">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtFloat).
      ///</return>
      public Operation IRFFT3D (  Output input , Output fft_length ,String opName= "IRFFT3D" ) 
      {
         OperationDescription desc = NewOperation("IRFFT3D", opName);
         desc.AddInput(input);
         desc.AddInput(fft_length);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtComplex64).
      ///</return>
      public Operation BatchFFT2D (  Output input ,String opName= "BatchFFT2D" ) 
      {
         OperationDescription desc = NewOperation("BatchFFT2D", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtComplex64).
      ///</return>
      public Operation BatchFFT3D (  Output input ,String opName= "BatchFFT3D" ) 
      {
         OperationDescription desc = NewOperation("BatchFFT3D", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="value">Input to the operation. </param>
      ///<param name="ksize"></param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="data_format"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation AvgPool (  Output value , long[] ksize, long[] strides, string padding, string data_format = null ,String opName= "AvgPool" ) 
      {
         OperationDescription desc = NewOperation("AvgPool", opName);
         desc.AddInput(value);
         desc.SetAttr("ksize", ksize);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="linear">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="l1">Input to the operation. </param>
      ///<param name="l2">Input to the operation. </param>
      ///<param name="l2_shrinkage">Input to the operation. </param>
      ///<param name="lr_power">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation SparseApplyFtrlV2 (  Output var , Output accum , Output linear , Output grad , Output indices , Output lr , Output l1 , Output l2 , Output l2_shrinkage , Output lr_power , bool use_locking = false ,String opName= "SparseApplyFtrlV2" ) 
      {
         OperationDescription desc = NewOperation("SparseApplyFtrlV2", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(linear);
         desc.AddInput(grad);
         desc.AddInput(indices);
         desc.AddInput(lr);
         desc.AddInput(l1);
         desc.AddInput(l2);
         desc.AddInput(l2_shrinkage);
         desc.AddInput(lr_power);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="axis">Input to the operation. </param>
      ///<param name="exclusive"></param>
      ///<param name="reverse"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation Cumsum (  Output x , Output axis , bool exclusive = false , bool reverse = false ,String opName= "Cumsum" ) 
      {
         OperationDescription desc = NewOperation("Cumsum", opName);
         desc.AddInput(x);
         desc.AddInput(axis);

         if (exclusive != false) desc.SetAttr("exclusive", exclusive);
         if (reverse != false) desc.SetAttr("reverse", reverse);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="t">Input to the operation. </param>
      ///<param name="m">Input to the operation. </param>
      ///<param name="v">Input to the operation. </param>
      ///<param name="beta">Input to the operation. </param>
      ///<param name="gamma">Input to the operation. </param>
      ///<param name="variance_epsilon"></param>
      ///<param name="scale_after_normalization"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] result(type: DtInvalid).
      ///</return>
      public Operation BatchNormWithGlobalNormalization (  Output t , Output m , Output v , Output beta , Output gamma , float variance_epsilon, bool scale_after_normalization,String opName= "BatchNormWithGlobalNormalization" ) 
      {
         OperationDescription desc = NewOperation("BatchNormWithGlobalNormalization", opName);
         desc.AddInput(t);
         desc.AddInput(m);
         desc.AddInput(v);
         desc.AddInput(beta);
         desc.AddInput(gamma);
         desc.SetAttr("variance_epsilon", variance_epsilon);
         desc.SetAttr("scale_after_normalization", scale_after_normalization);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="t">Input to the operation. </param>
      ///<param name="m">Input to the operation. </param>
      ///<param name="v">Input to the operation. </param>
      ///<param name="gamma">Input to the operation. </param>
      ///<param name="backprop">Input to the operation. </param>
      ///<param name="variance_epsilon"></param>
      ///<param name="scale_after_normalization"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] dx(type: DtInvalid).
      ///[1] dm(type: DtInvalid).
      ///[2] dv(type: DtInvalid).
      ///[3] db(type: DtInvalid).
      ///[4] dg(type: DtInvalid).
      ///</return>
      public Operation BatchNormWithGlobalNormalizationGrad (  Output t , Output m , Output v , Output gamma , Output backprop , float variance_epsilon, bool scale_after_normalization,String opName= "BatchNormWithGlobalNormalizationGrad" ) 
      {
         OperationDescription desc = NewOperation("BatchNormWithGlobalNormalizationGrad", opName);
         desc.AddInput(t);
         desc.AddInput(m);
         desc.AddInput(v);
         desc.AddInput(gamma);
         desc.AddInput(backprop);
         desc.SetAttr("variance_epsilon", variance_epsilon);
         desc.SetAttr("scale_after_normalization", scale_after_normalization);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="y_backprop">Input to the operation. </param>
      ///<param name="x">Input to the operation. </param>
      ///<param name="scale">Input to the operation. </param>
      ///<param name="reserve_space_1">Input to the operation. </param>
      ///<param name="reserve_space_2">Input to the operation. </param>
      ///<param name="epsilon"></param>
      ///<param name="data_format"></param>
      ///<param name="is_training"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] x_backprop(type: DtInvalid).
      ///[1] scale_backprop(type: DtInvalid).
      ///[2] offset_backprop(type: DtInvalid).
      ///[3] reserve_space_3(type: DtInvalid).
      ///[4] reserve_space_4(type: DtInvalid).
      ///</return>
      public Operation FusedBatchNormGradV2 (  Output y_backprop , Output x , Output scale , Output reserve_space_1 , Output reserve_space_2 , float epsilon = 0.0001f , string data_format = null , bool is_training = true ,String opName= "FusedBatchNormGradV2" ) 
      {
         OperationDescription desc = NewOperation("FusedBatchNormGradV2", opName);
         desc.AddInput(y_backprop);
         desc.AddInput(x);
         desc.AddInput(scale);
         desc.AddInput(reserve_space_1);
         desc.AddInput(reserve_space_2);

         if (epsilon != 0.0001f) desc.SetAttr("epsilon", epsilon);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         if (is_training != true) desc.SetAttr("is_training", is_training);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="filter">Input to the operation. </param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="use_cudnn_on_gpu"></param>
      ///<param name="data_format"></param>
      ///<param name="dilations"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Conv2D (  Output input , Output filter , long[] strides, string padding, bool use_cudnn_on_gpu = true , string data_format = null , long[] dilations = null ,String opName= "Conv2D" ) 
      {
         OperationDescription desc = NewOperation("Conv2D", opName);
         desc.AddInput(input);
         desc.AddInput(filter);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);
         if (use_cudnn_on_gpu != true) desc.SetAttr("use_cudnn_on_gpu", use_cudnn_on_gpu);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         if (dilations != null) desc.SetAttr("dilations", dilations);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="sp_indices">Input to the operation. </param>
      ///<param name="sp_values">Input to the operation. </param>
      ///<param name="sp_shape">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SparseSoftmax (  Output sp_indices , Output sp_values , Output sp_shape ,String opName= "SparseSoftmax" ) 
      {
         OperationDescription desc = NewOperation("SparseSoftmax", opName);
         desc.AddInput(sp_indices);
         desc.AddInput(sp_values);
         desc.AddInput(sp_shape);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="filter_sizes">Input to the operation. </param>
      ///<param name="out_backprop">Input to the operation. </param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="use_cudnn_on_gpu"></param>
      ///<param name="data_format"></param>
      ///<param name="dilations"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Conv2DBackpropFilter (  Output input , Output filter_sizes , Output out_backprop , long[] strides, string padding, bool use_cudnn_on_gpu = true , string data_format = null , long[] dilations = null ,String opName= "Conv2DBackpropFilter" ) 
      {
         OperationDescription desc = NewOperation("Conv2DBackpropFilter", opName);
         desc.AddInput(input);
         desc.AddInput(filter_sizes);
         desc.AddInput(out_backprop);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);
         if (use_cudnn_on_gpu != true) desc.SetAttr("use_cudnn_on_gpu", use_cudnn_on_gpu);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         if (dilations != null) desc.SetAttr("dilations", dilations);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="pattern"></param>
      ///<param name="rewrite"></param>
      ///<param name="replace_global"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtString).
      ///</return>
      public Operation StaticRegexReplace (  Output input , string pattern, string rewrite, bool replace_global = true ,String opName= "StaticRegexReplace" ) 
      {
         OperationDescription desc = NewOperation("StaticRegexReplace", opName);
         desc.AddInput(input);
         desc.SetAttr("pattern", pattern);
         desc.SetAttr("rewrite", rewrite);
         if (replace_global != true) desc.SetAttr("replace_global", replace_global);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Square (  Output x ,String opName= "Square" ) 
      {
         OperationDescription desc = NewOperation("Square", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="src_format"></param>
      ///<param name="dst_format"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation DataFormatVecPermute (  Output x , string src_format = null , string dst_format = null ,String opName= "DataFormatVecPermute" ) 
      {
         OperationDescription desc = NewOperation("DataFormatVecPermute", opName);
         desc.AddInput(x);

         if (src_format != null) desc.SetAttr("src_format", src_format);
         if (dst_format != null) desc.SetAttr("dst_format", dst_format);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="size">Input to the operation. </param>
      ///<param name="paddings">Input to the operation. </param>
      ///<param name="filter">Input to the operation. </param>
      ///<param name="mode"></param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="resize_align_corners"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation FusedResizeAndPadConv2D (  Output input , Output size , Output paddings , Output filter , string mode, long[] strides, string padding, bool resize_align_corners = false ,String opName= "FusedResizeAndPadConv2D" ) 
      {
         OperationDescription desc = NewOperation("FusedResizeAndPadConv2D", opName);
         desc.AddInput(input);
         desc.AddInput(size);
         desc.AddInput(paddings);
         desc.AddInput(filter);
         desc.SetAttr("mode", mode);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);
         if (resize_align_corners != false) desc.SetAttr("resize_align_corners", resize_align_corners);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="sp_indices">Input to the operation. </param>
      ///<param name="sp_values">Input to the operation. </param>
      ///<param name="sp_shape">Input to the operation. </param>
      ///<param name="dense">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SparseDenseCwiseMul (  Output sp_indices , Output sp_values , Output sp_shape , Output dense ,String opName= "SparseDenseCwiseMul" ) 
      {
         OperationDescription desc = NewOperation("SparseDenseCwiseMul", opName);
         desc.AddInput(sp_indices);
         desc.AddInput(sp_values);
         desc.AddInput(sp_shape);
         desc.AddInput(dense);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="logits">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] logsoftmax(type: DtInvalid).
      ///</return>
      public Operation LogSoftmax (  Output logits ,String opName= "LogSoftmax" ) 
      {
         OperationDescription desc = NewOperation("LogSoftmax", opName);
         desc.AddInput(logits);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="paddings">Input to the operation. </param>
      ///<param name="filter">Input to the operation. </param>
      ///<param name="mode"></param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation FusedPadConv2D (  Output input , Output paddings , Output filter , string mode, long[] strides, string padding,String opName= "FusedPadConv2D" ) 
      {
         OperationDescription desc = NewOperation("FusedPadConv2D", opName);
         desc.AddInput(input);
         desc.AddInput(paddings);
         desc.AddInput(filter);
         desc.SetAttr("mode", mode);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="m">Input to the operation. </param>
      ///<param name="v">Input to the operation. </param>
      ///<param name="beta1_power">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="beta1">Input to the operation. </param>
      ///<param name="beta2">Input to the operation. </param>
      ///<param name="epsilon">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation ApplyAdaMax (  Output var , Output m , Output v , Output beta1_power , Output lr , Output beta1 , Output beta2 , Output epsilon , Output grad , bool use_locking = false ,String opName= "ApplyAdaMax" ) 
      {
         OperationDescription desc = NewOperation("ApplyAdaMax", opName);
         desc.AddInput(var);
         desc.AddInput(m);
         desc.AddInput(v);
         desc.AddInput(beta1_power);
         desc.AddInput(lr);
         desc.AddInput(beta1);
         desc.AddInput(beta2);
         desc.AddInput(epsilon);
         desc.AddInput(grad);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="filter">Input to the operation. </param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="data_format"></param>
      ///<param name="dilations"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation DepthwiseConv2dNative (  Output input , Output filter , long[] strides, string padding, string data_format = null , long[] dilations = null ,String opName= "DepthwiseConv2dNative" ) 
      {
         OperationDescription desc = NewOperation("DepthwiseConv2dNative", opName);
         desc.AddInput(input);
         desc.AddInput(filter);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         if (dilations != null) desc.SetAttr("dilations", dilations);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="accum_update">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="rho">Input to the operation. </param>
      ///<param name="epsilon">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation SparseApplyAdadelta (  Output var , Output accum , Output accum_update , Output lr , Output rho , Output epsilon , Output grad , Output indices , bool use_locking = false ,String opName= "SparseApplyAdadelta" ) 
      {
         OperationDescription desc = NewOperation("SparseApplyAdadelta", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(accum_update);
         desc.AddInput(lr);
         desc.AddInput(rho);
         desc.AddInput(epsilon);
         desc.AddInput(grad);
         desc.AddInput(indices);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="filter_sizes">Input to the operation. </param>
      ///<param name="out_backprop">Input to the operation. </param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="data_format"></param>
      ///<param name="dilations"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation DepthwiseConv2dNativeBackpropFilter (  Output input , Output filter_sizes , Output out_backprop , long[] strides, string padding, string data_format = null , long[] dilations = null ,String opName= "DepthwiseConv2dNativeBackpropFilter" ) 
      {
         OperationDescription desc = NewOperation("DepthwiseConv2dNativeBackpropFilter", opName);
         desc.AddInput(input);
         desc.AddInput(filter_sizes);
         desc.AddInput(out_backprop);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         if (dilations != null) desc.SetAttr("dilations", dilations);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="ksize"></param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="data_format"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation AvgPool3D (  Output input , long[] ksize, long[] strides, string padding, string data_format = null ,String opName= "AvgPool3D" ) 
      {
         OperationDescription desc = NewOperation("AvgPool3D", opName);
         desc.AddInput(input);
         desc.SetAttr("ksize", ksize);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Erf (  Output x ,String opName= "Erf" ) 
      {
         OperationDescription desc = NewOperation("Erf", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="ksize"></param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="data_format"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation MaxPool3D (  Output input , long[] ksize, long[] strides, string padding, string data_format = null ,String opName= "MaxPool3D" ) 
      {
         OperationDescription desc = NewOperation("MaxPool3D", opName);
         desc.AddInput(input);
         desc.SetAttr("ksize", ksize);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="orig_input">Input to the operation. </param>
      ///<param name="orig_output">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="ksize"></param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="data_format"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation MaxPool3DGrad (  Output orig_input , Output orig_output , Output grad , long[] ksize, long[] strides, string padding, string data_format = null ,String opName= "MaxPool3DGrad" ) 
      {
         OperationDescription desc = NewOperation("MaxPool3DGrad", opName);
         desc.AddInput(orig_input);
         desc.AddInput(orig_output);
         desc.AddInput(grad);
         desc.SetAttr("ksize", ksize);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="orig_input">Input to the operation. </param>
      ///<param name="orig_output">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="ksize"></param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="data_format"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation MaxPool3DGradGrad (  Output orig_input , Output orig_output , Output grad , long[] ksize, long[] strides, string padding, string data_format = null ,String opName= "MaxPool3DGradGrad" ) 
      {
         OperationDescription desc = NewOperation("MaxPool3DGradGrad", opName);
         desc.AddInput(orig_input);
         desc.AddInput(orig_output);
         desc.AddInput(grad);
         desc.SetAttr("ksize", ksize);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="cond">Input to the operation. </param>
      ///<param name="input">Input to the operation. </param>
      ///<param name="Tout"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      //The following attributes are not known: then_branch: func; else_branch: func
      public Operation StatelessIf (  Output cond , Output input , DataType[] Tout,String opName= "StatelessIf" ) 
      {
         OperationDescription desc = NewOperation("StatelessIf", opName);
         desc.AddInput(cond);
         desc.AddInput(input);
         desc.SetAttr("Tout", Tout);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reference">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="updates">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_ref(type: DtInvalid).
      ///</return>
      public Operation ScatterDiv (  Output reference , Output indices , Output updates , bool use_locking = false ,String opName= "ScatterDiv" ) 
      {
         OperationDescription desc = NewOperation("ScatterDiv", opName);
         desc.AddInput(reference);
         desc.AddInput(indices);
         desc.AddInput(updates);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="t">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation L2Loss (  Output t ,String opName= "L2Loss" ) 
      {
         OperationDescription desc = NewOperation("L2Loss", opName);
         desc.AddInput(t);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="depth_radius"></param>
      ///<param name="bias"></param>
      ///<param name="alpha"></param>
      ///<param name="beta"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation LRN (  Output input , long depth_radius = 5 , float bias = 1f , float alpha = 1f , float beta = 0.5f ,String opName= "LRN" ) 
      {
         OperationDescription desc = NewOperation("LRN", opName);
         desc.AddInput(input);

         if (depth_radius != 5) desc.SetAttr("depth_radius", depth_radius);
         if (bias != 1f) desc.SetAttr("bias", bias);
         if (alpha != 1f) desc.SetAttr("alpha", alpha);
         if (beta != 0.5f) desc.SetAttr("beta", beta);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="segment_ids">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SegmentMean (  Output data , Output segment_ids ,String opName= "SegmentMean" ) 
      {
         OperationDescription desc = NewOperation("SegmentMean", opName);
         desc.AddInput(data);
         desc.AddInput(segment_ids);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_grads">Input to the operation. </param>
      ///<param name="input_image">Input to the operation. </param>
      ///<param name="output_image">Input to the operation. </param>
      ///<param name="depth_radius"></param>
      ///<param name="bias"></param>
      ///<param name="alpha"></param>
      ///<param name="beta"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation LRNGrad (  Output input_grads , Output input_image , Output output_image , long depth_radius = 5 , float bias = 1f , float alpha = 1f , float beta = 0.5f ,String opName= "LRNGrad" ) 
      {
         OperationDescription desc = NewOperation("LRNGrad", opName);
         desc.AddInput(input_grads);
         desc.AddInput(input_image);
         desc.AddInput(output_image);

         if (depth_radius != 5) desc.SetAttr("depth_radius", depth_radius);
         if (bias != 1f) desc.SetAttr("bias", bias);
         if (alpha != 1f) desc.SetAttr("alpha", alpha);
         if (beta != 0.5f) desc.SetAttr("beta", beta);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="orig_input">Input to the operation. </param>
      ///<param name="orig_output">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="ksize"></param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="data_format"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation MaxPoolGrad (  Output orig_input , Output orig_output , Output grad , long[] ksize, long[] strides, string padding, string data_format = null ,String opName= "MaxPoolGrad" ) 
      {
         OperationDescription desc = NewOperation("MaxPoolGrad", opName);
         desc.AddInput(orig_input);
         desc.AddInput(orig_output);
         desc.AddInput(grad);
         desc.SetAttr("ksize", ksize);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="orig_input">Input to the operation. </param>
      ///<param name="orig_output">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="ksize">Input to the operation. </param>
      ///<param name="strides">Input to the operation. </param>
      ///<param name="padding"></param>
      ///<param name="data_format"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation MaxPoolGradV2 (  Output orig_input , Output orig_output , Output grad , Output ksize , Output strides , string padding, string data_format = null ,String opName= "MaxPoolGradV2" ) 
      {
         OperationDescription desc = NewOperation("MaxPoolGradV2", opName);
         desc.AddInput(orig_input);
         desc.AddInput(orig_output);
         desc.AddInput(grad);
         desc.AddInput(ksize);
         desc.AddInput(strides);
         desc.SetAttr("padding", padding);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="features">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] activations(type: DtInvalid).
      ///</return>
      public Operation Elu (  Output features ,String opName= "Elu" ) 
      {
         OperationDescription desc = NewOperation("Elu", opName);
         desc.AddInput(features);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="orig_input">Input to the operation. </param>
      ///<param name="orig_output">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="ksize">Input to the operation. </param>
      ///<param name="strides">Input to the operation. </param>
      ///<param name="padding"></param>
      ///<param name="data_format"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation MaxPoolGradGradV2 (  Output orig_input , Output orig_output , Output grad , Output ksize , Output strides , string padding, string data_format = null ,String opName= "MaxPoolGradGradV2" ) 
      {
         OperationDescription desc = NewOperation("MaxPoolGradGradV2", opName);
         desc.AddInput(orig_input);
         desc.AddInput(orig_output);
         desc.AddInput(grad);
         desc.AddInput(ksize);
         desc.AddInput(strides);
         desc.SetAttr("padding", padding);
         if (data_format != null) desc.SetAttr("data_format", data_format);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="argmax">Input to the operation. </param>
      ///<param name="ksize"></param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation MaxPoolGradGradWithArgmax (  Output input , Output grad , Output argmax , long[] ksize, long[] strides, string padding,String opName= "MaxPoolGradGradWithArgmax" ) 
      {
         OperationDescription desc = NewOperation("MaxPoolGradGradWithArgmax", opName);
         desc.AddInput(input);
         desc.AddInput(grad);
         desc.AddInput(argmax);
         desc.SetAttr("ksize", ksize);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Neg (  Output x ,String opName= "Neg" ) 
      {
         OperationDescription desc = NewOperation("Neg", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="filter">Input to the operation. </param>
      ///<param name="strides"></param>
      ///<param name="rates"></param>
      ///<param name="padding"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Dilation2D (  Output input , Output filter , long[] strides, long[] rates, string padding,String opName= "Dilation2D" ) 
      {
         OperationDescription desc = NewOperation("Dilation2D", opName);
         desc.AddInput(input);
         desc.AddInput(filter);
         desc.SetAttr("strides", strides);
         desc.SetAttr("rates", rates);
         desc.SetAttr("padding", padding);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="filter">Input to the operation. </param>
      ///<param name="out_backprop">Input to the operation. </param>
      ///<param name="strides"></param>
      ///<param name="rates"></param>
      ///<param name="padding"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] in_backprop(type: DtInvalid).
      ///</return>
      public Operation Dilation2DBackpropInput (  Output input , Output filter , Output out_backprop , long[] strides, long[] rates, string padding,String opName= "Dilation2DBackpropInput" ) 
      {
         OperationDescription desc = NewOperation("Dilation2DBackpropInput", opName);
         desc.AddInput(input);
         desc.AddInput(filter);
         desc.AddInput(out_backprop);
         desc.SetAttr("strides", strides);
         desc.SetAttr("rates", rates);
         desc.SetAttr("padding", padding);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="filter">Input to the operation. </param>
      ///<param name="out_backprop">Input to the operation. </param>
      ///<param name="strides"></param>
      ///<param name="rates"></param>
      ///<param name="padding"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] filter_backprop(type: DtInvalid).
      ///</return>
      public Operation Dilation2DBackpropFilter (  Output input , Output filter , Output out_backprop , long[] strides, long[] rates, string padding,String opName= "Dilation2DBackpropFilter" ) 
      {
         OperationDescription desc = NewOperation("Dilation2DBackpropFilter", opName);
         desc.AddInput(input);
         desc.AddInput(filter);
         desc.AddInput(out_backprop);
         desc.SetAttr("strides", strides);
         desc.SetAttr("rates", rates);
         desc.SetAttr("padding", padding);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="features">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] activations(type: DtInvalid).
      ///</return>
      public Operation Relu (  Output features ,String opName= "Relu" ) 
      {
         OperationDescription desc = NewOperation("Relu", opName);
         desc.AddInput(features);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="features">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] activations(type: DtInvalid).
      ///</return>
      public Operation Selu (  Output features ,String opName= "Selu" ) 
      {
         OperationDescription desc = NewOperation("Selu", opName);
         desc.AddInput(features);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="gradients">Input to the operation. </param>
      ///<param name="features">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] backprops(type: DtInvalid).
      ///</return>
      public Operation SoftplusGrad (  Output gradients , Output features ,String opName= "SoftplusGrad" ) 
      {
         OperationDescription desc = NewOperation("SoftplusGrad", opName);
         desc.AddInput(gradients);
         desc.AddInput(features);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="features">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] activations(type: DtInvalid).
      ///</return>
      public Operation Softsign (  Output features ,String opName= "Softsign" ) 
      {
         OperationDescription desc = NewOperation("Softsign", opName);
         desc.AddInput(features);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="gradients">Input to the operation. </param>
      ///<param name="features">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] backprops(type: DtInvalid).
      ///</return>
      public Operation SoftsignGrad (  Output gradients , Output features ,String opName= "SoftsignGrad" ) 
      {
         OperationDescription desc = NewOperation("SoftsignGrad", opName);
         desc.AddInput(gradients);
         desc.AddInput(features);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Erfc (  Output x ,String opName= "Erfc" ) 
      {
         OperationDescription desc = NewOperation("Erfc", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="y">Input to the operation. </param>
      ///<param name="dy">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation ReciprocalGrad (  Output y , Output dy ,String opName= "ReciprocalGrad" ) 
      {
         OperationDescription desc = NewOperation("ReciprocalGrad", opName);
         desc.AddInput(y);
         desc.AddInput(dy);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="logits">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] softmax(type: DtInvalid).
      ///</return>
      public Operation Softmax (  Output logits ,String opName= "Softmax" ) 
      {
         OperationDescription desc = NewOperation("Softmax", opName);
         desc.AddInput(logits);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="min_x">Input to the operation. </param>
      ///<param name="max_x">Input to the operation. </param>
      ///<param name="min_y">Input to the operation. </param>
      ///<param name="max_y">Input to the operation. </param>
      ///<param name="Toutput"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///[1] min_z(type: DtFloat).
      ///[2] max_z(type: DtFloat).
      ///</return>
      public Operation QuantizedMul (  Output x , Output y , Output min_x , Output max_x , Output min_y , Output max_y , DataType? Toutput = null ,String opName= "QuantizedMul" ) 
      {
         OperationDescription desc = NewOperation("QuantizedMul", opName);
         desc.AddInput(x);
         desc.AddInput(y);
         desc.AddInput(min_x);
         desc.AddInput(max_x);
         desc.AddInput(min_y);
         desc.AddInput(max_y);

         if (Toutput.HasValue) desc.SetAttr("Toutput", Toutput.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="features">Input to the operation. </param>
      ///<param name="labels">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] loss(type: DtInvalid).
      ///[1] backprop(type: DtInvalid).
      ///</return>
      public Operation SoftmaxCrossEntropyWithLogits (  Output features , Output labels ,String opName= "SoftmaxCrossEntropyWithLogits" ) 
      {
         OperationDescription desc = NewOperation("SoftmaxCrossEntropyWithLogits", opName);
         desc.AddInput(features);
         desc.AddInput(labels);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="features">Input to the operation. </param>
      ///<param name="labels">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] loss(type: DtInvalid).
      ///[1] backprop(type: DtInvalid).
      ///</return>
      public Operation SparseSoftmaxCrossEntropyWithLogits (  Output features , Output labels ,String opName= "SparseSoftmaxCrossEntropyWithLogits" ) 
      {
         OperationDescription desc = NewOperation("SparseSoftmaxCrossEntropyWithLogits", opName);
         desc.AddInput(features);
         desc.AddInput(labels);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="shape">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation RandomUniform (  Output shape , DataType dtype, long seed = 0 , long seed2 = 0 ,String opName= "RandomUniform" ) 
      {
         OperationDescription desc = NewOperation("RandomUniform", opName);
         desc.AddInput(shape);
         desc.SetAttr("dtype", dtype);
         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="value">Input to the operation. </param>
      ///<param name="pooling_ratio"></param>
      ///<param name="pseudo_random"></param>
      ///<param name="overlapping"></param>
      ///<param name="deterministic"></param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///[1] row_pooling_sequence(type: DtInt64).
      ///[2] col_pooling_sequence(type: DtInt64).
      ///</return>
      public Operation FractionalMaxPool (  Output value , float[] pooling_ratio, bool pseudo_random = false , bool overlapping = false , bool deterministic = false , long seed = 0 , long seed2 = 0 ,String opName= "FractionalMaxPool" ) 
      {
         OperationDescription desc = NewOperation("FractionalMaxPool", opName);
         desc.AddInput(value);
         desc.SetAttr("pooling_ratio", pooling_ratio);
         if (pseudo_random != false) desc.SetAttr("pseudo_random", pseudo_random);
         if (overlapping != false) desc.SetAttr("overlapping", overlapping);
         if (deterministic != false) desc.SetAttr("deterministic", deterministic);
         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="args">Input to the operation. </param>
      ///<param name="Tout"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      //The following attributes are not known: f: func
      public Operation PartitionedCall (  Output args , DataType[] Tout,String opName= "PartitionedCall" ) 
      {
         OperationDescription desc = NewOperation("PartitionedCall", opName);
         desc.AddInput(args);
         desc.SetAttr("Tout", Tout);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="min_input">Input to the operation. </param>
      ///<param name="max_input">Input to the operation. </param>
      ///<param name="ksize"></param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///[1] min_output(type: DtFloat).
      ///[2] max_output(type: DtFloat).
      ///</return>
      public Operation QuantizedAvgPool (  Output input , Output min_input , Output max_input , long[] ksize, long[] strides, string padding,String opName= "QuantizedAvgPool" ) 
      {
         OperationDescription desc = NewOperation("QuantizedAvgPool", opName);
         desc.AddInput(input);
         desc.AddInput(min_input);
         desc.AddInput(max_input);
         desc.SetAttr("ksize", ksize);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="bias">Input to the operation. </param>
      ///<param name="min_input">Input to the operation. </param>
      ///<param name="max_input">Input to the operation. </param>
      ///<param name="min_bias">Input to the operation. </param>
      ///<param name="max_bias">Input to the operation. </param>
      ///<param name="out_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///[1] min_out(type: DtFloat).
      ///[2] max_out(type: DtFloat).
      ///</return>
      public Operation QuantizedBiasAdd (  Output input , Output bias , Output min_input , Output max_input , Output min_bias , Output max_bias , DataType out_type,String opName= "QuantizedBiasAdd" ) 
      {
         OperationDescription desc = NewOperation("QuantizedBiasAdd", opName);
         desc.AddInput(input);
         desc.AddInput(bias);
         desc.AddInput(min_input);
         desc.AddInput(max_input);
         desc.AddInput(min_bias);
         desc.AddInput(max_bias);
         desc.SetAttr("out_type", out_type);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="filter">Input to the operation. </param>
      ///<param name="min_input">Input to the operation. </param>
      ///<param name="max_input">Input to the operation. </param>
      ///<param name="min_filter">Input to the operation. </param>
      ///<param name="max_filter">Input to the operation. </param>
      ///<param name="strides"></param>
      ///<param name="padding"></param>
      ///<param name="out_type"></param>
      ///<param name="dilations"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///[1] min_output(type: DtFloat).
      ///[2] max_output(type: DtFloat).
      ///</return>
      public Operation QuantizedConv2D (  Output input , Output filter , Output min_input , Output max_input , Output min_filter , Output max_filter , long[] strides, string padding, DataType? out_type = null , long[] dilations = null ,String opName= "QuantizedConv2D" ) 
      {
         OperationDescription desc = NewOperation("QuantizedConv2D", opName);
         desc.AddInput(input);
         desc.AddInput(filter);
         desc.AddInput(min_input);
         desc.AddInput(max_input);
         desc.AddInput(min_filter);
         desc.AddInput(max_filter);
         desc.SetAttr("strides", strides);
         desc.SetAttr("padding", padding);
         if (out_type.HasValue) desc.SetAttr("out_type", out_type.Value);
         if (dilations != null) desc.SetAttr("dilations", dilations);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="features">Input to the operation. </param>
      ///<param name="min_features">Input to the operation. </param>
      ///<param name="max_features">Input to the operation. </param>
      ///<param name="out_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] activations(type: DtInvalid).
      ///[1] min_activations(type: DtFloat).
      ///[2] max_activations(type: DtFloat).
      ///</return>
      public Operation QuantizedRelu (  Output features , Output min_features , Output max_features , DataType? out_type = null ,String opName= "QuantizedRelu" ) 
      {
         OperationDescription desc = NewOperation("QuantizedRelu", opName);
         desc.AddInput(features);
         desc.AddInput(min_features);
         desc.AddInput(max_features);

         if (out_type.HasValue) desc.SetAttr("out_type", out_type.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="features">Input to the operation. </param>
      ///<param name="min_features">Input to the operation. </param>
      ///<param name="max_features">Input to the operation. </param>
      ///<param name="out_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] activations(type: DtInvalid).
      ///[1] min_activations(type: DtFloat).
      ///[2] max_activations(type: DtFloat).
      ///</return>
      public Operation QuantizedRelu6 (  Output features , Output min_features , Output max_features , DataType? out_type = null ,String opName= "QuantizedRelu6" ) 
      {
         OperationDescription desc = NewOperation("QuantizedRelu6", opName);
         desc.AddInput(features);
         desc.AddInput(min_features);
         desc.AddInput(max_features);

         if (out_type.HasValue) desc.SetAttr("out_type", out_type.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="features">Input to the operation. </param>
      ///<param name="max_value">Input to the operation. </param>
      ///<param name="min_features">Input to the operation. </param>
      ///<param name="max_features">Input to the operation. </param>
      ///<param name="out_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] activations(type: DtInvalid).
      ///[1] min_activations(type: DtFloat).
      ///[2] max_activations(type: DtFloat).
      ///</return>
      public Operation QuantizedReluX (  Output features , Output max_value , Output min_features , Output max_features , DataType? out_type = null ,String opName= "QuantizedReluX" ) 
      {
         OperationDescription desc = NewOperation("QuantizedReluX", opName);
         desc.AddInput(features);
         desc.AddInput(max_value);
         desc.AddInput(min_features);
         desc.AddInput(max_features);

         if (out_type.HasValue) desc.SetAttr("out_type", out_type.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="reduction_indices">Input to the operation. </param>
      ///<param name="keep_dims"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtBool).
      ///</return>
      public Operation All (  Output input , Output reduction_indices , bool keep_dims = false ,String opName= "All" ) 
      {
         OperationDescription desc = NewOperation("All", opName);
         desc.AddInput(input);
         desc.AddInput(reduction_indices);

         if (keep_dims != false) desc.SetAttr("keep_dims", keep_dims);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="t">Input to the operation. </param>
      ///<param name="t_min">Input to the operation. </param>
      ///<param name="t_max">Input to the operation. </param>
      ///<param name="m">Input to the operation. </param>
      ///<param name="m_min">Input to the operation. </param>
      ///<param name="m_max">Input to the operation. </param>
      ///<param name="v">Input to the operation. </param>
      ///<param name="v_min">Input to the operation. </param>
      ///<param name="v_max">Input to the operation. </param>
      ///<param name="beta">Input to the operation. </param>
      ///<param name="beta_min">Input to the operation. </param>
      ///<param name="beta_max">Input to the operation. </param>
      ///<param name="gamma">Input to the operation. </param>
      ///<param name="gamma_min">Input to the operation. </param>
      ///<param name="gamma_max">Input to the operation. </param>
      ///<param name="out_type"></param>
      ///<param name="variance_epsilon"></param>
      ///<param name="scale_after_normalization"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] result(type: DtInvalid).
      ///[1] result_min(type: DtFloat).
      ///[2] result_max(type: DtFloat).
      ///</return>
      public Operation QuantizedBatchNormWithGlobalNormalization (  Output t , Output t_min , Output t_max , Output m , Output m_min , Output m_max , Output v , Output v_min , Output v_max , Output beta , Output beta_min , Output beta_max , Output gamma , Output gamma_min , Output gamma_max , DataType out_type, float variance_epsilon, bool scale_after_normalization,String opName= "QuantizedBatchNormWithGlobalNormalization" ) 
      {
         OperationDescription desc = NewOperation("QuantizedBatchNormWithGlobalNormalization", opName);
         desc.AddInput(t);
         desc.AddInput(t_min);
         desc.AddInput(t_max);
         desc.AddInput(m);
         desc.AddInput(m_min);
         desc.AddInput(m_max);
         desc.AddInput(v);
         desc.AddInput(v_min);
         desc.AddInput(v_max);
         desc.AddInput(beta);
         desc.AddInput(beta_min);
         desc.AddInput(beta_max);
         desc.AddInput(gamma);
         desc.AddInput(gamma_min);
         desc.AddInput(gamma_max);
         desc.SetAttr("out_type", out_type);
         desc.SetAttr("variance_epsilon", variance_epsilon);
         desc.SetAttr("scale_after_normalization", scale_after_normalization);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="bytes">Input to the operation. </param>
      ///<param name="out_type"></param>
      ///<param name="little_endian"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation DecodeRaw (  Output bytes , DataType out_type, bool little_endian = true ,String opName= "DecodeRaw" ) 
      {
         OperationDescription desc = NewOperation("DecodeRaw", opName);
         desc.AddInput(bytes);
         desc.SetAttr("out_type", out_type);
         if (little_endian != true) desc.SetAttr("little_endian", little_endian);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="bytes">Input to the operation. </param>
      ///<param name="compression_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtString).
      ///</return>
      public Operation DecodeCompressed (  Output bytes , string compression_type = null ,String opName= "DecodeCompressed" ) 
      {
         OperationDescription desc = NewOperation("DecodeCompressed", opName);
         desc.AddInput(bytes);

         if (compression_type != null) desc.SetAttr("compression_type", compression_type);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="serialized">Input to the operation. </param>
      ///<param name="names">Input to the operation. </param>
      ///<param name="sparse_keys">Input to the operation. </param>
      ///<param name="dense_keys">Input to the operation. </param>
      ///<param name="dense_defaults">Input to the operation. </param>
      ///<param name="sparse_types"></param>
      ///<param name="dense_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] sparse_indices(type: DtInt64).
      ///[1] sparse_values(type: DtInvalid).
      ///[2] sparse_shapes(type: DtInt64).
      ///[3] dense_values(type: DtInvalid).
      ///</return>
      public Operation ParseExample (  Output serialized , Output names , Output sparse_keys , Output dense_keys , Output dense_defaults , DataType[] sparse_types, long[][] dense_shapes,String opName= "ParseExample" ) 
      {
         OperationDescription desc = NewOperation("ParseExample", opName);
         desc.AddInput(serialized);
         desc.AddInput(names);
         desc.AddInput(sparse_keys);
         desc.AddInput(dense_keys);
         desc.AddInput(dense_defaults);
         desc.SetAttr("sparse_types", sparse_types);
         desc.SetAttrShapeList("dense_shapes", dense_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="serialized">Input to the operation. </param>
      ///<param name="dense_defaults">Input to the operation. </param>
      ///<param name="num_sparse"></param>
      ///<param name="sparse_keys"></param>
      ///<param name="dense_keys"></param>
      ///<param name="sparse_types"></param>
      ///<param name="dense_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] sparse_indices(type: DtInt64).
      ///[1] sparse_values(type: DtInvalid).
      ///[2] sparse_shapes(type: DtInt64).
      ///[3] dense_values(type: DtInvalid).
      ///</return>
      public Operation ParseSingleExample (  Output serialized , Output dense_defaults , long num_sparse, string[] sparse_keys, string[] dense_keys, DataType[] sparse_types, long[][] dense_shapes,String opName= "ParseSingleExample" ) 
      {
         OperationDescription desc = NewOperation("ParseSingleExample", opName);
         desc.AddInput(serialized);
         desc.AddInput(dense_defaults);
         desc.SetAttr("num_sparse", num_sparse);
         desc.SetAttr("sparse_keys", sparse_keys);
         desc.SetAttr("dense_keys", dense_keys);
         desc.SetAttr("sparse_types", sparse_types);
         desc.SetAttrShapeList("dense_shapes", dense_shapes);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="serialized">Input to the operation. </param>
      ///<param name="debug_name">Input to the operation. </param>
      ///<param name="context_dense_defaults">Input to the operation. </param>
      ///<param name="feature_list_dense_missing_assumed_empty"></param>
      ///<param name="context_sparse_keys"></param>
      ///<param name="context_dense_keys"></param>
      ///<param name="feature_list_sparse_keys"></param>
      ///<param name="feature_list_dense_keys"></param>
      ///<param name="Ncontext_sparse"></param>
      ///<param name="Ncontext_dense"></param>
      ///<param name="Nfeature_list_sparse"></param>
      ///<param name="Nfeature_list_dense"></param>
      ///<param name="context_sparse_types"></param>
      ///<param name="feature_list_dense_types"></param>
      ///<param name="context_dense_shapes"></param>
      ///<param name="feature_list_sparse_types"></param>
      ///<param name="feature_list_dense_shapes"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] context_sparse_indices(type: DtInt64).
      ///[1] context_sparse_values(type: DtInvalid).
      ///[2] context_sparse_shapes(type: DtInt64).
      ///[3] context_dense_values(type: DtInvalid).
      ///[4] feature_list_sparse_indices(type: DtInt64).
      ///[5] feature_list_sparse_values(type: DtInvalid).
      ///[6] feature_list_sparse_shapes(type: DtInt64).
      ///[7] feature_list_dense_values(type: DtInvalid).
      ///[8] feature_list_dense_lengths(type: DtInt64).
      ///</return>
      public Operation ParseSequenceExample (  Output serialized , Output debug_name , Output context_dense_defaults , string[] feature_list_dense_missing_assumed_empty, string[] context_sparse_keys, string[] context_dense_keys, string[] feature_list_sparse_keys, string[] feature_list_dense_keys, long Ncontext_sparse = 0 , long Ncontext_dense = 0 , long Nfeature_list_sparse = 0 , long Nfeature_list_dense = 0 , DataType[] context_sparse_types = null , DataType[] feature_list_dense_types = null , long[][] context_dense_shapes = null , DataType[] feature_list_sparse_types = null , long[][] feature_list_dense_shapes = null ,String opName= "ParseSequenceExample" ) 
      {
         OperationDescription desc = NewOperation("ParseSequenceExample", opName);
         desc.AddInput(serialized);
         desc.AddInput(debug_name);
         desc.AddInput(context_dense_defaults);
         desc.SetAttr("feature_list_dense_missing_assumed_empty", feature_list_dense_missing_assumed_empty);
         desc.SetAttr("context_sparse_keys", context_sparse_keys);
         desc.SetAttr("context_dense_keys", context_dense_keys);
         desc.SetAttr("feature_list_sparse_keys", feature_list_sparse_keys);
         desc.SetAttr("feature_list_dense_keys", feature_list_dense_keys);
         if (Ncontext_sparse != 0) desc.SetAttr("Ncontext_sparse", Ncontext_sparse);
         if (Ncontext_dense != 0) desc.SetAttr("Ncontext_dense", Ncontext_dense);
         if (Nfeature_list_sparse != 0) desc.SetAttr("Nfeature_list_sparse", Nfeature_list_sparse);
         if (Nfeature_list_dense != 0) desc.SetAttr("Nfeature_list_dense", Nfeature_list_dense);
         if (context_sparse_types != null) desc.SetAttr("context_sparse_types", context_sparse_types);
         if (feature_list_dense_types != null) desc.SetAttr("feature_list_dense_types", feature_list_dense_types);
         if (context_dense_shapes != null) desc.SetAttrShapeList("context_dense_shapes", context_dense_shapes);
         if (feature_list_sparse_types != null) desc.SetAttr("feature_list_sparse_types", feature_list_sparse_types);
         if (feature_list_dense_shapes != null) desc.SetAttrShapeList("feature_list_dense_shapes", feature_list_dense_shapes);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="string_tensor">Input to the operation. </param>
      ///<param name="out_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation StringToNumber (  Output string_tensor , DataType? out_type = null ,String opName= "StringToNumber" ) 
      {
         OperationDescription desc = NewOperation("StringToNumber", opName);
         desc.AddInput(string_tensor);

         if (out_type.HasValue) desc.SetAttr("out_type", out_type.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="m">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="logbase">Input to the operation. </param>
      ///<param name="sign_decay">Input to the operation. </param>
      ///<param name="beta">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceApplyPowerSign (  Output var , Output m , Output lr , Output logbase , Output sign_decay , Output beta , Output grad , bool use_locking = false ,String opName= "ResourceApplyPowerSign" ) 
      {
         OperationDescription desc = NewOperation("ResourceApplyPowerSign", opName);
         desc.AddInput(var);
         desc.AddInput(m);
         desc.AddInput(lr);
         desc.AddInput(logbase);
         desc.AddInput(sign_decay);
         desc.AddInput(beta);
         desc.AddInput(grad);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="inputs">Input to the operation. </param>
      ///<param name="Toutputs"></param>
      ///<param name="serialized_remote_fused_graph_execute_info"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] outputs(type: DtInvalid).
      ///</return>
      public Operation RemoteFusedGraphExecute (  Output inputs , DataType[] Toutputs, string serialized_remote_fused_graph_execute_info,String opName= "RemoteFusedGraphExecute" ) 
      {
         OperationDescription desc = NewOperation("RemoteFusedGraphExecute", opName);
         desc.AddInput(inputs);
         desc.SetAttr("Toutputs", Toutputs);
         desc.SetAttr("serialized_remote_fused_graph_execute_info", serialized_remote_fused_graph_execute_info);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="dtype"></param>
      ///<param name="shape"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] resource(type: DtResource).
      ///</return>
      public Operation VarHandleOp (  DataType dtype, long[] shape, string container = null , string shared_name = null ,String opName= "VarHandleOp" ) 
      {
         OperationDescription desc = NewOperation("VarHandleOp", opName);

         desc.SetAttr("dtype", dtype);
         desc.SetAttrShape("shape", shape);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="resource">Input to the operation. </param>
      ///<param name="ignore_lookup_error"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation DestroyResourceOp (  Output resource , bool ignore_lookup_error = true ,String opName= "DestroyResourceOp" ) 
      {
         OperationDescription desc = NewOperation("DestroyResourceOp", opName);
         desc.AddInput(resource);

         if (ignore_lookup_error != true) desc.SetAttr("ignore_lookup_error", ignore_lookup_error);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Conj (  Output input ,String opName= "Conj" ) 
      {
         OperationDescription desc = NewOperation("Conj", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="resource">Input to the operation. </param>
      ///<param name="value">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation AssignVariableOp (  Output resource , Output value ,String opName= "AssignVariableOp" ) 
      {
         OperationDescription desc = NewOperation("AssignVariableOp", opName);
         desc.AddInput(resource);
         desc.AddInput(value);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="threshold">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtUint8).
      ///</return>
      public Operation CompareAndBitpack (  Output input , Output threshold ,String opName= "CompareAndBitpack" ) 
      {
         OperationDescription desc = NewOperation("CompareAndBitpack", opName);
         desc.AddInput(input);
         desc.AddInput(threshold);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation BesselI0e (  Output x ,String opName= "BesselI0e" ) 
      {
         OperationDescription desc = NewOperation("BesselI0e", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="resource">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="updates">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceScatterSub (  Output resource , Output indices , Output updates ,String opName= "ResourceScatterSub" ) 
      {
         OperationDescription desc = NewOperation("ResourceScatterSub", opName);
         desc.AddInput(resource);
         desc.AddInput(indices);
         desc.AddInput(updates);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="opName">The name of the operation</param>
      public Operation NoOp ( String opName= "NoOp" ) 
      {
         OperationDescription desc = NewOperation("NoOp", opName);



         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="resource">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="updates">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceScatterMul (  Output resource , Output indices , Output updates ,String opName= "ResourceScatterMul" ) 
      {
         OperationDescription desc = NewOperation("ResourceScatterMul", opName);
         desc.AddInput(resource);
         desc.AddInput(indices);
         desc.AddInput(updates);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="resource">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="updates">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceScatterMin (  Output resource , Output indices , Output updates ,String opName= "ResourceScatterMin" ) 
      {
         OperationDescription desc = NewOperation("ResourceScatterMin", opName);
         desc.AddInput(resource);
         desc.AddInput(indices);
         desc.AddInput(updates);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Reciprocal (  Output x ,String opName= "Reciprocal" ) 
      {
         OperationDescription desc = NewOperation("Reciprocal", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="resource">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="updates">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceScatterMax (  Output resource , Output indices , Output updates ,String opName= "ResourceScatterMax" ) 
      {
         OperationDescription desc = NewOperation("ResourceScatterMax", opName);
         desc.AddInput(resource);
         desc.AddInput(indices);
         desc.AddInput(updates);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="resource">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="updates">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceScatterUpdate (  Output resource , Output indices , Output updates ,String opName= "ResourceScatterUpdate" ) 
      {
         OperationDescription desc = NewOperation("ResourceScatterUpdate", opName);
         desc.AddInput(resource);
         desc.AddInput(indices);
         desc.AddInput(updates);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] resource(type: DtResource).
      ///</return>
      public Operation MutexV2 (  string container = null , string shared_name = null ,String opName= "MutexV2" ) 
      {
         OperationDescription desc = NewOperation("MutexV2", opName);


         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="shape">Input to the operation. </param>
      ///<param name="minval">Input to the operation. </param>
      ///<param name="maxval">Input to the operation. </param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation RandomUniformInt (  Output shape , Output minval , Output maxval , long seed = 0 , long seed2 = 0 ,String opName= "RandomUniformInt" ) 
      {
         OperationDescription desc = NewOperation("RandomUniformInt", opName);
         desc.AddInput(shape);
         desc.AddInput(minval);
         desc.AddInput(maxval);

         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="mutex_lock">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation ConsumeMutexLock (  Output mutex_lock ,String opName= "ConsumeMutexLock" ) 
      {
         OperationDescription desc = NewOperation("ConsumeMutexLock", opName);
         desc.AddInput(mutex_lock);


         return desc.FinishOperation();
      } 
      // Skipped function _ScopedAllocator
      // Skipped function _ScopedAllocatorConcat

      ///<summary>
      ///
      ///</summary>
      ///<param name="inputs">Input to the operation. </param>
      ///<param name="reduction_indices">Input to the operation. </param>
      ///<param name="keep_dims"></param>
      ///<param name="separator"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtString).
      ///</return>
      public Operation ReduceJoin (  Output inputs , Output reduction_indices , bool keep_dims = false , string separator = null ,String opName= "ReduceJoin" ) 
      {
         OperationDescription desc = NewOperation("ReduceJoin", opName);
         desc.AddInput(inputs);
         desc.AddInput(reduction_indices);

         if (keep_dims != false) desc.SetAttr("keep_dims", keep_dims);
         if (separator != null) desc.SetAttr("separator", separator);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInt64).
      ///</return>
      public Operation SdcaFprint (  Output input ,String opName= "SdcaFprint" ) 
      {
         OperationDescription desc = NewOperation("SdcaFprint", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="set1">Input to the operation. </param>
      ///<param name="set2_indices">Input to the operation. </param>
      ///<param name="set2_values">Input to the operation. </param>
      ///<param name="set2_shape">Input to the operation. </param>
      ///<param name="set_operation"></param>
      ///<param name="validate_indices"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] result_indices(type: DtInt64).
      ///[1] result_values(type: DtInvalid).
      ///[2] result_shape(type: DtInt64).
      ///</return>
      public Operation DenseToSparseSetOperation (  Output set1 , Output set2_indices , Output set2_values , Output set2_shape , string set_operation, bool validate_indices = true ,String opName= "DenseToSparseSetOperation" ) 
      {
         OperationDescription desc = NewOperation("DenseToSparseSetOperation", opName);
         desc.AddInput(set1);
         desc.AddInput(set2_indices);
         desc.AddInput(set2_values);
         desc.AddInput(set2_shape);
         desc.SetAttr("set_operation", set_operation);
         if (validate_indices != true) desc.SetAttr("validate_indices", validate_indices);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="set1_indices">Input to the operation. </param>
      ///<param name="set1_values">Input to the operation. </param>
      ///<param name="set1_shape">Input to the operation. </param>
      ///<param name="set2_indices">Input to the operation. </param>
      ///<param name="set2_values">Input to the operation. </param>
      ///<param name="set2_shape">Input to the operation. </param>
      ///<param name="set_operation"></param>
      ///<param name="validate_indices"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] result_indices(type: DtInt64).
      ///[1] result_values(type: DtInvalid).
      ///[2] result_shape(type: DtInt64).
      ///</return>
      public Operation SparseToSparseSetOperation (  Output set1_indices , Output set1_values , Output set1_shape , Output set2_indices , Output set2_values , Output set2_shape , string set_operation, bool validate_indices = true ,String opName= "SparseToSparseSetOperation" ) 
      {
         OperationDescription desc = NewOperation("SparseToSparseSetOperation", opName);
         desc.AddInput(set1_indices);
         desc.AddInput(set1_values);
         desc.AddInput(set1_shape);
         desc.AddInput(set2_indices);
         desc.AddInput(set2_values);
         desc.AddInput(set2_shape);
         desc.SetAttr("set_operation", set_operation);
         if (validate_indices != true) desc.SetAttr("validate_indices", validate_indices);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="linear">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="l1">Input to the operation. </param>
      ///<param name="l2">Input to the operation. </param>
      ///<param name="l2_shrinkage">Input to the operation. </param>
      ///<param name="lr_power">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceSparseApplyFtrlV2 (  Output var , Output accum , Output linear , Output grad , Output indices , Output lr , Output l1 , Output l2 , Output l2_shrinkage , Output lr_power , bool use_locking = false ,String opName= "ResourceSparseApplyFtrlV2" ) 
      {
         OperationDescription desc = NewOperation("ResourceSparseApplyFtrlV2", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(linear);
         desc.AddInput(grad);
         desc.AddInput(indices);
         desc.AddInput(lr);
         desc.AddInput(l1);
         desc.AddInput(l2);
         desc.AddInput(l2_shrinkage);
         desc.AddInput(lr_power);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="inputs">Input to the operation. </param>
      ///<param name="shape"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] sum(type: DtInvalid).
      ///</return>
      public Operation AccumulateNV2 (  Output inputs , long[] shape,String opName= "AccumulateNV2" ) 
      {
         OperationDescription desc = NewOperation("AccumulateNV2", opName);
         desc.AddInput(inputs);
         desc.SetAttrShape("shape", shape);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="DstT"></param>
      ///<param name="Truncate"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Cast (  Output x , DataType DstT, bool Truncate = false ,String opName= "Cast" ) 
      {
         OperationDescription desc = NewOperation("Cast", opName);
         desc.AddInput(x);
         desc.SetAttr("DstT", DstT);
         if (Truncate != false) desc.SetAttr("Truncate", Truncate);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Abs (  Output x ,String opName= "Abs" ) 
      {
         OperationDescription desc = NewOperation("Abs", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="Tout"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation ComplexAbs (  Output x , DataType? Tout = null ,String opName= "ComplexAbs" ) 
      {
         OperationDescription desc = NewOperation("ComplexAbs", opName);
         desc.AddInput(x);

         if (Tout.HasValue) desc.SetAttr("Tout", Tout.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Tan (  Output x ,String opName= "Tan" ) 
      {
         OperationDescription desc = NewOperation("Tan", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Inv (  Output x ,String opName= "Inv" ) 
      {
         OperationDescription desc = NewOperation("Inv", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Sqrt (  Output x ,String opName= "Sqrt" ) 
      {
         OperationDescription desc = NewOperation("Sqrt", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Log1p (  Output x ,String opName= "Log1p" ) 
      {
         OperationDescription desc = NewOperation("Log1p", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="string_tensor">Input to the operation. </param>
      ///<param name="num_buckets"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInt64).
      ///</return>
      public Operation StringToHashBucket (  Output string_tensor , long num_buckets,String opName= "StringToHashBucket" ) 
      {
         OperationDescription desc = NewOperation("StringToHashBucket", opName);
         desc.AddInput(string_tensor);
         desc.SetAttr("num_buckets", num_buckets);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Sinh (  Output x ,String opName= "Sinh" ) 
      {
         OperationDescription desc = NewOperation("Sinh", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Cosh (  Output x ,String opName= "Cosh" ) 
      {
         OperationDescription desc = NewOperation("Cosh", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Acosh (  Output x ,String opName= "Acosh" ) 
      {
         OperationDescription desc = NewOperation("Acosh", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="shape">Input to the operation. </param>
      ///<param name="seed">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation StatelessRandomUniform (  Output shape , Output seed , DataType? dtype = null ,String opName= "StatelessRandomUniform" ) 
      {
         OperationDescription desc = NewOperation("StatelessRandomUniform", opName);
         desc.AddInput(shape);
         desc.AddInput(seed);

         if (dtype.HasValue) desc.SetAttr("dtype", dtype.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="y">Input to the operation. </param>
      ///<param name="dy">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation TanhGrad (  Output y , Output dy ,String opName= "TanhGrad" ) 
      {
         OperationDescription desc = NewOperation("TanhGrad", opName);
         desc.AddInput(y);
         desc.AddInput(dy);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Digamma (  Output x ,String opName= "Digamma" ) 
      {
         OperationDescription desc = NewOperation("Digamma", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="shape">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation RandomStandardNormal (  Output shape , DataType dtype, long seed = 0 , long seed2 = 0 ,String opName= "RandomStandardNormal" ) 
      {
         OperationDescription desc = NewOperation("RandomStandardNormal", opName);
         desc.AddInput(shape);
         desc.SetAttr("dtype", dtype);
         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Cos (  Output x ,String opName= "Cos" ) 
      {
         OperationDescription desc = NewOperation("Cos", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="input_min">Input to the operation. </param>
      ///<param name="input_max">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_min(type: DtFloat).
      ///[1] output_max(type: DtFloat).
      ///</return>
      public Operation RequantizationRange (  Output input , Output input_min , Output input_max ,String opName= "RequantizationRange" ) 
      {
         OperationDescription desc = NewOperation("RequantizationRange", opName);
         desc.AddInput(input);
         desc.AddInput(input_min);
         desc.AddInput(input_max);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Asin (  Output x ,String opName= "Asin" ) 
      {
         OperationDescription desc = NewOperation("Asin", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Acos (  Output x ,String opName= "Acos" ) 
      {
         OperationDescription desc = NewOperation("Acos", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Atan (  Output x ,String opName= "Atan" ) 
      {
         OperationDescription desc = NewOperation("Atan", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtBool).
      ///</return>
      public Operation IsFinite (  Output x ,String opName= "IsFinite" ) 
      {
         OperationDescription desc = NewOperation("IsFinite", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 
      // Skipped function _ListToArray

      ///<summary>
      ///
      ///</summary>
      ///<param name="a">Input to the operation. </param>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation Polygamma (  Output a , Output x ,String opName= "Polygamma" ) 
      {
         OperationDescription desc = NewOperation("Polygamma", opName);
         desc.AddInput(a);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation AddV2 (  Output x , Output y ,String opName= "AddV2" ) 
      {
         OperationDescription desc = NewOperation("AddV2", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 
      // Skipped function _MklAdd

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation Sub (  Output x , Output y ,String opName= "Sub" ) 
      {
         OperationDescription desc = NewOperation("Sub", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 
      // Skipped function _MklSub

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation Mul (  Output x , Output y ,String opName= "Mul" ) 
      {
         OperationDescription desc = NewOperation("Mul", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 
      // Skipped function _MklMul

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation FloorDiv (  Output x , Output y ,String opName= "FloorDiv" ) 
      {
         OperationDescription desc = NewOperation("FloorDiv", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 
      // Skipped function _MklSquaredDifference

      ///<summary>
      ///
      ///</summary>
      ///<param name="reference">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="updates">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_ref(type: DtInvalid).
      ///</return>
      public Operation ScatterSub (  Output reference , Output indices , Output updates , bool use_locking = false ,String opName= "ScatterSub" ) 
      {
         OperationDescription desc = NewOperation("ScatterSub", opName);
         desc.AddInput(reference);
         desc.AddInput(indices);
         desc.AddInput(updates);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation Maximum (  Output x , Output y ,String opName= "Maximum" ) 
      {
         OperationDescription desc = NewOperation("Maximum", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 
      // Skipped function _MklMaximum

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation Minimum (  Output x , Output y ,String opName= "Minimum" ) 
      {
         OperationDescription desc = NewOperation("Minimum", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="target">Input to the operation. </param>
      ///<param name="args">Input to the operation. </param>
      ///<param name="Tout"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      //The following attributes are not known: f: func
      public Operation RemoteCall (  Output target , Output args , DataType[] Tout,String opName= "RemoteCall" ) 
      {
         OperationDescription desc = NewOperation("RemoteCall", opName);
         desc.AddInput(target);
         desc.AddInput(args);
         desc.SetAttr("Tout", Tout);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation Mod (  Output x , Output y ,String opName= "Mod" ) 
      {
         OperationDescription desc = NewOperation("Mod", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation Pow (  Output x , Output y ,String opName= "Pow" ) 
      {
         OperationDescription desc = NewOperation("Pow", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="a">Input to the operation. </param>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation Igamma (  Output a , Output x ,String opName= "Igamma" ) 
      {
         OperationDescription desc = NewOperation("Igamma", opName);
         desc.AddInput(a);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="a">Input to the operation. </param>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation IgammaGradA (  Output a , Output x ,String opName= "IgammaGradA" ) 
      {
         OperationDescription desc = NewOperation("IgammaGradA", opName);
         desc.AddInput(a);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="alpha">Input to the operation. </param>
      ///<param name="delta">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation ApplyGradientDescent (  Output var , Output alpha , Output delta , bool use_locking = false ,String opName= "ApplyGradientDescent" ) 
      {
         OperationDescription desc = NewOperation("ApplyGradientDescent", opName);
         desc.AddInput(var);
         desc.AddInput(alpha);
         desc.AddInput(delta);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="q">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation Zeta (  Output x , Output q ,String opName= "Zeta" ) 
      {
         OperationDescription desc = NewOperation("Zeta", opName);
         desc.AddInput(x);
         desc.AddInput(q);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="y">Input to the operation. </param>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation Atan2 (  Output y , Output x ,String opName= "Atan2" ) 
      {
         OperationDescription desc = NewOperation("Atan2", opName);
         desc.AddInput(y);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reference">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="updates">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_ref(type: DtInvalid).
      ///</return>
      public Operation ScatterAdd (  Output reference , Output indices , Output updates , bool use_locking = false ,String opName= "ScatterAdd" ) 
      {
         OperationDescription desc = NewOperation("ScatterAdd", opName);
         desc.AddInput(reference);
         desc.AddInput(indices);
         desc.AddInput(updates);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtBool).
      ///</return>
      public Operation Less (  Output x , Output y ,String opName= "Less" ) 
      {
         OperationDescription desc = NewOperation("Less", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtBool).
      ///</return>
      public Operation LessEqual (  Output x , Output y ,String opName= "LessEqual" ) 
      {
         OperationDescription desc = NewOperation("LessEqual", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtBool).
      ///</return>
      public Operation Greater (  Output x , Output y ,String opName= "Greater" ) 
      {
         OperationDescription desc = NewOperation("Greater", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="alpha">Input to the operation. </param>
      ///<param name="delta">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceApplyGradientDescent (  Output var , Output alpha , Output delta , bool use_locking = false ,String opName= "ResourceApplyGradientDescent" ) 
      {
         OperationDescription desc = NewOperation("ResourceApplyGradientDescent", opName);
         desc.AddInput(var);
         desc.AddInput(alpha);
         desc.AddInput(delta);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtBool).
      ///</return>
      public Operation Equal (  Output x , Output y ,String opName= "Equal" ) 
      {
         OperationDescription desc = NewOperation("Equal", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="shape"></param>
      ///<param name="dtype"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] ref(type: DtInvalid).
      ///</return>
      public Operation Variable (  long[] shape, DataType dtype, string container = null , string shared_name = null ,String opName= "Variable" ) 
      {
         OperationDescription desc = NewOperation("Variable", opName);

         desc.SetAttrShape("shape", shape);
         desc.SetAttr("dtype", dtype);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtBool).
      ///</return>
      public Operation LogicalNot (  Output x ,String opName= "LogicalNot" ) 
      {
         OperationDescription desc = NewOperation("LogicalNot", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtBool).
      ///</return>
      public Operation LogicalAnd (  Output x , Output y ,String opName= "LogicalAnd" ) 
      {
         OperationDescription desc = NewOperation("LogicalAnd", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtBool).
      ///</return>
      public Operation LogicalOr (  Output x , Output y ,String opName= "LogicalOr" ) 
      {
         OperationDescription desc = NewOperation("LogicalOr", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="num_buckets"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInt64).
      ///</return>
      public Operation StringToHashBucketFast (  Output input , long num_buckets,String opName= "StringToHashBucketFast" ) 
      {
         OperationDescription desc = NewOperation("StringToHashBucketFast", opName);
         desc.AddInput(input);
         desc.SetAttr("num_buckets", num_buckets);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="a">Input to the operation. </param>
      ///<param name="b">Input to the operation. </param>
      ///<param name="transpose_a"></param>
      ///<param name="transpose_b"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] product(type: DtInvalid).
      ///</return>
      public Operation MatMul (  Output a , Output b , bool transpose_a = false , bool transpose_b = false ,String opName= "MatMul" ) 
      {
         OperationDescription desc = NewOperation("MatMul", opName);
         desc.AddInput(a);
         desc.AddInput(b);

         if (transpose_a != false) desc.SetAttr("transpose_a", transpose_a);
         if (transpose_b != false) desc.SetAttr("transpose_b", transpose_b);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="reduction_indices">Input to the operation. </param>
      ///<param name="keep_dims"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Sum (  Output input , Output reduction_indices , bool keep_dims = false ,String opName= "Sum" ) 
      {
         OperationDescription desc = NewOperation("Sum", opName);
         desc.AddInput(input);
         desc.AddInput(reduction_indices);

         if (keep_dims != false) desc.SetAttr("keep_dims", keep_dims);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reverse_index_map">Input to the operation. </param>
      ///<param name="grad_values">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] d_values(type: DtInvalid).
      ///[1] d_default_value(type: DtInvalid).
      ///</return>
      public Operation SparseFillEmptyRowsGrad (  Output reverse_index_map , Output grad_values ,String opName= "SparseFillEmptyRowsGrad" ) 
      {
         OperationDescription desc = NewOperation("SparseFillEmptyRowsGrad", opName);
         desc.AddInput(reverse_index_map);
         desc.AddInput(grad_values);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="reduction_indices">Input to the operation. </param>
      ///<param name="keep_dims"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Prod (  Output input , Output reduction_indices , bool keep_dims = false ,String opName= "Prod" ) 
      {
         OperationDescription desc = NewOperation("Prod", opName);
         desc.AddInput(input);
         desc.AddInput(reduction_indices);

         if (keep_dims != false) desc.SetAttr("keep_dims", keep_dims);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="reduction_indices">Input to the operation. </param>
      ///<param name="keep_dims"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Max (  Output input , Output reduction_indices , bool keep_dims = false ,String opName= "Max" ) 
      {
         OperationDescription desc = NewOperation("Max", opName);
         desc.AddInput(input);
         desc.AddInput(reduction_indices);

         if (keep_dims != false) desc.SetAttr("keep_dims", keep_dims);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="dimension">Input to the operation. </param>
      ///<param name="output_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation ArgMax (  Output input , Output dimension , DataType? output_type = null ,String opName= "ArgMax" ) 
      {
         OperationDescription desc = NewOperation("ArgMax", opName);
         desc.AddInput(input);
         desc.AddInput(dimension);

         if (output_type.HasValue) desc.SetAttr("output_type", output_type.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="dimension">Input to the operation. </param>
      ///<param name="output_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation ArgMin (  Output input , Output dimension , DataType? output_type = null ,String opName= "ArgMin" ) 
      {
         OperationDescription desc = NewOperation("ArgMin", opName);
         desc.AddInput(input);
         desc.AddInput(dimension);

         if (output_type.HasValue) desc.SetAttr("output_type", output_type.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="writer">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation CloseSummaryWriter (  Output writer ,String opName= "CloseSummaryWriter" ) 
      {
         OperationDescription desc = NewOperation("CloseSummaryWriter", opName);
         desc.AddInput(writer);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="segment_ids">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SegmentMin (  Output data , Output segment_ids ,String opName= "SegmentMin" ) 
      {
         OperationDescription desc = NewOperation("SegmentMin", opName);
         desc.AddInput(data);
         desc.AddInput(segment_ids);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="segment_ids">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SegmentMax (  Output data , Output segment_ids ,String opName= "SegmentMax" ) 
      {
         OperationDescription desc = NewOperation("SegmentMax", opName);
         desc.AddInput(data);
         desc.AddInput(segment_ids);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="segment_ids">Input to the operation. </param>
      ///<param name="num_segments">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation UnsortedSegmentSum (  Output data , Output segment_ids , Output num_segments ,String opName= "UnsortedSegmentSum" ) 
      {
         OperationDescription desc = NewOperation("UnsortedSegmentSum", opName);
         desc.AddInput(data);
         desc.AddInput(segment_ids);
         desc.AddInput(num_segments);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="segment_ids">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SparseSegmentSum (  Output data , Output indices , Output segment_ids ,String opName= "SparseSegmentSum" ) 
      {
         OperationDescription desc = NewOperation("SparseSegmentSum", opName);
         desc.AddInput(data);
         desc.AddInput(indices);
         desc.AddInput(segment_ids);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="m">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="alpha">Input to the operation. </param>
      ///<param name="sign_decay">Input to the operation. </param>
      ///<param name="beta">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceApplyAddSign (  Output var , Output m , Output lr , Output alpha , Output sign_decay , Output beta , Output grad , bool use_locking = false ,String opName= "ResourceApplyAddSign" ) 
      {
         OperationDescription desc = NewOperation("ResourceApplyAddSign", opName);
         desc.AddInput(var);
         desc.AddInput(m);
         desc.AddInput(lr);
         desc.AddInput(alpha);
         desc.AddInput(sign_decay);
         desc.AddInput(beta);
         desc.AddInput(grad);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="segment_ids">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SparseSegmentMean (  Output data , Output indices , Output segment_ids ,String opName= "SparseSegmentMean" ) 
      {
         OperationDescription desc = NewOperation("SparseSegmentMean", opName);
         desc.AddInput(data);
         desc.AddInput(indices);
         desc.AddInput(segment_ids);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="l1">Input to the operation. </param>
      ///<param name="l2">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation SparseApplyProximalAdagrad (  Output var , Output accum , Output lr , Output l1 , Output l2 , Output grad , Output indices , bool use_locking = false ,String opName= "SparseApplyProximalAdagrad" ) 
      {
         OperationDescription desc = NewOperation("SparseApplyProximalAdagrad", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(lr);
         desc.AddInput(l1);
         desc.AddInput(l2);
         desc.AddInput(grad);
         desc.AddInput(indices);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="segment_ids">Input to the operation. </param>
      ///<param name="output_dim0">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SparseSegmentMeanGrad (  Output grad , Output indices , Output segment_ids , Output output_dim0 ,String opName= "SparseSegmentMeanGrad" ) 
      {
         OperationDescription desc = NewOperation("SparseSegmentMeanGrad", opName);
         desc.AddInput(grad);
         desc.AddInput(indices);
         desc.AddInput(segment_ids);
         desc.AddInput(output_dim0);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="segment_ids">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SparseSegmentSqrtN (  Output data , Output indices , Output segment_ids ,String opName= "SparseSegmentSqrtN" ) 
      {
         OperationDescription desc = NewOperation("SparseSegmentSqrtN", opName);
         desc.AddInput(data);
         desc.AddInput(indices);
         desc.AddInput(segment_ids);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="data">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="segment_ids">Input to the operation. </param>
      ///<param name="num_segments">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SparseSegmentSqrtNWithNumSegments (  Output data , Output indices , Output segment_ids , Output num_segments ,String opName= "SparseSegmentSqrtNWithNumSegments" ) 
      {
         OperationDescription desc = NewOperation("SparseSegmentSqrtNWithNumSegments", opName);
         desc.AddInput(data);
         desc.AddInput(indices);
         desc.AddInput(segment_ids);
         desc.AddInput(num_segments);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="ms">Input to the operation. </param>
      ///<param name="mom">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="rho">Input to the operation. </param>
      ///<param name="momentum">Input to the operation. </param>
      ///<param name="epsilon">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceSparseApplyRMSProp (  Output var , Output ms , Output mom , Output lr , Output rho , Output momentum , Output epsilon , Output grad , Output indices , bool use_locking = false ,String opName= "ResourceSparseApplyRMSProp" ) 
      {
         OperationDescription desc = NewOperation("ResourceSparseApplyRMSProp", opName);
         desc.AddInput(var);
         desc.AddInput(ms);
         desc.AddInput(mom);
         desc.AddInput(lr);
         desc.AddInput(rho);
         desc.AddInput(momentum);
         desc.AddInput(epsilon);
         desc.AddInput(grad);
         desc.AddInput(indices);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="segment_ids">Input to the operation. </param>
      ///<param name="output_dim0">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SparseSegmentSqrtNGrad (  Output grad , Output indices , Output segment_ids , Output output_dim0 ,String opName= "SparseSegmentSqrtNGrad" ) 
      {
         OperationDescription desc = NewOperation("SparseSegmentSqrtNGrad", opName);
         desc.AddInput(grad);
         desc.AddInput(indices);
         desc.AddInput(segment_ids);
         desc.AddInput(output_dim0);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="reduction_indices">Input to the operation. </param>
      ///<param name="keep_dims"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtBool).
      ///</return>
      public Operation Any (  Output input , Output reduction_indices , bool keep_dims = false ,String opName= "Any" ) 
      {
         OperationDescription desc = NewOperation("Any", opName);
         desc.AddInput(input);
         desc.AddInput(reduction_indices);

         if (keep_dims != false) desc.SetAttr("keep_dims", keep_dims);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="start">Input to the operation. </param>
      ///<param name="limit">Input to the operation. </param>
      ///<param name="delta">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Range (  Output start , Output limit , Output delta ,String opName= "Range" ) 
      {
         OperationDescription desc = NewOperation("Range", opName);
         desc.AddInput(start);
         desc.AddInput(limit);
         desc.AddInput(delta);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reference">Input to the operation. </param>
      ///<param name="value">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_ref(type: DtInvalid).
      ///</return>
      public Operation AssignAdd (  Output reference , Output value , bool use_locking = false ,String opName= "AssignAdd" ) 
      {
         OperationDescription desc = NewOperation("AssignAdd", opName);
         desc.AddInput(reference);
         desc.AddInput(value);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="real">Input to the operation. </param>
      ///<param name="imag">Input to the operation. </param>
      ///<param name="Tout"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation Complex (  Output real , Output imag , DataType? Tout = null ,String opName= "Complex" ) 
      {
         OperationDescription desc = NewOperation("Complex", opName);
         desc.AddInput(real);
         desc.AddInput(imag);

         if (Tout.HasValue) desc.SetAttr("Tout", Tout.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="resource">Input to the operation. </param>
      ///<param name="limit"></param>
      ///<param name="T"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation ResourceCountUpTo (  Output resource , long limit, DataType T,String opName= "ResourceCountUpTo" ) 
      {
         OperationDescription desc = NewOperation("ResourceCountUpTo", opName);
         desc.AddInput(resource);
         desc.SetAttr("limit", limit);
         desc.SetAttr("T", T);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="Tout"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation Angle (  Output input , DataType? Tout = null ,String opName= "Angle" ) 
      {
         OperationDescription desc = NewOperation("Angle", opName);
         desc.AddInput(input);

         if (Tout.HasValue) desc.SetAttr("Tout", Tout.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="a">Input to the operation. </param>
      ///<param name="b">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] product(type: DtInvalid).
      ///</return>
      public Operation Cross (  Output a , Output b ,String opName= "Cross" ) 
      {
         OperationDescription desc = NewOperation("Cross", opName);
         desc.AddInput(a);
         desc.AddInput(b);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="values">Input to the operation. </param>
      ///<param name="value_range">Input to the operation. </param>
      ///<param name="nbins">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation HistogramFixedWidth (  Output values , Output value_range , Output nbins , DataType? dtype = null ,String opName= "HistogramFixedWidth" ) 
      {
         OperationDescription desc = NewOperation("HistogramFixedWidth", opName);
         desc.AddInput(values);
         desc.AddInput(value_range);
         desc.AddInput(nbins);

         if (dtype.HasValue) desc.SetAttr("dtype", dtype.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="arr">Input to the operation. </param>
      ///<param name="size">Input to the operation. </param>
      ///<param name="weights">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] bins(type: DtInvalid).
      ///</return>
      public Operation Bincount (  Output arr , Output size , Output weights ,String opName= "Bincount" ) 
      {
         OperationDescription desc = NewOperation("Bincount", opName);
         desc.AddInput(arr);
         desc.AddInput(size);
         desc.AddInput(weights);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="axis">Input to the operation. </param>
      ///<param name="exclusive"></param>
      ///<param name="reverse"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation Cumprod (  Output x , Output axis , bool exclusive = false , bool reverse = false ,String opName= "Cumprod" ) 
      {
         OperationDescription desc = NewOperation("Cumprod", opName);
         desc.AddInput(x);
         desc.AddInput(axis);

         if (exclusive != false) desc.SetAttr("exclusive", exclusive);
         if (reverse != false) desc.SetAttr("reverse", reverse);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="a">Input to the operation. </param>
      ///<param name="b">Input to the operation. </param>
      ///<param name="min_a">Input to the operation. </param>
      ///<param name="max_a">Input to the operation. </param>
      ///<param name="min_b">Input to the operation. </param>
      ///<param name="max_b">Input to the operation. </param>
      ///<param name="Toutput"></param>
      ///<param name="transpose_a"></param>
      ///<param name="transpose_b"></param>
      ///<param name="Tactivation"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///[1] min_out(type: DtFloat).
      ///[2] max_out(type: DtFloat).
      ///</return>
      public Operation QuantizedMatMul (  Output a , Output b , Output min_a , Output max_a , Output min_b , Output max_b , DataType? Toutput = null , bool transpose_a = false , bool transpose_b = false , DataType? Tactivation = null ,String opName= "QuantizedMatMul" ) 
      {
         OperationDescription desc = NewOperation("QuantizedMatMul", opName);
         desc.AddInput(a);
         desc.AddInput(b);
         desc.AddInput(min_a);
         desc.AddInput(max_a);
         desc.AddInput(min_b);
         desc.AddInput(max_b);

         if (Toutput.HasValue) desc.SetAttr("Toutput", Toutput.Value);
         if (transpose_a != false) desc.SetAttr("transpose_a", transpose_a);
         if (transpose_b != false) desc.SetAttr("transpose_b", transpose_b);
         if (Tactivation.HasValue) desc.SetAttr("Tactivation", Tactivation.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="min_x">Input to the operation. </param>
      ///<param name="max_x">Input to the operation. </param>
      ///<param name="min_y">Input to the operation. </param>
      ///<param name="max_y">Input to the operation. </param>
      ///<param name="Toutput"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///[1] min_z(type: DtFloat).
      ///[2] max_z(type: DtFloat).
      ///</return>
      public Operation QuantizedAdd (  Output x , Output y , Output min_x , Output max_x , Output min_y , Output max_y , DataType? Toutput = null ,String opName= "QuantizedAdd" ) 
      {
         OperationDescription desc = NewOperation("QuantizedAdd", opName);
         desc.AddInput(x);
         desc.AddInput(y);
         desc.AddInput(min_x);
         desc.AddInput(max_x);
         desc.AddInput(min_y);
         desc.AddInput(max_y);

         if (Toutput.HasValue) desc.SetAttr("Toutput", Toutput.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="input_min">Input to the operation. </param>
      ///<param name="input_max">Input to the operation. </param>
      ///<param name="out_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///[1] output_min(type: DtFloat).
      ///[2] output_max(type: DtFloat).
      ///</return>
      public Operation QuantizeDownAndShrinkRange (  Output input , Output input_min , Output input_max , DataType out_type,String opName= "QuantizeDownAndShrinkRange" ) 
      {
         OperationDescription desc = NewOperation("QuantizeDownAndShrinkRange", opName);
         desc.AddInput(input);
         desc.AddInput(input_min);
         desc.AddInput(input_max);
         desc.SetAttr("out_type", out_type);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="update_slots"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation SparseApplyAdagrad (  Output var , Output accum , Output lr , Output grad , Output indices , bool use_locking = false , bool update_slots = true ,String opName= "SparseApplyAdagrad" ) 
      {
         OperationDescription desc = NewOperation("SparseApplyAdagrad", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(lr);
         desc.AddInput(grad);
         desc.AddInput(indices);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         if (update_slots != true) desc.SetAttr("update_slots", update_slots);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] y(type: DtInvalid).
      ///</return>
      public Operation Invert (  Output x ,String opName= "Invert" ) 
      {
         OperationDescription desc = NewOperation("Invert", opName);
         desc.AddInput(x);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation BitwiseAnd (  Output x , Output y ,String opName= "BitwiseAnd" ) 
      {
         OperationDescription desc = NewOperation("BitwiseAnd", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation BitwiseXor (  Output x , Output y ,String opName= "BitwiseXor" ) 
      {
         OperationDescription desc = NewOperation("BitwiseXor", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation LeftShift (  Output x , Output y ,String opName= "LeftShift" ) 
      {
         OperationDescription desc = NewOperation("LeftShift", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="linear">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="l1">Input to the operation. </param>
      ///<param name="l2">Input to the operation. </param>
      ///<param name="lr_power">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceSparseApplyFtrl (  Output var , Output accum , Output linear , Output grad , Output indices , Output lr , Output l1 , Output l2 , Output lr_power , bool use_locking = false ,String opName= "ResourceSparseApplyFtrl" ) 
      {
         OperationDescription desc = NewOperation("ResourceSparseApplyFtrl", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(linear);
         desc.AddInput(grad);
         desc.AddInput(indices);
         desc.AddInput(lr);
         desc.AddInput(l1);
         desc.AddInput(l2);
         desc.AddInput(lr_power);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="x">Input to the operation. </param>
      ///<param name="y">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] z(type: DtInvalid).
      ///</return>
      public Operation RightShift (  Output x , Output y ,String opName= "RightShift" ) 
      {
         OperationDescription desc = NewOperation("RightShift", opName);
         desc.AddInput(x);
         desc.AddInput(y);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="backprop_val_grad">Input to the operation. </param>
      ///<param name="a_indices">Input to the operation. </param>
      ///<param name="b_indices">Input to the operation. </param>
      ///<param name="sum_indices">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] a_val_grad(type: DtInvalid).
      ///[1] b_val_grad(type: DtInvalid).
      ///</return>
      public Operation SparseAddGrad (  Output backprop_val_grad , Output a_indices , Output b_indices , Output sum_indices ,String opName= "SparseAddGrad" ) 
      {
         OperationDescription desc = NewOperation("SparseAddGrad", opName);
         desc.AddInput(backprop_val_grad);
         desc.AddInput(a_indices);
         desc.AddInput(b_indices);
         desc.AddInput(sum_indices);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="a_indices">Input to the operation. </param>
      ///<param name="a_values">Input to the operation. </param>
      ///<param name="a_shape">Input to the operation. </param>
      ///<param name="b_indices">Input to the operation. </param>
      ///<param name="b_values">Input to the operation. </param>
      ///<param name="b_shape">Input to the operation. </param>
      ///<param name="thresh">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] sum_indices(type: DtInt64).
      ///[1] sum_values(type: DtInvalid).
      ///[2] sum_shape(type: DtInt64).
      ///</return>
      public Operation SparseAdd (  Output a_indices , Output a_values , Output a_shape , Output b_indices , Output b_values , Output b_shape , Output thresh ,String opName= "SparseAdd" ) 
      {
         OperationDescription desc = NewOperation("SparseAdd", opName);
         desc.AddInput(a_indices);
         desc.AddInput(a_values);
         desc.AddInput(a_shape);
         desc.AddInput(b_indices);
         desc.AddInput(b_values);
         desc.AddInput(b_shape);
         desc.AddInput(thresh);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="a_indices">Input to the operation. </param>
      ///<param name="a_values">Input to the operation. </param>
      ///<param name="a_shape">Input to the operation. </param>
      ///<param name="b">Input to the operation. </param>
      ///<param name="adjoint_a"></param>
      ///<param name="adjoint_b"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] product(type: DtInvalid).
      ///</return>
      public Operation SparseTensorDenseMatMul (  Output a_indices , Output a_values , Output a_shape , Output b , bool adjoint_a = false , bool adjoint_b = false ,String opName= "SparseTensorDenseMatMul" ) 
      {
         OperationDescription desc = NewOperation("SparseTensorDenseMatMul", opName);
         desc.AddInput(a_indices);
         desc.AddInput(a_values);
         desc.AddInput(a_shape);
         desc.AddInput(b);

         if (adjoint_a != false) desc.SetAttr("adjoint_a", adjoint_a);
         if (adjoint_b != false) desc.SetAttr("adjoint_b", adjoint_b);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="sparse_indices">Input to the operation. </param>
      ///<param name="sparse_values">Input to the operation. </param>
      ///<param name="sparse_shape">Input to the operation. </param>
      ///<param name="out_type"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] serialized_sparse(type: DtInvalid).
      ///</return>
      public Operation SerializeManySparse (  Output sparse_indices , Output sparse_values , Output sparse_shape , DataType? out_type = null ,String opName= "SerializeManySparse" ) 
      {
         OperationDescription desc = NewOperation("SerializeManySparse", opName);
         desc.AddInput(sparse_indices);
         desc.AddInput(sparse_values);
         desc.AddInput(sparse_shape);

         if (out_type.HasValue) desc.SetAttr("out_type", out_type.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="serialized_sparse">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] sparse_indices(type: DtInt64).
      ///[1] sparse_values(type: DtInvalid).
      ///[2] sparse_shape(type: DtInt64).
      ///</return>
      public Operation DeserializeManySparse (  Output serialized_sparse , DataType dtype,String opName= "DeserializeManySparse" ) 
      {
         OperationDescription desc = NewOperation("DeserializeManySparse", opName);
         desc.AddInput(serialized_sparse);
         desc.SetAttr("dtype", dtype);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="values">Input to the operation. </param>
      ///<param name="shapes">Input to the operation. </param>
      ///<param name="concat_dim"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_indices(type: DtInt64).
      ///[1] output_values(type: DtInvalid).
      ///[2] output_shape(type: DtInt64).
      ///</return>
      public Operation SparseConcat (  Output indices , Output values , Output shapes , long concat_dim,String opName= "SparseConcat" ) 
      {
         OperationDescription desc = NewOperation("SparseConcat", opName);
         desc.AddInput(indices);
         desc.AddInput(values);
         desc.AddInput(shapes);
         desc.SetAttr("concat_dim", concat_dim);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="values">Input to the operation. </param>
      ///<param name="shape">Input to the operation. </param>
      ///<param name="start">Input to the operation. </param>
      ///<param name="size">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_indices(type: DtInt64).
      ///[1] output_values(type: DtInvalid).
      ///[2] output_shape(type: DtInt64).
      ///</return>
      public Operation SparseSlice (  Output indices , Output values , Output shape , Output start , Output size ,String opName= "SparseSlice" ) 
      {
         OperationDescription desc = NewOperation("SparseSlice", opName);
         desc.AddInput(indices);
         desc.AddInput(values);
         desc.AddInput(shape);
         desc.AddInput(start);
         desc.AddInput(size);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_indices">Input to the operation. </param>
      ///<param name="input_values">Input to the operation. </param>
      ///<param name="input_shape">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_indices(type: DtInt64).
      ///[1] output_values(type: DtInvalid).
      ///</return>
      public Operation SparseReorder (  Output input_indices , Output input_values , Output input_shape ,String opName= "SparseReorder" ) 
      {
         OperationDescription desc = NewOperation("SparseReorder", opName);
         desc.AddInput(input_indices);
         desc.AddInput(input_values);
         desc.AddInput(input_shape);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="a_indices">Input to the operation. </param>
      ///<param name="a_values">Input to the operation. </param>
      ///<param name="a_shape">Input to the operation. </param>
      ///<param name="b">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SparseTensorDenseAdd (  Output a_indices , Output a_values , Output a_shape , Output b ,String opName= "SparseTensorDenseAdd" ) 
      {
         OperationDescription desc = NewOperation("SparseTensorDenseAdd", opName);
         desc.AddInput(a_indices);
         desc.AddInput(a_values);
         desc.AddInput(a_shape);
         desc.AddInput(b);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_indices">Input to the operation. </param>
      ///<param name="input_values">Input to the operation. </param>
      ///<param name="input_shape">Input to the operation. </param>
      ///<param name="reduction_axes">Input to the operation. </param>
      ///<param name="keep_dims"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_indices(type: DtInt64).
      ///[1] output_values(type: DtInvalid).
      ///[2] output_shape(type: DtInt64).
      ///</return>
      public Operation SparseReduceMaxSparse (  Output input_indices , Output input_values , Output input_shape , Output reduction_axes , bool keep_dims = false ,String opName= "SparseReduceMaxSparse" ) 
      {
         OperationDescription desc = NewOperation("SparseReduceMaxSparse", opName);
         desc.AddInput(input_indices);
         desc.AddInput(input_values);
         desc.AddInput(input_shape);
         desc.AddInput(reduction_axes);

         if (keep_dims != false) desc.SetAttr("keep_dims", keep_dims);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input_indices">Input to the operation. </param>
      ///<param name="input_values">Input to the operation. </param>
      ///<param name="input_shape">Input to the operation. </param>
      ///<param name="reduction_axes">Input to the operation. </param>
      ///<param name="keep_dims"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SparseReduceSum (  Output input_indices , Output input_values , Output input_shape , Output reduction_axes , bool keep_dims = false ,String opName= "SparseReduceSum" ) 
      {
         OperationDescription desc = NewOperation("SparseReduceSum", opName);
         desc.AddInput(input_indices);
         desc.AddInput(input_values);
         desc.AddInput(input_shape);
         desc.AddInput(reduction_axes);

         if (keep_dims != false) desc.SetAttr("keep_dims", keep_dims);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="sp_indices">Input to the operation. </param>
      ///<param name="sp_values">Input to the operation. </param>
      ///<param name="sp_shape">Input to the operation. </param>
      ///<param name="dense">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation SparseDenseCwiseDiv (  Output sp_indices , Output sp_values , Output sp_shape , Output dense ,String opName= "SparseDenseCwiseDiv" ) 
      {
         OperationDescription desc = NewOperation("SparseDenseCwiseDiv", opName);
         desc.AddInput(sp_indices);
         desc.AddInput(sp_values);
         desc.AddInput(sp_shape);
         desc.AddInput(dense);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="a_indices">Input to the operation. </param>
      ///<param name="a_values">Input to the operation. </param>
      ///<param name="a_shape">Input to the operation. </param>
      ///<param name="b_indices">Input to the operation. </param>
      ///<param name="b_values">Input to the operation. </param>
      ///<param name="b_shape">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_indices(type: DtInt64).
      ///[1] output_values(type: DtInvalid).
      ///</return>
      public Operation SparseSparseMinimum (  Output a_indices , Output a_values , Output a_shape , Output b_indices , Output b_values , Output b_shape ,String opName= "SparseSparseMinimum" ) 
      {
         OperationDescription desc = NewOperation("SparseSparseMinimum", opName);
         desc.AddInput(a_indices);
         desc.AddInput(a_values);
         desc.AddInput(a_shape);
         desc.AddInput(b_indices);
         desc.AddInput(b_values);
         desc.AddInput(b_shape);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="sparse_indices">Input to the operation. </param>
      ///<param name="sparse_values">Input to the operation. </param>
      ///<param name="sparse_shape">Input to the operation. </param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] sparse_handle(type: DtInt64).
      ///</return>
      public Operation AddSparseToTensorsMap (  Output sparse_indices , Output sparse_values , Output sparse_shape , string container = null , string shared_name = null ,String opName= "AddSparseToTensorsMap" ) 
      {
         OperationDescription desc = NewOperation("AddSparseToTensorsMap", opName);
         desc.AddInput(sparse_indices);
         desc.AddInput(sparse_values);
         desc.AddInput(sparse_shape);

         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="sparse_indices">Input to the operation. </param>
      ///<param name="sparse_values">Input to the operation. </param>
      ///<param name="sparse_shape">Input to the operation. </param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] sparse_handles(type: DtInt64).
      ///</return>
      public Operation AddManySparseToTensorsMap (  Output sparse_indices , Output sparse_values , Output sparse_shape , string container = null , string shared_name = null ,String opName= "AddManySparseToTensorsMap" ) 
      {
         OperationDescription desc = NewOperation("AddManySparseToTensorsMap", opName);
         desc.AddInput(sparse_indices);
         desc.AddInput(sparse_values);
         desc.AddInput(sparse_shape);

         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="values">Input to the operation. </param>
      ///<param name="dense_shape">Input to the operation. </param>
      ///<param name="default_value">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_indices(type: DtInt64).
      ///[1] output_values(type: DtInvalid).
      ///[2] empty_row_indicator(type: DtBool).
      ///[3] reverse_index_map(type: DtInt64).
      ///</return>
      public Operation SparseFillEmptyRows (  Output indices , Output values , Output dense_shape , Output default_value ,String opName= "SparseFillEmptyRows" ) 
      {
         OperationDescription desc = NewOperation("SparseFillEmptyRows", opName);
         desc.AddInput(indices);
         desc.AddInput(values);
         desc.AddInput(dense_shape);
         desc.AddInput(default_value);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="shape">Input to the operation. </param>
      ///<param name="means">Input to the operation. </param>
      ///<param name="stdevs">Input to the operation. </param>
      ///<param name="minvals">Input to the operation. </param>
      ///<param name="maxvals">Input to the operation. </param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation ParameterizedTruncatedNormal (  Output shape , Output means , Output stdevs , Output minvals , Output maxvals , long seed = 0 , long seed2 = 0 ,String opName= "ParameterizedTruncatedNormal" ) 
      {
         OperationDescription desc = NewOperation("ParameterizedTruncatedNormal", opName);
         desc.AddInput(shape);
         desc.AddInput(means);
         desc.AddInput(stdevs);
         desc.AddInput(minvals);
         desc.AddInput(maxvals);

         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="shape">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="seed"></param>
      ///<param name="seed2"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation TruncatedNormal (  Output shape , DataType dtype, long seed = 0 , long seed2 = 0 ,String opName= "TruncatedNormal" ) 
      {
         OperationDescription desc = NewOperation("TruncatedNormal", opName);
         desc.AddInput(shape);
         desc.SetAttr("dtype", dtype);
         if (seed != 0) desc.SetAttr("seed", seed);
         if (seed2 != 0) desc.SetAttr("seed2", seed2);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="alpha">Input to the operation. </param>
      ///<param name="sample">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation RandomGammaGrad (  Output alpha , Output sample ,String opName= "RandomGammaGrad" ) 
      {
         OperationDescription desc = NewOperation("RandomGammaGrad", opName);
         desc.AddInput(alpha);
         desc.AddInput(sample);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="shape">Input to the operation. </param>
      ///<param name="seed">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation StatelessRandomNormal (  Output shape , Output seed , DataType? dtype = null ,String opName= "StatelessRandomNormal" ) 
      {
         OperationDescription desc = NewOperation("StatelessRandomNormal", opName);
         desc.AddInput(shape);
         desc.AddInput(seed);

         if (dtype.HasValue) desc.SetAttr("dtype", dtype.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="shape">Input to the operation. </param>
      ///<param name="seed">Input to the operation. </param>
      ///<param name="dtype"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation StatelessTruncatedNormal (  Output shape , Output seed , DataType? dtype = null ,String opName= "StatelessTruncatedNormal" ) 
      {
         OperationDescription desc = NewOperation("StatelessTruncatedNormal", opName);
         desc.AddInput(shape);
         desc.AddInput(seed);

         if (dtype.HasValue) desc.SetAttr("dtype", dtype.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="logits">Input to the operation. </param>
      ///<param name="num_samples">Input to the operation. </param>
      ///<param name="seed">Input to the operation. </param>
      ///<param name="output_dtype"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation StatelessMultinomial (  Output logits , Output num_samples , Output seed , DataType? output_dtype = null ,String opName= "StatelessMultinomial" ) 
      {
         OperationDescription desc = NewOperation("StatelessMultinomial", opName);
         desc.AddInput(logits);
         desc.AddInput(num_samples);
         desc.AddInput(seed);

         if (output_dtype.HasValue) desc.SetAttr("output_dtype", output_dtype.Value);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="pattern">Input to the operation. </param>
      ///<param name="rewrite">Input to the operation. </param>
      ///<param name="replace_global"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtString).
      ///</return>
      public Operation RegexReplace (  Output input , Output pattern , Output rewrite , bool replace_global = true ,String opName= "RegexReplace" ) 
      {
         OperationDescription desc = NewOperation("RegexReplace", opName);
         desc.AddInput(input);
         desc.AddInput(pattern);
         desc.AddInput(rewrite);

         if (replace_global != true) desc.SetAttr("replace_global", replace_global);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="pattern">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtBool).
      ///</return>
      public Operation RegexFullMatch (  Output input , Output pattern ,String opName= "RegexFullMatch" ) 
      {
         OperationDescription desc = NewOperation("RegexFullMatch", opName);
         desc.AddInput(input);
         desc.AddInput(pattern);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="num_buckets"></param>
      ///<param name="key"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInt64).
      ///</return>
      public Operation StringToHashBucketStrong (  Output input , long num_buckets, long[] key,String opName= "StringToHashBucketStrong" ) 
      {
         OperationDescription desc = NewOperation("StringToHashBucketStrong", opName);
         desc.AddInput(input);
         desc.SetAttr("num_buckets", num_buckets);
         desc.SetAttr("key", key);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="precision"></param>
      ///<param name="scientific"></param>
      ///<param name="shortest"></param>
      ///<param name="width"></param>
      ///<param name="fill"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtString).
      ///</return>
      public Operation AsString (  Output input , long precision = -1 , bool scientific = false , bool shortest = false , long width = -1 , string fill = null ,String opName= "AsString" ) 
      {
         OperationDescription desc = NewOperation("AsString", opName);
         desc.AddInput(input);

         if (precision != -1) desc.SetAttr("precision", precision);
         if (scientific != false) desc.SetAttr("scientific", scientific);
         if (shortest != false) desc.SetAttr("shortest", shortest);
         if (width != -1) desc.SetAttr("width", width);
         if (fill != null) desc.SetAttr("fill", fill);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="inputs">Input to the operation. </param>
      ///<param name="separator"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtString).
      ///</return>
      public Operation StringJoin (  Output inputs , string separator = null ,String opName= "StringJoin" ) 
      {
         OperationDescription desc = NewOperation("StringJoin", opName);
         desc.AddInput(inputs);

         if (separator != null) desc.SetAttr("separator", separator);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="delimiter">Input to the operation. </param>
      ///<param name="skip_empty"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] indices(type: DtInt64).
      ///[1] values(type: DtString).
      ///[2] shape(type: DtInt64).
      ///</return>
      public Operation StringSplit (  Output input , Output delimiter , bool skip_empty = true ,String opName= "StringSplit" ) 
      {
         OperationDescription desc = NewOperation("StringSplit", opName);
         desc.AddInput(input);
         desc.AddInput(delimiter);

         if (skip_empty != true) desc.SetAttr("skip_empty", skip_empty);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="sep">Input to the operation. </param>
      ///<param name="maxsplit"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] indices(type: DtInt64).
      ///[1] values(type: DtString).
      ///[2] shape(type: DtInt64).
      ///</return>
      public Operation StringSplitV2 (  Output input , Output sep , long maxsplit = -1 ,String opName= "StringSplitV2" ) 
      {
         OperationDescription desc = NewOperation("StringSplitV2", opName);
         desc.AddInput(input);
         desc.AddInput(sep);

         if (maxsplit != -1) desc.SetAttr("maxsplit", maxsplit);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInt32).
      ///</return>
      public Operation StringLength (  Output input ,String opName= "StringLength" ) 
      {
         OperationDescription desc = NewOperation("StringLength", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="pos">Input to the operation. </param>
      ///<param name="len">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtString).
      ///</return>
      public Operation Substr (  Output input , Output pos , Output len ,String opName= "Substr" ) 
      {
         OperationDescription desc = NewOperation("Substr", opName);
         desc.AddInput(input);
         desc.AddInput(pos);
         desc.AddInput(len);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="pad"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtString).
      ///</return>
      public Operation EncodeBase64 (  Output input , bool pad = false ,String opName= "EncodeBase64" ) 
      {
         OperationDescription desc = NewOperation("EncodeBase64", opName);
         desc.AddInput(input);

         if (pad != false) desc.SetAttr("pad", pad);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtString).
      ///</return>
      public Operation DecodeBase64 (  Output input ,String opName= "DecodeBase64" ) 
      {
         OperationDescription desc = NewOperation("DecodeBase64", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="shared_name"></param>
      ///<param name="container"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] writer(type: DtResource).
      ///</return>
      public Operation SummaryWriter (  string shared_name = null , string container = null ,String opName= "SummaryWriter" ) 
      {
         OperationDescription desc = NewOperation("SummaryWriter", opName);


         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         if (container != null) desc.SetAttr("container", container);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="writer">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation FlushSummaryWriter (  Output writer ,String opName= "FlushSummaryWriter" ) 
      {
         OperationDescription desc = NewOperation("FlushSummaryWriter", opName);
         desc.AddInput(writer);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="writer">Input to the operation. </param>
      ///<param name="step">Input to the operation. </param>
      ///<param name="tensor">Input to the operation. </param>
      ///<param name="tag">Input to the operation. </param>
      ///<param name="summary_metadata">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation WriteSummary (  Output writer , Output step , Output tensor , Output tag , Output summary_metadata ,String opName= "WriteSummary" ) 
      {
         OperationDescription desc = NewOperation("WriteSummary", opName);
         desc.AddInput(writer);
         desc.AddInput(step);
         desc.AddInput(tensor);
         desc.AddInput(tag);
         desc.AddInput(summary_metadata);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="writer">Input to the operation. </param>
      ///<param name="tfEvent">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation ImportEvent (  Output writer , Output tfEvent ,String opName= "ImportEvent" ) 
      {
         OperationDescription desc = NewOperation("ImportEvent", opName);
         desc.AddInput(writer);
         desc.AddInput(tfEvent);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="writer">Input to the operation. </param>
      ///<param name="step">Input to the operation. </param>
      ///<param name="tag">Input to the operation. </param>
      ///<param name="tensor">Input to the operation. </param>
      ///<param name="bad_color">Input to the operation. </param>
      ///<param name="max_images"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation WriteImageSummary (  Output writer , Output step , Output tag , Output tensor , Output bad_color , long max_images = 3 ,String opName= "WriteImageSummary" ) 
      {
         OperationDescription desc = NewOperation("WriteImageSummary", opName);
         desc.AddInput(writer);
         desc.AddInput(step);
         desc.AddInput(tag);
         desc.AddInput(tensor);
         desc.AddInput(bad_color);

         if (max_images != 3) desc.SetAttr("max_images", max_images);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="writer">Input to the operation. </param>
      ///<param name="step">Input to the operation. </param>
      ///<param name="tensor">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      public Operation WriteGraphSummary (  Output writer , Output step , Output tensor ,String opName= "WriteGraphSummary" ) 
      {
         OperationDescription desc = NewOperation("WriteGraphSummary", opName);
         desc.AddInput(writer);
         desc.AddInput(step);
         desc.AddInput(tensor);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="shape"></param>
      ///<param name="dtype"></param>
      ///<param name="container"></param>
      ///<param name="shared_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] ref(type: DtInvalid).
      ///</return>
      public Operation VariableV2 (  long[] shape, DataType dtype, string container = null , string shared_name = null ,String opName= "VariableV2" ) 
      {
         OperationDescription desc = NewOperation("VariableV2", opName);

         desc.SetAttrShape("shape", shape);
         desc.SetAttr("dtype", dtype);
         if (container != null) desc.SetAttr("container", container);
         if (shared_name != null) desc.SetAttr("shared_name", shared_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reference">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] is_initialized(type: DtBool).
      ///</return>
      public Operation IsVariableInitialized (  Output reference ,String opName= "IsVariableInitialized" ) 
      {
         OperationDescription desc = NewOperation("IsVariableInitialized", opName);
         desc.AddInput(reference);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="shape"></param>
      ///<param name="dtype"></param>
      ///<param name="var_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] ref(type: DtInvalid).
      ///</return>
      public Operation TemporaryVariable (  long[] shape, DataType dtype, string var_name = null ,String opName= "TemporaryVariable" ) 
      {
         OperationDescription desc = NewOperation("TemporaryVariable", opName);

         desc.SetAttrShape("shape", shape);
         desc.SetAttr("dtype", dtype);
         if (var_name != null) desc.SetAttr("var_name", var_name);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reference">Input to the operation. </param>
      ///<param name="var_name"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] value(type: DtInvalid).
      ///</return>
      public Operation DestroyTemporaryVariable (  Output reference , string var_name,String opName= "DestroyTemporaryVariable" ) 
      {
         OperationDescription desc = NewOperation("DestroyTemporaryVariable", opName);
         desc.AddInput(reference);
         desc.SetAttr("var_name", var_name);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reference">Input to the operation. </param>
      ///<param name="value">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_ref(type: DtInvalid).
      ///</return>
      public Operation AssignSub (  Output reference , Output value , bool use_locking = false ,String opName= "AssignSub" ) 
      {
         OperationDescription desc = NewOperation("AssignSub", opName);
         desc.AddInput(reference);
         desc.AddInput(value);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reference">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="updates">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_ref(type: DtInvalid).
      ///</return>
      public Operation ScatterMin (  Output reference , Output indices , Output updates , bool use_locking = false ,String opName= "ScatterMin" ) 
      {
         OperationDescription desc = NewOperation("ScatterMin", opName);
         desc.AddInput(reference);
         desc.AddInput(indices);
         desc.AddInput(updates);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reference">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="updates">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceScatterNdUpdate (  Output reference , Output indices , Output updates , bool use_locking = true ,String opName= "ResourceScatterNdUpdate" ) 
      {
         OperationDescription desc = NewOperation("ResourceScatterNdUpdate", opName);
         desc.AddInput(reference);
         desc.AddInput(indices);
         desc.AddInput(updates);

         if (use_locking != true) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="reference">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="updates">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output_ref(type: DtInvalid).
      ///</return>
      public Operation ScatterNdAdd (  Output reference , Output indices , Output updates , bool use_locking = false ,String opName= "ScatterNdAdd" ) 
      {
         OperationDescription desc = NewOperation("ScatterNdAdd", opName);
         desc.AddInput(reference);
         desc.AddInput(indices);
         desc.AddInput(updates);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="alpha">Input to the operation. </param>
      ///<param name="l1">Input to the operation. </param>
      ///<param name="l2">Input to the operation. </param>
      ///<param name="delta">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceApplyProximalGradientDescent (  Output var , Output alpha , Output l1 , Output l2 , Output delta , bool use_locking = false ,String opName= "ResourceApplyProximalGradientDescent" ) 
      {
         OperationDescription desc = NewOperation("ResourceApplyProximalGradientDescent", opName);
         desc.AddInput(var);
         desc.AddInput(alpha);
         desc.AddInput(l1);
         desc.AddInput(l2);
         desc.AddInput(delta);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="accum_update">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="rho">Input to the operation. </param>
      ///<param name="epsilon">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation ApplyAdadelta (  Output var , Output accum , Output accum_update , Output lr , Output rho , Output epsilon , Output grad , bool use_locking = false ,String opName= "ApplyAdadelta" ) 
      {
         OperationDescription desc = NewOperation("ApplyAdadelta", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(accum_update);
         desc.AddInput(lr);
         desc.AddInput(rho);
         desc.AddInput(epsilon);
         desc.AddInput(grad);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="accum_update">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="rho">Input to the operation. </param>
      ///<param name="epsilon">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceApplyAdadelta (  Output var , Output accum , Output accum_update , Output lr , Output rho , Output epsilon , Output grad , bool use_locking = false ,String opName= "ResourceApplyAdadelta" ) 
      {
         OperationDescription desc = NewOperation("ResourceApplyAdadelta", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(accum_update);
         desc.AddInput(lr);
         desc.AddInput(rho);
         desc.AddInput(epsilon);
         desc.AddInput(grad);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="accum_update">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="rho">Input to the operation. </param>
      ///<param name="epsilon">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceSparseApplyAdadelta (  Output var , Output accum , Output accum_update , Output lr , Output rho , Output epsilon , Output grad , Output indices , bool use_locking = false ,String opName= "ResourceSparseApplyAdadelta" ) 
      {
         OperationDescription desc = NewOperation("ResourceSparseApplyAdadelta", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(accum_update);
         desc.AddInput(lr);
         desc.AddInput(rho);
         desc.AddInput(epsilon);
         desc.AddInput(grad);
         desc.AddInput(indices);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="update_slots"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceApplyAdagrad (  Output var , Output accum , Output lr , Output grad , bool use_locking = false , bool update_slots = true ,String opName= "ResourceApplyAdagrad" ) 
      {
         OperationDescription desc = NewOperation("ResourceApplyAdagrad", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(lr);
         desc.AddInput(grad);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         if (update_slots != true) desc.SetAttr("update_slots", update_slots);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="l1">Input to the operation. </param>
      ///<param name="l2">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceApplyProximalAdagrad (  Output var , Output accum , Output lr , Output l1 , Output l2 , Output grad , bool use_locking = false ,String opName= "ResourceApplyProximalAdagrad" ) 
      {
         OperationDescription desc = NewOperation("ResourceApplyProximalAdagrad", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(lr);
         desc.AddInput(l1);
         desc.AddInput(l2);
         desc.AddInput(grad);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="gradient_accumulator">Input to the operation. </param>
      ///<param name="gradient_squared_accumulator">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="l1">Input to the operation. </param>
      ///<param name="l2">Input to the operation. </param>
      ///<param name="global_step">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation ApplyAdagradDA (  Output var , Output gradient_accumulator , Output gradient_squared_accumulator , Output grad , Output lr , Output l1 , Output l2 , Output global_step , bool use_locking = false ,String opName= "ApplyAdagradDA" ) 
      {
         OperationDescription desc = NewOperation("ApplyAdagradDA", opName);
         desc.AddInput(var);
         desc.AddInput(gradient_accumulator);
         desc.AddInput(gradient_squared_accumulator);
         desc.AddInput(grad);
         desc.AddInput(lr);
         desc.AddInput(l1);
         desc.AddInput(l2);
         desc.AddInput(global_step);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="mg">Input to the operation. </param>
      ///<param name="ms">Input to the operation. </param>
      ///<param name="mom">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="rho">Input to the operation. </param>
      ///<param name="momentum">Input to the operation. </param>
      ///<param name="epsilon">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation SparseApplyCenteredRMSProp (  Output var , Output mg , Output ms , Output mom , Output lr , Output rho , Output momentum , Output epsilon , Output grad , Output indices , bool use_locking = false ,String opName= "SparseApplyCenteredRMSProp" ) 
      {
         OperationDescription desc = NewOperation("SparseApplyCenteredRMSProp", opName);
         desc.AddInput(var);
         desc.AddInput(mg);
         desc.AddInput(ms);
         desc.AddInput(mom);
         desc.AddInput(lr);
         desc.AddInput(rho);
         desc.AddInput(momentum);
         desc.AddInput(epsilon);
         desc.AddInput(grad);
         desc.AddInput(indices);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="gradient_accumulator">Input to the operation. </param>
      ///<param name="gradient_squared_accumulator">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="l1">Input to the operation. </param>
      ///<param name="l2">Input to the operation. </param>
      ///<param name="global_step">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation SparseApplyAdagradDA (  Output var , Output gradient_accumulator , Output gradient_squared_accumulator , Output grad , Output indices , Output lr , Output l1 , Output l2 , Output global_step , bool use_locking = false ,String opName= "SparseApplyAdagradDA" ) 
      {
         OperationDescription desc = NewOperation("SparseApplyAdagradDA", opName);
         desc.AddInput(var);
         desc.AddInput(gradient_accumulator);
         desc.AddInput(gradient_squared_accumulator);
         desc.AddInput(grad);
         desc.AddInput(indices);
         desc.AddInput(lr);
         desc.AddInput(l1);
         desc.AddInput(l2);
         desc.AddInput(global_step);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="l1">Input to the operation. </param>
      ///<param name="l2">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceSparseApplyProximalAdagrad (  Output var , Output accum , Output lr , Output l1 , Output l2 , Output grad , Output indices , bool use_locking = false ,String opName= "ResourceSparseApplyProximalAdagrad" ) 
      {
         OperationDescription desc = NewOperation("ResourceSparseApplyProximalAdagrad", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(lr);
         desc.AddInput(l1);
         desc.AddInput(l2);
         desc.AddInput(grad);
         desc.AddInput(indices);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="linear">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="l1">Input to the operation. </param>
      ///<param name="l2">Input to the operation. </param>
      ///<param name="lr_power">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation SparseApplyFtrl (  Output var , Output accum , Output linear , Output grad , Output indices , Output lr , Output l1 , Output l2 , Output lr_power , bool use_locking = false ,String opName= "SparseApplyFtrl" ) 
      {
         OperationDescription desc = NewOperation("SparseApplyFtrl", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(linear);
         desc.AddInput(grad);
         desc.AddInput(indices);
         desc.AddInput(lr);
         desc.AddInput(l1);
         desc.AddInput(l2);
         desc.AddInput(lr_power);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="linear">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="l1">Input to the operation. </param>
      ///<param name="l2">Input to the operation. </param>
      ///<param name="lr_power">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceApplyFtrl (  Output var , Output accum , Output linear , Output grad , Output lr , Output l1 , Output l2 , Output lr_power , bool use_locking = false ,String opName= "ResourceApplyFtrl" ) 
      {
         OperationDescription desc = NewOperation("ResourceApplyFtrl", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(linear);
         desc.AddInput(grad);
         desc.AddInput(lr);
         desc.AddInput(l1);
         desc.AddInput(l2);
         desc.AddInput(lr_power);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="linear">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="l1">Input to the operation. </param>
      ///<param name="l2">Input to the operation. </param>
      ///<param name="l2_shrinkage">Input to the operation. </param>
      ///<param name="lr_power">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceApplyFtrlV2 (  Output var , Output accum , Output linear , Output grad , Output lr , Output l1 , Output l2 , Output l2_shrinkage , Output lr_power , bool use_locking = false ,String opName= "ResourceApplyFtrlV2" ) 
      {
         OperationDescription desc = NewOperation("ResourceApplyFtrlV2", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(linear);
         desc.AddInput(grad);
         desc.AddInput(lr);
         desc.AddInput(l1);
         desc.AddInput(l2);
         desc.AddInput(l2_shrinkage);
         desc.AddInput(lr_power);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="momentum">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="use_nesterov"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation SparseApplyMomentum (  Output var , Output accum , Output lr , Output grad , Output indices , Output momentum , bool use_locking = false , bool use_nesterov = false ,String opName= "SparseApplyMomentum" ) 
      {
         OperationDescription desc = NewOperation("SparseApplyMomentum", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(lr);
         desc.AddInput(grad);
         desc.AddInput(indices);
         desc.AddInput(momentum);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         if (use_nesterov != false) desc.SetAttr("use_nesterov", use_nesterov);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="accum">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="indices">Input to the operation. </param>
      ///<param name="momentum">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="use_nesterov"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceSparseApplyMomentum (  Output var , Output accum , Output lr , Output grad , Output indices , Output momentum , bool use_locking = false , bool use_nesterov = false ,String opName= "ResourceSparseApplyMomentum" ) 
      {
         OperationDescription desc = NewOperation("ResourceSparseApplyMomentum", opName);
         desc.AddInput(var);
         desc.AddInput(accum);
         desc.AddInput(lr);
         desc.AddInput(grad);
         desc.AddInput(indices);
         desc.AddInput(momentum);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         if (use_nesterov != false) desc.SetAttr("use_nesterov", use_nesterov);
         return desc.FinishOperation();
      } 
      // Skipped function _ArrayToList

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="ms">Input to the operation. </param>
      ///<param name="mom">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="rho">Input to the operation. </param>
      ///<param name="momentum">Input to the operation. </param>
      ///<param name="epsilon">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation ApplyRMSProp (  Output var , Output ms , Output mom , Output lr , Output rho , Output momentum , Output epsilon , Output grad , bool use_locking = false ,String opName= "ApplyRMSProp" ) 
      {
         OperationDescription desc = NewOperation("ApplyRMSProp", opName);
         desc.AddInput(var);
         desc.AddInput(ms);
         desc.AddInput(mom);
         desc.AddInput(lr);
         desc.AddInput(rho);
         desc.AddInput(momentum);
         desc.AddInput(epsilon);
         desc.AddInput(grad);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="mg">Input to the operation. </param>
      ///<param name="ms">Input to the operation. </param>
      ///<param name="mom">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="rho">Input to the operation. </param>
      ///<param name="momentum">Input to the operation. </param>
      ///<param name="epsilon">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] out(type: DtInvalid).
      ///</return>
      public Operation ApplyCenteredRMSProp (  Output var , Output mg , Output ms , Output mom , Output lr , Output rho , Output momentum , Output epsilon , Output grad , bool use_locking = false ,String opName= "ApplyCenteredRMSProp" ) 
      {
         OperationDescription desc = NewOperation("ApplyCenteredRMSProp", opName);
         desc.AddInput(var);
         desc.AddInput(mg);
         desc.AddInput(ms);
         desc.AddInput(mom);
         desc.AddInput(lr);
         desc.AddInput(rho);
         desc.AddInput(momentum);
         desc.AddInput(epsilon);
         desc.AddInput(grad);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="ms">Input to the operation. </param>
      ///<param name="mom">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="rho">Input to the operation. </param>
      ///<param name="momentum">Input to the operation. </param>
      ///<param name="epsilon">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceApplyRMSProp (  Output var , Output ms , Output mom , Output lr , Output rho , Output momentum , Output epsilon , Output grad , bool use_locking = false ,String opName= "ResourceApplyRMSProp" ) 
      {
         OperationDescription desc = NewOperation("ResourceApplyRMSProp", opName);
         desc.AddInput(var);
         desc.AddInput(ms);
         desc.AddInput(mom);
         desc.AddInput(lr);
         desc.AddInput(rho);
         desc.AddInput(momentum);
         desc.AddInput(epsilon);
         desc.AddInput(grad);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="var">Input to the operation. </param>
      ///<param name="mg">Input to the operation. </param>
      ///<param name="ms">Input to the operation. </param>
      ///<param name="mom">Input to the operation. </param>
      ///<param name="lr">Input to the operation. </param>
      ///<param name="rho">Input to the operation. </param>
      ///<param name="momentum">Input to the operation. </param>
      ///<param name="epsilon">Input to the operation. </param>
      ///<param name="grad">Input to the operation. </param>
      ///<param name="use_locking"></param>
      ///<param name="opName">The name of the operation</param>
      public Operation ResourceApplyCenteredRMSProp (  Output var , Output mg , Output ms , Output mom , Output lr , Output rho , Output momentum , Output epsilon , Output grad , bool use_locking = false ,String opName= "ResourceApplyCenteredRMSProp" ) 
      {
         OperationDescription desc = NewOperation("ResourceApplyCenteredRMSProp", opName);
         desc.AddInput(var);
         desc.AddInput(mg);
         desc.AddInput(ms);
         desc.AddInput(mom);
         desc.AddInput(lr);
         desc.AddInput(rho);
         desc.AddInput(momentum);
         desc.AddInput(epsilon);
         desc.AddInput(grad);

         if (use_locking != false) desc.SetAttr("use_locking", use_locking);
         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="filename"></param>
      ///<param name="batch_size"></param>
      ///<param name="window_size"></param>
      ///<param name="min_count"></param>
      ///<param name="subsample"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] vocab_word(type: DtString).
      ///[1] vocab_freq(type: DtInt32).
      ///[2] words_per_epoch(type: DtInt64).
      ///[3] current_epoch(type: DtInt32).
      ///[4] total_words_processed(type: DtInt64).
      ///[5] examples(type: DtInt32).
      ///[6] labels(type: DtInt32).
      ///</return>
      public Operation Skipgram (  string filename, long batch_size, long window_size = 5 , long min_count = 5 , float subsample = 0.001f ,String opName= "Skipgram" ) 
      {
         OperationDescription desc = NewOperation("Skipgram", opName);

         desc.SetAttr("filename", filename);
         desc.SetAttr("batch_size", batch_size);
         if (window_size != 5) desc.SetAttr("window_size", window_size);
         if (min_count != 5) desc.SetAttr("min_count", min_count);
         if (subsample != 0.001f) desc.SetAttr("subsample", subsample);
         return desc.FinishOperation();
      } 
      // Skipped function _Arg
      // Skipped function _Retval

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="Tout"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      //The following attributes are not known: f: func
      public Operation SymbolicGradient (  Output input , DataType[] Tout,String opName= "SymbolicGradient" ) 
      {
         OperationDescription desc = NewOperation("SymbolicGradient", opName);
         desc.AddInput(input);
         desc.SetAttr("Tout", Tout);

         return desc.FinishOperation();
      } 
      // Skipped function _While

      ///<summary>
      ///
      ///</summary>
      ///<param name="input">Input to the operation. </param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      //The following attributes are not known: cond: func; body: func
      public Operation StatelessWhile (  Output input ,String opName= "StatelessWhile" ) 
      {
         OperationDescription desc = NewOperation("StatelessWhile", opName);
         desc.AddInput(input);


         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="args">Input to the operation. </param>
      ///<param name="Tout"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      //The following attributes are not known: f: func
      public Operation StatefulPartitionedCall (  Output args , DataType[] Tout,String opName= "StatefulPartitionedCall" ) 
      {
         OperationDescription desc = NewOperation("StatefulPartitionedCall", opName);
         desc.AddInput(args);
         desc.SetAttr("Tout", Tout);

         return desc.FinishOperation();
      } 

      ///<summary>
      ///
      ///</summary>
      ///<param name="dtype"></param>
      ///<param name="shape"></param>
      ///<param name="opName">The name of the operation</param>
      ///<return>
      ///[0] output(type: DtInvalid).
      ///</return>
      public Operation FakeParam (  DataType dtype, long[] shape,String opName= "FakeParam" ) 
      {
         OperationDescription desc = NewOperation("FakeParam", opName);

         desc.SetAttr("dtype", dtype);
         desc.SetAttrShape("shape", shape);

         return desc.FinishOperation();
      } 
      // Skipped function _HostSend
      // Skipped function _HostRecv
   }
}