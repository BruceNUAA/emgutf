// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/core/protobuf/rewriter_config.proto
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Tensorflow {

  /// <summary>Holder for reflection information generated from tensorflow/core/protobuf/rewriter_config.proto</summary>
  public static partial class RewriterConfigReflection {

    #region Descriptor
    /// <summary>File descriptor for tensorflow/core/protobuf/rewriter_config.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static RewriterConfigReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Ci50ZW5zb3JmbG93L2NvcmUvcHJvdG9idWYvcmV3cml0ZXJfY29uZmlnLnBy",
            "b3RvEgp0ZW5zb3JmbG93IjsKE0F1dG9QYXJhbGxlbE9wdGlvbnMSDgoGZW5h",
            "YmxlGAEgASgIEhQKDG51bV9yZXBsaWNhcxgCIAEoBSKjAgoOUmV3cml0ZXJD",
            "b25maWcSHgoWb3B0aW1pemVfdGVuc29yX2xheW91dBgBIAEoCBIdChVkaXNh",
            "YmxlX21vZGVsX3BydW5pbmcYAiABKAgSGAoQY29uc3RhbnRfZm9sZGluZxgD",
            "IAEoCBJCChNtZW1vcnlfb3B0aW1pemF0aW9uGAQgASgOMiUudGVuc29yZmxv",
            "dy5SZXdyaXRlckNvbmZpZy5NZW1PcHRUeXBlEjYKDWF1dG9fcGFyYWxsZWwY",
            "BSABKAsyHy50ZW5zb3JmbG93LkF1dG9QYXJhbGxlbE9wdGlvbnMSEgoKb3B0",
            "aW1pemVycxhkIAMoCSIoCgpNZW1PcHRUeXBlEg4KCk5PX01FTV9PUFQQABIK",
            "CgZNQU5VQUwQAUI1ChhvcmcudGVuc29yZmxvdy5mcmFtZXdvcmtCFFJld3Jp",
            "dGVyQ29uZmlnUHJvdG9zUAH4AQFiBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.AutoParallelOptions), global::Tensorflow.AutoParallelOptions.Parser, new[]{ "Enable", "NumReplicas" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.RewriterConfig), global::Tensorflow.RewriterConfig.Parser, new[]{ "OptimizeTensorLayout", "DisableModelPruning", "ConstantFolding", "MemoryOptimization", "AutoParallel", "Optimizers" }, null, new[]{ typeof(global::Tensorflow.RewriterConfig.Types.MemOptType) }, null)
          }));
    }
    #endregion

  }
  #region Messages
  public sealed partial class AutoParallelOptions : pb::IMessage<AutoParallelOptions> {
    private static readonly pb::MessageParser<AutoParallelOptions> _parser = new pb::MessageParser<AutoParallelOptions>(() => new AutoParallelOptions());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<AutoParallelOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.RewriterConfigReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AutoParallelOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AutoParallelOptions(AutoParallelOptions other) : this() {
      enable_ = other.enable_;
      numReplicas_ = other.numReplicas_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AutoParallelOptions Clone() {
      return new AutoParallelOptions(this);
    }

    /// <summary>Field number for the "enable" field.</summary>
    public const int EnableFieldNumber = 1;
    private bool enable_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Enable {
      get { return enable_; }
      set {
        enable_ = value;
      }
    }

    /// <summary>Field number for the "num_replicas" field.</summary>
    public const int NumReplicasFieldNumber = 2;
    private int numReplicas_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int NumReplicas {
      get { return numReplicas_; }
      set {
        numReplicas_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as AutoParallelOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(AutoParallelOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Enable != other.Enable) return false;
      if (NumReplicas != other.NumReplicas) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Enable != false) hash ^= Enable.GetHashCode();
      if (NumReplicas != 0) hash ^= NumReplicas.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Enable != false) {
        output.WriteRawTag(8);
        output.WriteBool(Enable);
      }
      if (NumReplicas != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(NumReplicas);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Enable != false) {
        size += 1 + 1;
      }
      if (NumReplicas != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(NumReplicas);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(AutoParallelOptions other) {
      if (other == null) {
        return;
      }
      if (other.Enable != false) {
        Enable = other.Enable;
      }
      if (other.NumReplicas != 0) {
        NumReplicas = other.NumReplicas;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Enable = input.ReadBool();
            break;
          }
          case 16: {
            NumReplicas = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Graph rewriting is experimental and subject to change, not subject to any
  /// API guarantees.
  /// </summary>
  public sealed partial class RewriterConfig : pb::IMessage<RewriterConfig> {
    private static readonly pb::MessageParser<RewriterConfig> _parser = new pb::MessageParser<RewriterConfig>(() => new RewriterConfig());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RewriterConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.RewriterConfigReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RewriterConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RewriterConfig(RewriterConfig other) : this() {
      optimizeTensorLayout_ = other.optimizeTensorLayout_;
      disableModelPruning_ = other.disableModelPruning_;
      constantFolding_ = other.constantFolding_;
      memoryOptimization_ = other.memoryOptimization_;
      AutoParallel = other.autoParallel_ != null ? other.AutoParallel.Clone() : null;
      optimizers_ = other.optimizers_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RewriterConfig Clone() {
      return new RewriterConfig(this);
    }

    /// <summary>Field number for the "optimize_tensor_layout" field.</summary>
    public const int OptimizeTensorLayoutFieldNumber = 1;
    private bool optimizeTensorLayout_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool OptimizeTensorLayout {
      get { return optimizeTensorLayout_; }
      set {
        optimizeTensorLayout_ = value;
      }
    }

    /// <summary>Field number for the "disable_model_pruning" field.</summary>
    public const int DisableModelPruningFieldNumber = 2;
    private bool disableModelPruning_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool DisableModelPruning {
      get { return disableModelPruning_; }
      set {
        disableModelPruning_ = value;
      }
    }

    /// <summary>Field number for the "constant_folding" field.</summary>
    public const int ConstantFoldingFieldNumber = 3;
    private bool constantFolding_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool ConstantFolding {
      get { return constantFolding_; }
      set {
        constantFolding_ = value;
      }
    }

    /// <summary>Field number for the "memory_optimization" field.</summary>
    public const int MemoryOptimizationFieldNumber = 4;
    private global::Tensorflow.RewriterConfig.Types.MemOptType memoryOptimization_ = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.RewriterConfig.Types.MemOptType MemoryOptimization {
      get { return memoryOptimization_; }
      set {
        memoryOptimization_ = value;
      }
    }

    /// <summary>Field number for the "auto_parallel" field.</summary>
    public const int AutoParallelFieldNumber = 5;
    private global::Tensorflow.AutoParallelOptions autoParallel_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.AutoParallelOptions AutoParallel {
      get { return autoParallel_; }
      set {
        autoParallel_ = value;
      }
    }

    /// <summary>Field number for the "optimizers" field.</summary>
    public const int OptimizersFieldNumber = 100;
    private static readonly pb::FieldCodec<string> _repeated_optimizers_codec
        = pb::FieldCodec.ForString(802);
    private readonly pbc::RepeatedField<string> optimizers_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// If non-empty, will use this as an alternative way to specify a list of
    /// optimizations to turn on and the order of the optimizations.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Optimizers {
      get { return optimizers_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RewriterConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RewriterConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (OptimizeTensorLayout != other.OptimizeTensorLayout) return false;
      if (DisableModelPruning != other.DisableModelPruning) return false;
      if (ConstantFolding != other.ConstantFolding) return false;
      if (MemoryOptimization != other.MemoryOptimization) return false;
      if (!object.Equals(AutoParallel, other.AutoParallel)) return false;
      if(!optimizers_.Equals(other.optimizers_)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (OptimizeTensorLayout != false) hash ^= OptimizeTensorLayout.GetHashCode();
      if (DisableModelPruning != false) hash ^= DisableModelPruning.GetHashCode();
      if (ConstantFolding != false) hash ^= ConstantFolding.GetHashCode();
      if (MemoryOptimization != 0) hash ^= MemoryOptimization.GetHashCode();
      if (autoParallel_ != null) hash ^= AutoParallel.GetHashCode();
      hash ^= optimizers_.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (OptimizeTensorLayout != false) {
        output.WriteRawTag(8);
        output.WriteBool(OptimizeTensorLayout);
      }
      if (DisableModelPruning != false) {
        output.WriteRawTag(16);
        output.WriteBool(DisableModelPruning);
      }
      if (ConstantFolding != false) {
        output.WriteRawTag(24);
        output.WriteBool(ConstantFolding);
      }
      if (MemoryOptimization != 0) {
        output.WriteRawTag(32);
        output.WriteEnum((int) MemoryOptimization);
      }
      if (autoParallel_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(AutoParallel);
      }
      optimizers_.WriteTo(output, _repeated_optimizers_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (OptimizeTensorLayout != false) {
        size += 1 + 1;
      }
      if (DisableModelPruning != false) {
        size += 1 + 1;
      }
      if (ConstantFolding != false) {
        size += 1 + 1;
      }
      if (MemoryOptimization != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) MemoryOptimization);
      }
      if (autoParallel_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AutoParallel);
      }
      size += optimizers_.CalculateSize(_repeated_optimizers_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RewriterConfig other) {
      if (other == null) {
        return;
      }
      if (other.OptimizeTensorLayout != false) {
        OptimizeTensorLayout = other.OptimizeTensorLayout;
      }
      if (other.DisableModelPruning != false) {
        DisableModelPruning = other.DisableModelPruning;
      }
      if (other.ConstantFolding != false) {
        ConstantFolding = other.ConstantFolding;
      }
      if (other.MemoryOptimization != 0) {
        MemoryOptimization = other.MemoryOptimization;
      }
      if (other.autoParallel_ != null) {
        if (autoParallel_ == null) {
          autoParallel_ = new global::Tensorflow.AutoParallelOptions();
        }
        AutoParallel.MergeFrom(other.AutoParallel);
      }
      optimizers_.Add(other.optimizers_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            OptimizeTensorLayout = input.ReadBool();
            break;
          }
          case 16: {
            DisableModelPruning = input.ReadBool();
            break;
          }
          case 24: {
            ConstantFolding = input.ReadBool();
            break;
          }
          case 32: {
            memoryOptimization_ = (global::Tensorflow.RewriterConfig.Types.MemOptType) input.ReadEnum();
            break;
          }
          case 42: {
            if (autoParallel_ == null) {
              autoParallel_ = new global::Tensorflow.AutoParallelOptions();
            }
            input.ReadMessage(autoParallel_);
            break;
          }
          case 802: {
            optimizers_.AddEntriesFrom(input, _repeated_optimizers_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the RewriterConfig message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum MemOptType {
        /// <summary>
        /// Fully disabled
        /// </summary>
        [pbr::OriginalName("NO_MEM_OPT")] NoMemOpt = 0,
        /// <summary>
        /// Driven by manual annotations
        /// </summary>
        [pbr::OriginalName("MANUAL")] Manual = 1,
      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
